{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Boardfarm","text":"<p>Boardfarm is an open-source IT automation framework purely written in Python (3.11+).</p> <p>Its primary focus revolves around systems configuration, infrastructure deployment, and orchestration of advanced IT tasks such as Subscriber Provisioning, Line Termination System bootups (LTS) or a CPE firmware flash via bootloader.</p> <p>It empowers its users with the ability to automate and comprehensively test their devices across a wide range of target environments.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Boardfarm was initially developed at Qualcomm to automate testing of OpenWrt routers and other embedded devices.</p> <p></p> <p>Over time, the framework evolved to support RDK-B derived boards and IoT devices, along with the essential OSS and back-office components necessary for simulating a Telecom Service Providers' environment.</p> <p></p> <p>The operation of a device or the configuration of a server can vary depending on the specific hardware variant or the infrastructure layout of the deploying Telecom Operator.</p> <p>To address this variability, Boardfarm utilizes Pluggy to introduce a hook structure that enables its users to register customized code through plugins for each individual infrastructure component.</p> <p>This structure also enforces a uniform API specification, allowing plugins to invoke their implementation at any of the predefined checkpoints within the Boardfarm's execution cycle, offering flexibility and extensibility.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Modular Hook definitions enabling users to independently initiate the bootup/deployment process for each component within the infrastructure, offering granular control and flexibility.</li> <li>Seamless integration with Pytest. Provides easy access to devices along with their pre-set operations through protocol-specific libraries.</li> <li>A versatile connection manager that abstracts physical device connections, offering a unified set of APIs for RS232, SSH, Telnet, SNMP, and HTTP(s) communication with the infrastructure.</li> <li>A library of device templates (Python ABCs) that can be inherited and customized for implementing hardware interactions without application or server specific constraints.</li> <li>A plugin architecture that enables vendors and OEMs to perform testing and provisioning on their firmware builds/devices, whether in a predefined production or fully simulated test environment.</li> <li>Integration with Docker/QEMU to simulate various test environments and devices.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Run the following command to directly install the package from the repo:</p> <pre><code>pip install git+https://github.com/lgirdk/boardfarm.git\n</code></pre> <p>Run the following command to install from PyPI:</p> <pre><code>pip install boardfarm3\n</code></pre>"},{"location":"#plugin","title":"Plugin","text":"<p>If you also want to install Boardfarm\u2019s plugins for DOCSIS (<code>boardfarm3-docsis</code>) and Pytest (<code>pytest-boardfarm3</code>), you can install them together using extras:</p> <pre><code>pip install \"boardfarm3[docsis, pytest]\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>boardfarm -h\n</code></pre> <p>This will display help for the framework. Here are all the switches it supports.</p> <pre><code>usage: boardfarm [-h] --board-name BOARD_NAME --env-config ENV_CONFIG --inventory-config INVENTORY_CONFIG [--legacy] [--skip-boot] [--skip-contingency-checks] [--save-console-logs]\n\noptions:\n  -h, --help            show this help message and exit\n  --board-name BOARD_NAME\n                        Board name\n  --env-config ENV_CONFIG\n                        Environment JSON config file path\n  --inventory-config INVENTORY_CONFIG\n                        Inventory JSON config file path\n  --legacy              allows for devices.&lt;device&gt; obj to be exposed (only for legacy use)\n  --skip-boot           Skips the booting process, all devices will be used as they are\n  --skip-contingency-checks\n                        Skip contingency checks while running tests\n  --save-console-logs   Save console logs to the disk\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For full documentation, including installation, tutorials and architecture overview and how to run a prplOS demo with  a CPE, ACS, lan, wan devices, please see the following.</p> <p>Boardfarm Read the Docs</p>"},{"location":"#changelog","title":"Changelog","text":"<p>Consult the CHANGELOG page for fixes and enhancements of each version.</p>"},{"location":"#license","title":"License","text":"<p>Distributed under the terms of the Clear BSD License, Boardfarm is free and open source software.</p>"},{"location":"architecture/","title":"Overview","text":""},{"location":"architecture/#introduction","title":"Introduction","text":"<p>End-to-end (E2E) solutions for CPE, access and back-office stacks are inherently complex:</p> <ul> <li>they depend on many different components (CPE, ACS, DHCP, SIP, OSS/BSS, emulators, etc.),</li> <li>span multiple layers of integration,</li> <li>involve multi-vendor delivery, and</li> <li>evolve at varying development cadences with many transitive dependencies.</li> </ul> <p>At every integration level, each incremental change must be validated against multiple, evolving target deployment environments:</p> <ul> <li>different customers run different topologies and component versions,</li> <li>each environment changes over time, and</li> <li>late discovery or poor reproducibility of environment differences drives up cost and delays.</li> </ul>"},{"location":"architecture/#the-vendorteam-challenge","title":"The vendor/team challenge","text":"<p>Vendors and engineering teams must simultaneously:</p> <ul> <li>deliver new functionality,</li> <li>design, build, integrate and validate features, and</li> <li>avoid regressions \u2014 which requires large amounts of regression testing.</li> </ul> <p>To be effective, development and validation must happen against the relevant environments: using the particular versions and configurations of the neighbouring components that exist in a real E2E deployment.</p>"},{"location":"architecture/#architecture","title":"Architecture","text":"<p>Boardfarm\u2019s architecture is designed to address these realities by emphasizing:</p> <p></p> <ul> <li>Top-down (inward) dependencies only \u2014 stable, inner layers define contracts; outer layers implement them.</li> <li>Non-restrictive API standardization \u2014 provide clear, compact templates (ABCs) so use cases and tests stay vendor-agnostic.</li> <li>Maximized portability \u2014 make each layer easy to reuse across customers and testbeds.</li> <li>Extensibility via plugins \u2014 add new device classes, transports or behaviors as plugins rather than changing the core.</li> </ul>"},{"location":"architecture/#how-this-is-achieved","title":"How this is achieved","text":"<ul> <li>Templates (ABCs) define stable device APIs that use cases and hooks rely on.</li> <li>Concrete device classes implement those templates for vendors, emulators or transports.</li> <li>Pluggy (plugin manager + hooks) orchestrates multi-phase provisioning and lifecycle events across the infrastructure (boot, configure, attach, etc.).</li> <li>Use Cases protocol-specific, test-facing operations; the API tests and the interactive shell use.</li> </ul> <p>Together, these principles make Boardfarm a portable, testable framework that helps teams develop, validate and debug E2E functionality against representative, reproducible environments while minimizing the cost of integrating multi-vendor stacks.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#templates-abcs","title":"Templates (ABCs)","text":"<p>What they are: Python Abstract Base Classes that describe the minimal set of methods a device must offer for Boardfarm use cases to work.</p> <p>Why they matter: Use cases and hooks import these Templates, not concrete device classes. That guarantees portability: a test calls the template API, not vendor-specific code.</p> <p>Example sketch:</p> <pre><code>from abc import ABC, abstractmethod\n\nGpvInput = Union[str, list[str]]\nGpvStruct = dict[str, Union[str, int, bool]]\nGpvResponse = list[GpvStruct]\n\nclass ACS(ABC):\n    \"\"\"Boardfarm ACS device template.\"\"\"\n\n    @abstractmethod\n    def GPV(\n        self,\n        param: GpvInput,\n        timeout: int | None = None,\n        cpe_id: str | None = None,\n    ) -&gt; GpvResponse:\n        ...\n\n    ... # rest of the API definition\n</code></pre> <p>Guidelines:</p> <ul> <li>Keep signatures high-level and stable.</li> <li>Add capabilities via optional mixins or new ABCs rather than changing existing method signatures.</li> <li>Document expected return types and exceptions.</li> </ul>"},{"location":"architecture/#devices-concrete-implementations","title":"Devices (Concrete implementations)","text":"<p>What they are: Classes that implement a Template (ABC). They translate Template methods into transport-specific actions (SSH, serial, HTTP, local command, docker exec, QEMU socket, etc.).</p> <p>Important: Device classes may also implement device hooks (<code>hookspecs</code>) to participate in the boot/provision lifecycle \u2014 but those hook implementations should only call the templated APIs and perform device-specific I/O. Avoid exposing these vendor-specific private APIs to use cases.</p> <p>Example:</p> <pre><code>from boardfarm3.templates.acs import ACS, GpvInput, GpvResponse\n\nclass GenieACS(ACS):\n\n    def GPV(\n        self,\n        param: GpvInput,\n        timeout: int | None = None,\n        cpe_id: str | None = None,\n    ) -&gt; GpvResponse:\n        \"\"\"Send GetParamaterValues command via ACS server.\"\"\"\n        quoted_id = quote('{\"_id\":\"' + cpe_id + '\"}', safe=\"\")\n        self._request_post(\n            endpoint=\"/devices/\" + quote(cpe_id) + \"/tasks\",\n            data=self._build_input_structs_gpv(param),\n            conn_request=True,\n            timeout=timeout,\n        )\n        response_data = self._request_get(\n            \"/devices\"  # noqa: ISC003\n            + \"?query=\"\n            + quoted_id\n            + \"&amp;projection=\"\n            + self._build_input_structs(param),\n            timeout=timeout,\n        )\n        return GpvResponse(self._convert_response(response_data))\n\n    ... # rest of the implementation\n\n</code></pre> <p>Rules:</p> <ul> <li>Devices are only meant to drive I/O and vendor-specific quirks.</li> <li>Do not implement business logic in devices \u2014 they will always be implemented in use cases.</li> </ul>"},{"location":"architecture/#use-cases","title":"Use Cases","text":"<p>What they are: The library of testable, protocol-specific operations.</p>"},{"location":"architecture/#why-use-cases","title":"Why use cases?","text":"<ul> <li>Tests call use cases (e.g., GPV, flash_firmware) rather than device methods directly.</li> <li>Use cases hide which concrete device handles the operation \u2014 the Template contract ensures compatibility.</li> </ul> <p>Example:</p> <pre><code>\"\"\"TR-069 Use cases.\"\"\"\n\nfrom __future__ import annotations\n\nif TYPE_CHECKING:\n    from boardfarm3.templates.acs import ACS\n    from boardfarm3.templates.cpe import CPE\n\ndef get_parameter_values(\n    params: str | list[str],\n    acs: ACS,\n    board: CPE,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Perform TR-069 RPC call GetParameterValues.\"\"\"\n\n    return acs.GPV(params, cpe_id=board.sw.tr69_cpe_id)\n</code></pre> <p>Example usage (in IPython or pytest):</p> <pre><code>from boardfarm3.use_cases.tr069 import get_parameter_values\nfrom boardfarm3.templates.acs import ACS\nfrom boardfarm3.templates.cpe import CPE\n\nfrom boardfarm3.lib.device_manager import DeviceManager\n\nvalue = get_parameter_value(\n    'Device.DeviceInfo.Manufacturer',\n    device_manager.get_device_by_type(ACS),\n    device_manager.get_device_by_type(CPE),\n    )\n</code></pre>"},{"location":"architecture/#summary","title":"Summary","text":"<ul> <li>Stable contract (Template/ABC) \u2014 The ACS template (an ABC) declares the <code>GPV</code>(...) -&gt; <code>GpvResponse</code> API and the expected input/output types.</li> <li>Dependency inversion \u2014 Use cases (<code>get_parameter_values</code>) accept an ACS instance (the interface) rather than a concrete class.</li> <li>Pluggable device implementations \u2014 Concrete classes like <code>GenieACS</code> implement the ACS ABC and provide transport/vendor-specific logic.</li> <li>Runtime selection via DeviceManager \u2014 Tests call <code>device_manager.get_device_by_type(ACS)</code> to obtain any registered ACS device. The test code doesn\u2019t change when you swap GenieACS for AxirosACS (or a simulator).</li> <li>Easy mocking &amp; CI-friendly \u2014 You can inject fakes or mocks that implement the ACS interface for fast, deterministic unit tests and CI runs without hardware.</li> </ul> <p>Result: tests written against the ACS template are vendor-agnostic \u2014 you can run the same test suite against real hardware, vendor servers, or simulated ACS backends without changing test code.</p>"},{"location":"architecture/#hooks-specification-and-pluggy","title":"Hooks Specification and Pluggy","text":"<p>Boardfarm uses Pluggy as the central plugin manager. Pluggy provides the extension points (<code>@hookspecs</code>) that let different repositories register device classes, extend runner behaviour, and participate in the multi-phase environment boot/provision lifecycle. The design principle is simple:</p> <ul> <li>Framework (core) concerns are exposed as <code>core hooks</code> \u2014 used to customize runner behavior (CLI args, config parsing, device reservation, environment setup, device registration, release and shutdown).</li> <li>Device concerns are expressed as <code>device hooks</code> \u2014 implemented by concrete device classes (plugins) to perform boot, configuration, validation and shutdown for that device.</li> <li>The runner invokes core hooks to orchestrate the run; core hooks in turn cause the runner to call device hooks for each device in the configured order.</li> </ul>"},{"location":"architecture/#hook-categories-where-they-belong","title":"Hook categories &amp; where they belong","text":"<p>Core hooks (framework-level) \u2014 implemented by runner or plugin authors. These orchestrate the overall lifecycle of a run:</p> <ul> <li><code>boardfarm_add_cmdline_args(argparser)</code> \u2014 add CLI flags.</li> <li><code>boardfarm_parse_config(...) -&gt; BoardfarmConfig</code> (firstresult) \u2014 produce/override the merged run config.</li> <li><code>boardfarm_reserve_devices(...) -&gt; inventory</code> (firstresult) \u2014 reserve lab hardware before deployment.</li> <li><code>boardfarm_setup_env(...) -&gt; DeviceManager</code> (firstresult) \u2014 deploy devices and build the <code>DeviceManager</code>.</li> <li><code>boardfarm_register_devices(...) -&gt; DeviceManager</code> (firstresult) &amp; <code>boardfarm_add_devices()</code> \u2014 register device classes (map inventory <code>\"type\"</code> \u2192 class).</li> <li><code>boardfarm_release_devices(...)</code> &amp; <code>boardfarm_shutdown_device()</code> \u2014 release reserved devices and perform framework cleanup.</li> </ul> <p>Device hooks (device-level) \u2014 implemented by device authors (usually as <code>@hookimpl</code> instance methods on concrete device classes). These drive device-specific behavior within the lifecycle:</p> <ul> <li><code>boardfarm_skip_boot</code> \u2014 initialize/attach to device without provisioning.</li> <li><code>boardfarm_server_boot</code> / <code>boardfarm_device_boot</code> / <code>boardfarm_attached_device_boot</code> \u2014 boot device categories in sequence.</li> <li><code>boardfarm_server_configure</code> / <code>boardfarm_device_configure</code> / <code>boardfarm_attached_device_configure</code> \u2014 apply environment-driven configuration.</li> <li><code>contingency_check(env_req, device_manager)</code> \u2014 per-test health check used by pytest integration.</li> <li><code>*_async</code> variants \u2014 available where concurrency helps speed up provisioning.</li> </ul>"},{"location":"architecture/#device-categories","title":"Device categories","text":"<p>A Boardfarm device should be one of:</p> <ol> <li>server \u2014 infrastructure services (ACS, DHCP, SIP, etc.).</li> <li>device \u2014 main DUTs/CPEs that depend on infrastructure.</li> <li>attached device \u2014 clients attached to devices (LAN clients, phones, etc.).</li> </ol> <p>Each category participates in different lifecycle phases and must implement hooks appropriate to that category.</p>"},{"location":"architecture/#execution-order","title":"Execution order","text":"<p>When boot is enabled, Boardfarm executes device hooks in this order (each name is an actual <code>@hookspec</code>):</p> <pre><code>boardfarm_server_boot\n\u2193\nboardfarm_server_configure\n\u2193\nboardfarm_device_boot\n\u2193\nboardfarm_device_configure\n\u2193\nboardfarm_attached_device_boot\n\u2193\nboardfarm_attached_device_configure\n</code></pre>"},{"location":"architecture/#minimal-checklist-for-architecture-readers","title":"Minimal checklist for architecture readers","text":"<ul> <li>Core hooks extend and orchestrate the runner; device hooks implement per-device behavior.</li> <li>Use cases depend on Templates (ABCs) only \u2014 device implementations plug in behind the Templates via hooks.</li> <li>The runner uses core hooks to build the environment and then calls device hooks in the documented order.</li> <li>See the dedicated \u201cHow to implement\u201d page for step-by-step examples (device skeletons, core hook examples, tests and best practices).</li> </ul>"},{"location":"architecture/#execution-order-comprehensive-view","title":"Execution Order (Comprehensive View)","text":"<p>The following diagram explains in brief the execution lifecycle of the boardfarm runner: </p>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#100-2025-09-15","title":"1.0.0 (2025-09-15)","text":""},{"location":"changelog/#breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>BOARDFARM-5242</li> <li>BOARDFARM-5242</li> <li>BOARDFARM-5010</li> <li>BOARDFARM-5021</li> <li>BOARDFARM-5021</li> <li>BOARDFARM-4996</li> <li>BOARDFARM-2692</li> <li>BOARDFARM-2018</li> <li>BOARDFARM-1610</li> <li>BOARDFARM-5485</li> <li>BOARDFARM-2784</li> </ul>"},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>resources: add rdkb deploy files</li> <li>add pysnmp-lextudio for pdu management</li> <li>inventory for RPi4 RDKB</li> <li>expose axiros rest to plugin</li> <li>add axiros acs class</li> <li>add local serial connection</li> <li>expose rpi class to plugins</li> <li>add PDU management classes</li> <li>add rpi rdkb class</li> <li>boardfarm3/templates/: add template</li> <li>boardfarm3/devices/base_devices/linux_device.py: add method</li> <li>boardfarm3/devices/linux_lan.py: added method to handle arp table</li> <li>network_utils.py: method to generate uuid</li> <li>add documentation and readme</li> <li>deploy prplos for visual reg demo</li> <li>add gui_html_report.css</li> <li>prplos gui tests</li> <li>add compare png images fucntion</li> <li>update flake8/ruff settings</li> <li>linux_lan.py,lan.py: clear arp cache</li> <li>use_cases/cpe: implementation</li> <li>usecases/dhcp: implementation</li> <li>usecases/devices: getters and utilities</li> <li>cpe: cpe interfaces enum</li> <li>dataclass: load or store use-case data</li> <li>templates: add AFTR and LTS</li> <li>cpe_sw: Add mising APIs</li> <li>boardfarm3/: methods to update hosts</li> <li>lib/connections/connect_and_run.py: add connect and run feature</li> <li>linux_device.py: setup static routes based on inventory</li> <li>add boardfarm_parse_config plugin</li> <li>wlan.py: method to read packets</li> <li>save the logs to a choosen location</li> <li>linux_wlan.py,wlan.py: add methods to enable and disable monitor mode</li> <li>boardfarm3/: added flood method</li> <li>add delete default route</li> <li>update the loc resources hookspecs</li> <li>wlan.py,-networking.py: add ping support for wlan devices</li> <li>softphone.py: add devices class and template for softphone</li> <li>kamailio.py: adding kamailio sipserver device class and template</li> <li>lan.py:wan.py: port use case helpers</li> <li>linux_device.py:lan.py: added method</li> <li>prplos_cpe: add property for tr069 cpe id</li> <li>devices: add a WAN, LAN, ACS, DHCP and WLAN</li> <li>prplos_cpe: add device class</li> <li>templates: cpe and core router</li> <li>connections: support for local shell command</li> <li>linux_device: parse device suboptions</li> <li>templates/lan.py: added template</li> <li>IptablesFirewall: add get_ip6tables_policy() method</li> <li>linux_device.py: provide implementation for set_default_gw() and set_static_ip()</li> <li>lan,wan,wlan templates; linux_device: add stop_traffic() method and implementation</li> <li>lan,wan: add options for curl</li> <li>boardfarm3/: added property and templates</li> <li>templates/LAN|WAN: add send_mldv2_report() method to CPE clients</li> <li>lan|wan|wlan: add set_date to templates</li> <li>core: ignore devices option</li> <li>boardfarm3/: added property and fixed method</li> <li>boardfarm3/: added templates and fixed methods</li> <li>networking: adding the usecases</li> <li>base_devices/linux_device.py: add _get_nw_interface_ipv4_address_async</li> <li>base_devices/linux_device.py: add async versions of methods needed for hooks</li> <li>plugins/setup_environment.py: introduce boardfarm_attached_device_configure_async hook</li> <li>boardfarm3/: make boardfarm_setup_env async</li> <li>add boardfarm_attached_device_boot_async hook</li> <li>boardfarm/: async skip boot flow</li> <li>lib/connections: add plain telnet connectivity and ser2net inherits from telnet</li> <li>boardfarm3: add internet_access_cmd parameter</li> <li>templates/lan.py,wan.py,wlan.py: add abstract method</li> <li>boardfarm3/templates/lan.py,wan.py,wlan.py: add abstract methods to start iperf traffic on sender and receiver</li> <li>base_devices/linux_device.py: add function to delete files in the device</li> <li>templates/acs.py,-lan.py,wan.py,wlan.py: add abstract method to perform scp from linux devices</li> <li>update noxfile to python 3.11</li> <li>templates/acs.py,lan.py,wan.py,wlan.py: add abstract method to delete file from device</li> <li>base_devices/linux_device.py: add method to perform scp from linux devices</li> <li>base_devices/linux_device.py: add method to toggle interface up/down</li> <li>templates/lan.py,wan.py,wlan.py: add abstract method to toggle interface</li> <li>boardfarm3/devices/base_devices/linux_device.py: add method to start the iperf traffic on sender and receiver</li> <li>lib/networking.py,-lib/parsers/iptables_parser.py: add method to return the iptables policy</li> <li>templates: add route methods to wan</li> <li>pyproject.toml: register no reservation plugin on startup</li> <li>templates/wan.py: add abstract method to get interface mtu size</li> <li>templates/lan.py: add abstract method to get interface mtu size</li> <li>templates/wlan.py: add abstract method to get interface mtu size</li> <li>plugins/no_reservation.py: add a plugin to enable boardfarm without reservation</li> <li>lib/SNMPv2.py: implementation of SNMP bulk get method</li> <li>introduce docker compose yml generator based on device json templates for docker factory payload</li> <li>boardfarm3/plugins/devices.py: add skip-boot hook spec and hook flow in boarfarm v3 devices</li> <li>templates/lan.py: add abstract methods for add and delete upnp rule</li> <li>base_devices/linux_device.py: add method to return the subnet mask of the interface</li> <li>boardfarm3/templates/tftp.py: add restart_lighttpd_and_serve_image and stop_lighttpd methods to tftp device template</li> <li>boardfarm3/devices/linux_tftp.py: add implementation for set_static_ip, restart_lighttpd and stop_lighttpd methods</li> <li>templates/wan.py,-templates/wlan.py: update the teamplate of WAN and WLAN with get_interface_macaddr method</li> <li>boardfarm3/templates/wlan.py: add enable/disable ipv6 abstract methods to wlan template</li> <li>boardfarm3/templates/lan.py: add enable/disable ipv6 abstract methods to lan template</li> <li>boardfarm3/lib/boardfarm_config.py: make _get_json function public</li> <li>templates/wan.py,-devices/linux_wan.py: add abstract methods and implementations for rSSH features</li> <li>boardfarm3/lib/utils.py: add method to get the device ipaddress from the device config options entry</li> <li>templates/acs.py: update acs template with provision_cpe_via_tr069 method</li> <li>templates/acs.py: update acs template with provision_cpe_via_tr069 method</li> <li>devices/linux_wan.py,-templates/wan.py: add abstract methods and return statements for rssh username and password</li> <li>lib/boardfarm_config.py,main.py: support lockable resources with multiple boards</li> <li>multicast_device.py,templates: add multicast base device and update templates with multicast methods</li> <li>linux_device: configure dante proxy</li> <li>lib:boardfarm_config.py: remove wifi devices with incorrect config</li> <li>lib/interactive_shell.py: option to add custom marker in the console logs</li> <li>lib/interactive_shell.py: add option to run boardfarm tests from interactive shell</li> <li>fetch jsons from a url</li> <li>main.py,hookspecs/core.py: add support for lockable resources</li> <li>base_devices:linux_device.py: add method for nmap</li> <li>connections,boardfarm_pexpect.py: save console logs to disk</li> <li>tfpt: tftpd initialisation</li> <li>add ser2net driver</li> <li>devices:linux_wlan.py: port wifi device class to boardfarmV3</li> <li>devices.linux_wan.py: add contingency check for acs servers reachability request in wan</li> <li>devices,plugins: add contingency checks for boardfarm devices</li> <li>add python_executor</li> <li>add voice related exception</li> <li>lib.wrappers.py: add singleton decorator</li> <li>templates.acs: add missing methods and update existing methods in acs template</li> <li>lib.networking,templates.wan: add is_link_up method to wan</li> <li>add is_link_up to WAN</li> <li>add retry_on_exception</li> <li>add faultcode to tr069 exception</li> <li>add is_link_up</li> <li>lib/utils.py: port retry function from boardfarm v2</li> <li>linux_lan.py,lan.py: add method to set static ip and set default gateway</li> <li>lib,templates,linux_device.py: add dns_lookup and http_get methods required by use-cases</li> <li>SNMPv2.py: add snmp v2 library</li> <li>LinuxTFTP: set ip on startup</li> <li>networking.py,parsers: add linux networking components</li> <li>exceptions: add NotSupportedError exception</li> <li>templates,use_cases,devices: add start http service use cases and buf fixes</li> <li>add LinuxLAN, LinuxWAN, AxirosACS implementations</li> <li>linux_device uses properties for user and passwd</li> <li>noxfile.py,tox.ini: test boardfarm on multiple python environments</li> <li>uses interact with ptpython</li> <li>linux_device has default user and passwd</li> <li>preparing master to port boardfarm3</li> <li>boardfarm/lib/env_helper.py: add support for image_uri</li> <li>deploy-boardfarm-nodes: fix default route</li> <li>deploy-boardfarm-nodes: add docker env</li> <li>env_helper.py: add latest version 2.45 of env schema</li> <li>boardfarm/: aftr device class impl</li> <li>boardfarm/: aftr device class impl</li> <li>use_cases/voice.py: add stop_and_start_sip_server</li> <li>base_devices/board_templates.py: added template for sw class</li> <li>use_cases/voice.py: add get_sip_expiry_time usecase</li> <li>devices/kamailio.py: add get_sipserver_expire_timer implementation</li> <li>lib/common.py: add install logic</li> <li>devices/linux.py: add method to get secondary IPv4 address</li> <li>dns: add support for external DNS servers</li> <li>env_helper: add support for latest schema</li> <li>make code base python3.11 compatible and fix pylint issues</li> <li>pyproject.toml: lock selenium verison 4.15.0</li> <li>use_cases/networking.py: add Use Case to get the iptables policy</li> <li>devices/debian_fxs.py: add method to perform unconditional call forwarding</li> <li>devices/softphone.py: add method to perform unconditional call forwarding</li> <li>use_cases/voice.py: add Use Case to enable/disable unconditional call forwarding</li> <li>devices/linux.py: add method to return interface mtu size</li> <li>use_cases/networking.py: add param to decide on the iperf destination ip addr</li> <li>use_cases/snmp.py: add Use Case to perform SNMP bulk get</li> <li>lib/SNMPv2.py: implementation of SNMP bulk get method</li> <li>use_cases/networking.py: add Param for the test case to pass destination port for initiating the ipv4 traffic</li> <li>use_cases/networking.py: add Param for the test case to pass destination port for initiating the ipv6 traffic</li> <li>boardfarm/use_cases/networking.py: add use case to disable ipv6 on lan/wlan</li> <li>boardfarm/use_cases/networking.py: add use case to enable ipv6 on lan/wlan</li> <li>use_cases/wifi.py: add Use Cases to list all ssid / check particular ssid in WLAN</li> <li>allow acs seep session to use a certificate</li> <li>ubuntu_asterisk: make changes to the dockerfile</li> <li>add tg2492lg to env check</li> <li>dockerfiles/resources/: add changes to ubuntu asterisk</li> <li>env_helper.py: increase version numbers</li> <li>increase env number</li> <li>booting.py: add voice specific changes</li> <li>voice.py: add pcap verification changes to the lib</li> <li>voice.py: modify parse pcap to support ipv6 check</li> <li>linux.py: add bandwidth to the start traffic function</li> <li>ubuntu_asterisk: add updated sip conf</li> <li>env_helper.py: add support to latest env version</li> <li>use_cases: parse ipv6 mldv2 packets</li> <li>debian_lan: add multicast support</li> <li>pyproject.toml: update selenium version</li> <li>frr: added smcroute</li> <li>use_cases:networking.py: add usecase to perform ping from a device</li> <li>debian_lan: add multicast scapy support</li> <li>frr: moving from quagga to frr</li> <li>use_cases:networking.py: add set_dut_date for board sw</li> <li>use_cases:networking.py: add use cases for nmap</li> <li>booting.py: change config voice according to latest sipserver change</li> <li>use_cases/networking.py: add iptables use_cases</li> <li>softphone.py: add nameserver entry</li> <li>voice.py: add voice usecases</li> <li>ubuntu_asterisk: add freepbx config</li> <li>influx: add support for capturing cpu &amp; memory utilization in influx db</li> <li>debian_ntp: add debian ntp docker image</li> <li>linux.py: add method get_memory_utilization</li> <li>DeviceManager.py: add samknows device to device manager</li> <li>debian_lan: add ftp in debian_lan and vsftp in debian_wan</li> <li>use_cases/descriptors.py: return ipv6 addr</li> <li>booting.py: add voice specify boot functions</li> <li>use_cases/descriptors.py: add provisioner descriptor</li> <li>multicast: ssm multicast libraries</li> <li>asterisk: dockerfile</li> <li>quagga: modify implementation to ubuntu</li> <li>base_devices:board_templates.py: add method is_link_up to BoardSWTemplate class</li> <li>installers.py: add force parameter to install_vsftpd</li> <li>sip_template.py: add endpoints specific functions</li> <li>add check for multicast server count</li> <li>devices:linux.py,-use_cases:networking.py: add device class implementation and usecases of the IPerfTrafficGenerator</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>rdk_inventory: fix SSH ports</li> <li>linting errors</li> <li>boardfarm/: add start and stop tcpdump to devices</li> <li>networking: correct parse http result</li> <li>boardfarm_config: retaining debian logic</li> <li>linting issues</li> <li>aftr.py: change use case signature</li> <li>pre-commit: stick to flynt v1.0.3</li> <li>boardfarm3: add modify templates based on usecases</li> <li>wlan: to get ip6 addr for wlan1</li> <li>boardfarm3/lib/wrappers.py: correct return type for callable</li> <li>modify pre-commit to ignore tabs for makefile</li> <li>boardfarm3/devices/kea_provisioner.py: update options with dhcp_options</li> <li>make sure the http service is running</li> <li>update configs/kea_eth_provisioner lease db</li> <li>linux_lan: wait 3s before starting danted</li> <li>bf-config: update the sip server type</li> <li>boardfarm/.pylintrc: pylint py version change to 3.11</li> <li>linting issues</li> <li>connect_and_run: increase retries</li> <li>connect_and_run: increase timeout</li> <li>pjsip_phone: fixing docstring</li> <li>boardfarm3/: iperf with udp only</li> <li>boardfarm3/: add method</li> <li>connect_and_run: add retries</li> <li>base_devices/linux_device.py: add logic to handle async kill</li> <li>boardfarm3/devices/base_devices/linux_device.py: fix method get_interface_mask to use correct regex</li> <li>boardfarm3/devices/linux_lan.p: fix for lan_gateway</li> <li>boardfarm3/templates/wan.py: add property</li> <li>base_devices/linux_device.py:templates: add cport functionality</li> <li>boardfarm3/: modfiy the template and function</li> <li>boardfarm3/lib/networking.py: fix mypy error</li> <li>linux_devices: add static routes from inventory for linux devices</li> <li>linux_tftp: delete any previous default route</li> <li>mypy linting issue</li> <li>boardfarm3/devices/linux_lan.py,boardfarm3/templates/lan.py: fix the create_upnp_rule function</li> <li>wlan.py: added rel renew methods support</li> <li>boardfarm3/lib/network_utils.py: add dest to tftp transfer</li> <li>boardfarm3/: leverage timeout param</li> <li>lib/network_utils.py: add tftp utility</li> <li>templates/acs.py:genie_acs.py: add url property</li> <li>sip_server.py: methods for copying file</li> <li>boardfarm3/: added params, fixed logic</li> <li>noxfile.py: pin nox pylint==3.2.6</li> <li>toml: pin pyasn1=0.6.0</li> <li>core.py: change name of kamailio to sipcenter_kamailio</li> <li>linux_device.py:lan.py: support for ipv6</li> <li>linux_device.py: sync for prompt</li> <li>linux_device.py: condition if server didn't start</li> <li>linux_device.py: property name to clear from cache</li> <li>boardfarm3/: fix for local cmd param</li> <li>prplos_cpe: fix the cpe_id property</li> <li>hookspec: add the missing async hook definitions</li> <li>config: update to a generic openwrt board</li> <li>boardfarm3/: method to get iperf logs</li> <li>boardfarm3/: added additional argument</li> <li>boardfarm_config.py: add station name attr</li> <li>provisioner.py:typing/dhcp.py: custom type hints</li> <li>provisioner.py: added base provisioner class</li> <li>boardfarm3/devices/base_devices/: add scp to local</li> <li>allow got linting to pass</li> <li>lan|wan|wlan: add get_date() to templates</li> <li>boardfarm3/: fixed dns_lookup method</li> <li>linux_tftp: add a route for the static ip</li> <li>utils: initialize webdriver on interact</li> <li>connections: update LDAP authentication</li> <li>plugins: add async spec for server_configure</li> <li>devices/base_devices/linux_device.py: removed firewall utility obj</li> <li>add ssh-rsa to key algorithms</li> <li>ser2net: update regex on connection</li> <li>allow a cpe to connect via ser2net</li> <li>networking: update the http parsing rules</li> <li>networking: update type hints to comply with ruff</li> <li>update login_to_server with default parameter</li> <li>base_devices/linux_device.py: add await keyword</li> <li>core.py: boardfarm_post_setup_env does not require boardfarm config</li> <li>update noxfile and add pylint plugin to dev dependency</li> <li>lib/: fix mypy issues</li> <li>update perform_scp to match templates</li> <li>boardfarm3/devices/base_devices/linux_device.py: define linux style prompts in one place</li> <li>lib/device_manager.py: fix crash when registering a device with property that raises an exception</li> <li>boardfarm3/plugins/core.py: fix different pytest beaviour on incorrect command line parameter from boardfarm3</li> <li>boardfarm3/lib/SNMPv2.py: do not modify the snmp set value if the set value is a hex string</li> <li>boardfarm3/plugins/devices.py: move linux wan device class to boardfarm-lgi-shared</li> <li>boardfarm3/devices/base_devices/linux_device.py: remove trailing stray characters from ping output</li> <li>boardfarm3/lib/boardfarm_config.py: fix typo in get_inventory_config function name</li> <li>pass path to pexpect.spawn</li> <li>devices/base_devices/linux_device.py: remove sudo from tcpdump and tshark commands</li> <li>lib/boardfarm_pexpect.py: fix the double prompt issue in freepbx</li> <li>linux_device: use sendline for dante cfg</li> <li>lib/SNMPv2.py: fixed snmp parse regex</li> <li>lib/networking.py: fix scp failure</li> <li>linux_device: use sudo_sendline in tcpdump</li> <li>lib/boardfarm_config.py: disable jsonmerge debug logs</li> <li>templates/acs.py: revert deletion of the ScheduleInform acs method</li> <li>lib/networking.py: fix scp failure when the host ip is a ipv6 address</li> <li>.pylintrc: update .pylintrc file to fix warnings</li> <li>crash when using telnet on console</li> <li>lib/interactive_shell.py,main.py: updated interactive shell look</li> <li>linux_device: static route is now set</li> <li>lib.boardfarm_config.py: use locations key to get shared config</li> <li>utils.py: fix type hinting and code of retry methods</li> <li>linux_tftp.py: update docstring and fix static ip logic</li> <li>stop autocomp running propeties</li> <li>terminal longlines changes</li> <li>pyproject.toml: fix plugin path</li> <li>axiros_acs.py: get tr69 cpe-id from board</li> <li>allows text wrap on long lines</li> <li>linting issues</li> <li>boardfarm/devices/axiros_acs.py: fix add object</li> <li>boardfarm/lib/env_helper.py: fix for dhcp_options</li> <li>deploy-boardfarm-nodes.sh: add ipv6 isolate management</li> <li>lib/env_helper.py: add the version</li> <li>lib/hooks/contingency_checks.py: add logic for maxcpe</li> <li>boardfarm/lib/SnmpHelper.py: add fix</li> <li>debian_isc.py: support sku with no voice support</li> <li>isc_aftr.py: restarting aftr process</li> <li>lib/env_helper.py: add the schema version</li> <li>linux.py: remove buffer data</li> <li>linux_nw_utility.py:networking.py: add tftpboot as the folder location</li> <li>pyproject.toml: change selenium install version</li> <li>booting_utils.py: fix to enable WiFi 5GHz guest settings</li> <li>isc_aftr: update DNS entry</li> <li>networking.py:linux_nw_utility.py: add send file via tftp</li> <li>networking.py: updated condition</li> <li>linux.py: remove buffer data</li> <li>env_helper.py: add 2.44 version</li> <li>toml: pin pyasn1=0.6.0</li> <li>restrict numpy&lt;2.1.0</li> <li>networking.py: updated logic</li> <li>pyproject.toml: retsrict the pysnmp version</li> <li>linux.py:networking.py: get server and client logs</li> <li>hooks/contingency_checks.py: add dual in rechable check</li> <li>connect: allow access to a AAA configured dev</li> <li>networking.py: added additional argument</li> <li>boardfarm/use_cases/voice.py: correct the voice client fun call</li> <li>use_cases/dhcpv6.py: fixed dhcpv6 packet parsing for mv3 eth</li> <li>boardfarm/lib/common.py: change wget to curl</li> <li>lib/env_helper.py: add the latest schema version</li> <li>boardfarm/lib/booting.py: add transport and dns pref</li> <li>kamailio.py:use_cases/voice.py: change get exp timmer name</li> <li>use_cases/networking.py: fixed resolve_dns use case</li> <li>acs retry on wsdl schema</li> <li>use_cases/networking.py: fix nmap usecase</li> <li>devices/kamailio.py,-use_cases/voice.py: remove redundant param</li> <li>network_testing.py: change tcpdump cmd flags</li> <li>quagga_router.py: update interface</li> <li>use_cases/voice.py: fix set_sip_expiry_time</li> <li>devices/debian_fxs.py: fix detect_dialtone</li> <li>pyproject: update easysnmp dependency</li> <li>boardfarm/use_cases/voice.py: fix get_sip_expiry_time usecase</li> <li>networking: fix the HTTP parsing</li> <li>use_cases/networking.py: update anycpe to boardtemplate</li> <li>lib/booting.py: update extra configure voice param</li> <li>lib/voice.py: update logic for sip trace</li> <li>use_cases/networking.py: add sleep</li> <li>lib/voice.py: update logic for sip trace</li> <li>wifi_lib/manager.py: fix the WLAN_options</li> <li>contingency_checks.py: add none check on mode</li> <li>use_cases/networking.py: fix Use Case</li> <li>lib/env_helper.py: fix env mismatch</li> <li>lib/linux_nw_utility.py,-use_cases/networking.py: fix method</li> <li>boardfarm/lib/common.py: run firefox as headless when specified</li> <li>run tcpdump as root user</li> <li>download aftr via mgmt iface</li> <li>networking.py: added interface param</li> <li>common: update setting firefox profile</li> <li>lib/firewall_parser.py,-lib/linux_nw_utility.py: fix to get the iptables policy</li> <li>voice: fix the console sync issue</li> <li>boardfarm/lib/booting.py: fix digit map issue</li> <li>boardfarm/devices/axiros_acs.py: fix xml parser error when non formatted, non printable or non ascii characters present</li> <li>kill webfsd on wan setup</li> <li>boardfarm/lib/booting.py: introduce wait for hw boot after reset in booting class</li> <li>use_cases/networking.py: fixed nmap method</li> <li>boardfarm/use_cases/networking.py: update nmap board condition</li> <li>boardfarm/use_cases/networking.py: fix nmap board condition</li> <li>boardfarm/lib/hooks/contingency_checks.py: acs contingency check has to be performed based on the provisioning mode</li> <li>selenium &lt; 4.10.0</li> <li>acs do not verify ssl session</li> <li>softphone.py: change softphone nameserver order</li> <li>boardfarm/use_cases/voice.py: change call waiting fn to use dtmf</li> <li>kamailio.py: add url to sipcenter template</li> <li>multicast: parse IPv4 igmp type</li> <li>booting.py: fix the error thrown</li> <li>linux.py: add ipv6 support for scp</li> <li>multicast: use cases signature fix</li> <li>send dhcp-client-identifier as a string</li> <li>flake8 ignore  B028, B017</li> <li>acs.py: use case to return acs urls</li> <li>softphone: add nameserver to the top</li> <li>booting.py: check if board is in dslite for mv3</li> <li>debian_fxs.py,softphone.py,sip_template.py: fix usage of descriptors in phone class</li> <li>booting: retry on tr-069 provisioning</li> <li>env_helper: lan clients number mismatch</li> <li>softphone.py,debian_fxs.py,sip_template.py: remove allocate number funtion and related</li> <li>hooks:contingency_checks: update acs dns check in contingency</li> <li>change gitlab to github</li> <li>retry on acs contingency</li> <li>sip_template.py: fix softphone initialisation error</li> <li>common.py: remove passive mode connection from ftp_upload_download</li> <li>linux.py: simplify regex for validating cpu load in get_load_avg method</li> <li>use_cases/networking.py: add kwargs</li> <li>lib:hooks:contingency_checks.py: remove the usage of arm in CC</li> <li>networking.py: add ipv6 dns resolve</li> <li>use_cases/dhcp.py: update dhcp methods</li> <li>common.py: update expect statement of password prompt for ftp_useradd</li> <li>use_cases/dhcpv6.py: add additional_args param</li> <li>SNMPv2.py: correct the regex and match</li> <li>add timeout to parse_sip_trace usecase</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>boardfarm3/lib/odh: add odh to boardfarm</li> <li>base_devices/linux_device.py:lan.py:wan.py: refactor method name hping flood</li> <li>move demo pages to gui/prplos</li> <li>remove resources/configs resources/dockerfiles</li> <li>core.py,boardfarm_config_example.json: rename the devices dictionary keys</li> <li>lib/multicast.py: implement proper type hinting</li> <li>align docstring with methods signature</li> <li>networking.py: fix issues found by ruff 0.2.0</li> <li>docs: delete empty or old documentation</li> <li>linter: fix black errors</li> <li>boardfarm_config: remove nox/flake8 errors</li> <li>update compose generator due to changes in schema</li> <li>boardfarm3/templates/wlan.py: update enable_ipv6 and disable_ipv6 template methods for wlan</li> <li>boardfarm3/templates/lan.py: update enable_ipv6 and disable_ipv6 template methods for lan</li> <li>templates/wan.py: refactor the method connect_to_board_via_reverse_ssh to return bool</li> <li>lib/SNMPv2.py: refactor the code that performs snmpset</li> <li>boardfarm3/lib/boardfarm_config.py: refactoring via ruff</li> <li>devices/linux_wan.py: modify the command to get the network statistics</li> <li>introduce ruff linter</li> <li>scripts/: remove scripts folder</li> <li>boardfarm3/templates/wan.py,-boardfarm3/devices/linux_wan.py: modify the signature of rssh_password</li> <li>lib/networking.py: add fqdn and rework dns class</li> <li>lib/SNMPv2.py: make get_mib_oid public</li> <li>lib/boardfarm_config.py,pyproject.toml: use new flexible inventory schema</li> <li>lib/interactive_shell.py,plugins/core.py: make interactive shell extensible</li> <li>devices:linux_wlan.py: remove is_wifi_ssid_listed from template</li> <li>makes configuration more flexible</li> <li>devices.linux_lan.py: move linux lan device to lgi-shared since it require cable modem</li> <li>move wan options to wan device</li> <li>update syntax to py3.9</li> <li>remove redundant sendline</li> <li>py.typed: add py.typed file to indicate the package is type hinted</li> <li>rename package from boardfarm to boardfarm3</li> <li>devices,plugins,lib,templates: boardfarm v3 plugins, libraries, templates and devices</li> <li>devices,lib,use_cases: cleanup boardfarm repo for v3</li> <li>devices,lib,templates: Cleanup boardfarm repo for v3</li> <li>env_helper: add latest env</li> <li>pre-commit-config.yaml: update isort version</li> <li>axiros_acs.py,acs_template.py: update AcsTemplate and update AxirosACS</li> </ul>"},{"location":"changelog/#2022350-2022-08-31","title":"2022.35.0 (2022-08-31)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>dhcpv6.py: add timeout to parse_dhcpv6_trace usecase</li> <li>booting_utils.py: add condition to connect wifi</li> <li>env_helper.py: add support to new env schema</li> </ul>"},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>disable check on signature checker</li> <li>depends-on change rebase -&gt; checkout</li> <li>networking.py: update the regex in http_get usecase</li> <li>networking.py: fix the regex in http_get usecase</li> <li>dhclient-script: ns count fix</li> <li>debian_lan: no mgmt dns in dhclient.conf</li> <li>debian_isc: run v4/v6 config together</li> <li>arguments.py: change operator</li> <li>axiros_acs.py: remove pprint</li> <li>axiros_acs.py: remove pprint from output</li> <li>networking.py: remove the use of the output from print</li> </ul>"},{"location":"changelog/#refactor_1","title":"Refactor","text":"<ul> <li>acs_template: add bool and int to SPV type hinting</li> </ul>"},{"location":"changelog/#2022330-2022-08-17","title":"2022.33.0 (2022-08-17)","text":""},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>can read the inventory.json from web location</li> <li>add tones_dict to sw template</li> <li>DeviceManager.py: add ssam client to device manager</li> </ul>"},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>debian_lan: fix dhclient-script issue</li> <li>pylint issue == to is</li> <li>do not install packages</li> <li>debian_sipcenter: add bind.so to sipcenter</li> <li>debian: fix dnsmasq configuration</li> <li>init.py: remove argument model</li> </ul>"},{"location":"changelog/#2022310-2022-08-03","title":"2022.31.0 (2022-08-03)","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>add mitm as it is needed in scripts</li> <li>contingency_checks.py: fix contingency check device list</li> <li>debian_dns: update dnsutils package version</li> <li>networking.py: modify the use case http_get</li> <li>networking.py: fix the parse response logic for failure</li> <li>lib:env_helper.py: update get_board_hardware_type with F5685LGB from env_helper</li> <li>pyproject.toml: rm jira from dependencies</li> </ul>"},{"location":"changelog/#2022290-2022-07-20","title":"2022.29.0 (2022-07-20)","text":""},{"location":"changelog/#feat_3","title":"Feat","text":"<ul> <li>kea_dhcp: allow multiple host reservations</li> </ul>"},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>devices:kamailio.py: fix the sipserver_user_add function to take the correct password for a sip user</li> </ul>"},{"location":"changelog/#refactor_2","title":"Refactor","text":"<ul> <li>sonarQ reporting moved to cicd</li> </ul>"},{"location":"changelog/#2022270-2022-07-07","title":"2022.27.0 (2022-07-07)","text":""},{"location":"changelog/#feat_4","title":"Feat","text":"<ul> <li>platform/debian: add ptr record suppport</li> <li>DeviceManager: add enum for olt</li> </ul>"},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>flake8 B023 error</li> <li>fix wifi board fail at post boot</li> <li>invoke power off on board.hw</li> </ul>"},{"location":"changelog/#2022250-2022-06-20","title":"2022.25.0 (2022-06-20)","text":""},{"location":"changelog/#feat_5","title":"Feat","text":"<ul> <li>bft_pexepct_helper: add check_output</li> <li>pylint: bump pylint to 2.14.1</li> </ul>"},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>dhcp.py: add timeout for parse_dhcp_trace</li> <li>dnsmasq not starting when \"auth-zone=\" in .conf</li> </ul>"},{"location":"changelog/#2022230-2022-06-08","title":"2022.23.0 (2022-06-08)","text":""},{"location":"changelog/#feat_6","title":"Feat","text":"<ul> <li>devices:base_devices:mib_template.py: add sw_update_table_mib to the mib template of the BoardSWTemplate</li> <li>env_helper.py: add get_board_gui_language</li> </ul>"},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>debian_dns: update apt libraries' version</li> <li>quagga: allows addition of more interfaces</li> </ul>"},{"location":"changelog/#refactor_3","title":"Refactor","text":"<ul> <li>voice.py,-wifi.py: add voice resources and wifi resources</li> </ul>"},{"location":"changelog/#2022210-2022-05-25","title":"2022.21.0 (2022-05-25)","text":""},{"location":"changelog/#feat_7","title":"Feat","text":"<ul> <li>kea_provisioner: add HTTP APIs for DHCP</li> </ul>"},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>devices:base_devices:mib_template.py: add sw_server_address_mib property to MIBTemplate</li> <li>use_cases:dhcp.py: fix use-case get_dhcp_suboption_details to fetch suboptions for option 125</li> <li>debian_wan: add option to set static ipv6 route</li> <li>lib:env_helper.py: fix failures with provisioner dhcp options</li> </ul>"},{"location":"changelog/#2022190-2022-05-11","title":"2022.19.0 (2022-05-11)","text":""},{"location":"changelog/#feat_8","title":"Feat","text":"<ul> <li>use_cases:dhcp.py: implement usecases to configure and trigger dhcpinform packets</li> <li>debian_lan,debian_wan: add support to add webfs server</li> <li>add debian_kea_provisioner dockerfile</li> </ul>"},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>lib:SNMPv2.py: fix parse_snmp_output for IndexError</li> <li>dockerfiles: fix missing debian binay packages</li> <li>networking.py: fix off by one bug related to /32 subnet</li> </ul>"},{"location":"changelog/#refactor_4","title":"Refactor","text":"<ul> <li>lib:env_helper.py: segregate docsis and non-docsis env_helper</li> </ul>"},{"location":"changelog/#2022170-2022-04-28","title":"2022.17.0 (2022-04-28)","text":""},{"location":"changelog/#feat_9","title":"Feat","text":"<ul> <li>add schema 2.22 to env helper</li> <li>linux.py,networking.py: add support to spin up/down webserver using webfsd</li> <li>booting.py,contingency_checks.py: add support for static ip assignment for lan/wlan clients</li> <li>lib:hooks:contingency_checks.py: Contingency Check Functionality Segregation</li> </ul>"},{"location":"changelog/#fix_10","title":"Fix","text":"<ul> <li>add mgmt when fetching from server</li> <li>acs_server: add support for another ACS</li> <li>devices:debian_wan.py: add ipv6.google.com to resolve as wan container's ip address</li> <li>disable acs pcap capture by default</li> </ul>"},{"location":"changelog/#refactor_5","title":"Refactor","text":"<ul> <li>pylint-fixes: fix pylint errors</li> </ul>"},{"location":"changelog/#2022150-2022-04-14","title":"2022.15.0 (2022-04-14)","text":""},{"location":"changelog/#breaking-change_1","title":"BREAKING CHANGE","text":"<ul> <li>MVX_TST-56392</li> <li>BOARDFARM-1666</li> </ul>"},{"location":"changelog/#feat_10","title":"Feat","text":"<ul> <li>devices:base_devices:board_templates: update BoardSWTemplate with nw_utility and firewall instances</li> <li>use_cases:networking.py: use cases to block and unblock traffic via iptables firewall rule</li> <li>networking.py: add usecase for dhcp renew</li> <li>update template and booting for new board</li> <li>add new api to resolve board type</li> <li>dhcp.py: add DHCP parse Use Cases</li> </ul>"},{"location":"changelog/#fix_11","title":"Fix","text":"<ul> <li>remove yamlfmt/yamllint from pre-commit</li> <li>bumps the env version</li> <li>pre-commit: update pre-commit hooks to latest versions and autofix issues</li> </ul>"},{"location":"changelog/#2022130-2022-03-31","title":"2022.13.0 (2022-03-31)","text":""},{"location":"changelog/#breaking-change_2","title":"BREAKING CHANGE","text":"<ul> <li>BOARDFARM-1734</li> </ul>"},{"location":"changelog/#feat_11","title":"Feat","text":"<ul> <li>use_cases:console.py: implement usecase to restart the erouter interface</li> <li>linux.py,networking.py: add support to set static ip , ip search in pool</li> <li>contingency_checks.py: add support to disable lan client init</li> <li>wifi_use_cases: update access to wifi object getter, change the usage in use cases</li> </ul>"},{"location":"changelog/#fix_12","title":"Fix","text":"<ul> <li>pyproject.toml: freeze pylint dependency to last working version</li> </ul>"},{"location":"changelog/#refactor_6","title":"Refactor","text":"<ul> <li>dockerfiles: Create dockerfile for each device and cleanup</li> </ul>"},{"location":"changelog/#2022110-2022-03-16","title":"2022.11.0 (2022-03-16)","text":""},{"location":"changelog/#feat_12","title":"Feat","text":"<ul> <li>devices:board_templates.py,mib_template.py,linux.py: add mib template to support vendor specific mib configurations for software download</li> <li>networking.py: add dns_resolve  uc</li> <li>device_getters.py: add provisioner getter</li> <li>voice.py: remove sleep from disconnect_the_call</li> <li>traffic_gen return TrafficGeneratorResults</li> </ul>"},{"location":"changelog/#fix_13","title":"Fix","text":"<ul> <li>linux.py: change regular expression to get process id</li> <li>quagga_router.py: update ip route method to fetch route from quagga instance</li> </ul>"},{"location":"changelog/#refactor_7","title":"Refactor","text":"<ul> <li>debian_lan.py: validate ipv6 address is obtained and throw exception</li> </ul>"},{"location":"changelog/#2022090-2022-03-02","title":"2022.09.0 (2022-03-02)","text":""},{"location":"changelog/#breaking-change_3","title":"BREAKING CHANGE","text":"<ul> <li>Do not merge until all the executors have been updated! BOARDFARM-1698</li> <li>BOARDFARM-1500</li> </ul>"},{"location":"changelog/#feat_13","title":"Feat","text":"<ul> <li>debian_isc.py: add support for invalid dhcp gateway</li> <li>add get_load_avg to sw template</li> <li>debian: fetch DNS entry from inventory json and update in dnsmasq.conf</li> <li>linux.py: add graceful error handling</li> <li>linux: add support for ping using json cli</li> <li>add 2.19 env version</li> <li>boardfarm:use_cases:networking.py: write a use case to parse ICMP responses and compare</li> </ul>"},{"location":"changelog/#fix_14","title":"Fix","text":"<ul> <li>voice.py: reduce sleep time in makecall</li> <li>quagga_router.py: update atexit call and docstrings</li> </ul>"},{"location":"changelog/#2022070-2022-02-16","title":"2022.07.0 (2022-02-16)","text":""},{"location":"changelog/#feat_14","title":"Feat","text":"<ul> <li>quagga_router.py: add quagga router device class</li> <li>linux.py: add support for tcpdump capture,read[tcpdump,tshark]</li> <li>traffic_generator.py: formalise traffic generator template</li> <li>debian_lan: add iw and wpasupplicant packages in image</li> </ul>"},{"location":"changelog/#fix_15","title":"Fix","text":"<ul> <li>pyproject.toml: freeze pyvirtualdisplay package version to 2.2</li> <li>pyproject.toml: pin elasticsearch to stay compliant with api</li> <li>increase cli size</li> </ul>"},{"location":"changelog/#refactor_8","title":"Refactor","text":"<ul> <li>pyproject.toml: freeze selenium dependency to 4.1.0</li> </ul>"},{"location":"changelog/#2022050-2022-02-02","title":"2022.05.0 (2022-02-02)","text":""},{"location":"changelog/#feat_15","title":"Feat","text":"<ul> <li>devices:softphone.py,debian_fxs.py: implement enable_call_waiting and enable_call_forwarding_busy use cases for softphone</li> <li>getters.py: add getters for lan and wan clients</li> </ul>"},{"location":"changelog/#fix_16","title":"Fix","text":"<ul> <li>lib:voice.py: fix _parse_rtp_trace usecase to check for rtp packets associated to a SIP setup-frame</li> <li>debian_wan: replace google.com with wan.boardfarm.com for v4 and v6</li> <li>debian_fxs: update debian:stable-slim with debian:buster-slim</li> <li>connection_decider: use strict match for connection type</li> <li>pyproject.toml: pin dependency for selenium version 3.141.0</li> <li>devices:debian_lan.py: set icmp_echo_ignore_broadcasts to false on lan devices</li> <li>boardfarm:lib:voice: fix _parse_rtp_trace when start and end indexes are same</li> </ul>"},{"location":"changelog/#2022030-2022-01-20","title":"2022.03.0 (2022-01-20)","text":""},{"location":"changelog/#breaking-change_4","title":"BREAKING CHANGE","text":"<ul> <li>BOARDFARM-1456</li> </ul>"},{"location":"changelog/#feat_16","title":"Feat","text":"<ul> <li>devices:softphone.py: implement the unimplemented usecases for softphone</li> <li>add connect to DUT via ssh</li> <li>device-manager: register wifi devices</li> </ul>"},{"location":"changelog/#fix_17","title":"Fix","text":"<ul> <li>devices:softphone.py: fix softphone pjsip config to disable TCP transport</li> <li>networking.py: add link_local_ipv6 to IPAddresses dataclass</li> <li>devices:linux.py: fix get_interface_ipaddr to handle AttributeError and throw PexpectTimeoutError</li> <li>devices:debian_isc.py: fix for port number of acs url in vendor specific dhcp configuration</li> <li>debian: updated pkgs that can be installed</li> <li>fixes to run with debian:buster-slim image</li> <li>debian: fix pexpect xterm env set</li> <li>installers: minor fix on apt_install</li> </ul>"},{"location":"changelog/#2022010-2022-01-05","title":"2022.01.0 (2022-01-05)","text":""},{"location":"changelog/#breaking-change_5","title":"BREAKING CHANGE","text":"<ul> <li>If using Docsis devices the latest Docsis change must be picked.</li> </ul>"},{"location":"changelog/#feat_17","title":"Feat","text":"<ul> <li>get image use image_uri</li> <li>multicast: add multicast usecases</li> <li>quagga: add mrouted daemon</li> </ul>"},{"location":"changelog/#fix_18","title":"Fix","text":"<ul> <li>boardfarm:resources:configs:kamailio.cfg: update kamailio.cfg to configure timeout of 25sec</li> <li>boardfarm:devices:debian_isc.py: fix acs url in vendor specific dhcpoptions to use http as prefix</li> <li>boardfarm:use_cases:voice.py: handle exception for hangup in shutdown_phone usecase</li> </ul>"},{"location":"changelog/#2021510-2021-12-22","title":"2021.51.0 (2021-12-22)","text":""},{"location":"changelog/#feat_18","title":"Feat","text":"<ul> <li>quagga-pim: add IGMP multicast routing for interface</li> <li>enable/disable acs pcap capture</li> <li>improved name discovery</li> </ul>"},{"location":"changelog/#fix_19","title":"Fix","text":"<ul> <li>devices:linux.py: add fix to fetch erouter0/lan ipv6 on linux console when output is delayed/untidy after command execution</li> <li>do not use get_pytest_name yet</li> <li>fix test name fetching in acs intercept</li> <li>devices:debian_lan.py: handle timeout error when tshark read is too long for failed lan renewal</li> </ul>"},{"location":"changelog/#2021490-2021-12-09","title":"2021.49.0 (2021-12-09)","text":""},{"location":"changelog/#feat_19","title":"Feat","text":"<ul> <li>use_cases:voice.py: add place_call_offhook use case for voice</li> <li>networking.py: Add IPAddresses data class for erouter use case at common location</li> <li>use_cases:voice.py: add off hook use case for voice</li> </ul>"},{"location":"changelog/#fix_20","title":"Fix","text":"<ul> <li>lib:dhcpoption.py: fix ManufacturerOUI under DHCP Option 125 on LAN side</li> <li>pylint: Add pylint config and fix pylint issues.</li> </ul>"},{"location":"changelog/#2021470-2021-11-24","title":"2021.47.0 (2021-11-24)","text":""},{"location":"changelog/#fix_21","title":"Fix","text":"<ul> <li>lib:voice.py: add 1 second delay to verify RTP packets and handle few exceptions</li> </ul>"},{"location":"changelog/#2021460-2021-11-18","title":"2021.46.0 (2021-11-18)","text":""},{"location":"changelog/#feat_20","title":"Feat","text":"<ul> <li>pyproject.toml: Add commitizen-specific config. Prune tbump config.</li> <li>pyproject.toml: Add tbump config and bump version manually.</li> <li>boardfarm/bft: Add option to skip resource reservation status check on Jenkins</li> <li>linux.py: Add hostname property for all linux devices.</li> <li>remove zephyr dead code</li> <li>devices:debian_fxs.py,softphone.py: fix and implement sip abstract methods</li> <li>use_cases:networking.py: add use_cases to be used by TCs to avoid direct access to board consoles</li> <li>lib:linux_nw_utility.py,linux_console_utility.py: add network and dut console utilities</li> <li>bft,lockableresources: Use Jenknins Lockable Resources in Boardfarm to manage modems</li> <li>quagga: dockerfile for quagga router</li> <li>installers.py: add method get_interface_private_ip6addr</li> <li>networking.py-wifi.py-wifi_template.py: add wifi usecases</li> <li>acs: show console interactions</li> <li>voice: add voice conference use cases</li> <li>devices-base_devices-board_template: add FXO as voice</li> <li>devices:-base_devices:-fxo_template: add new template class to be used by MTA template</li> <li>use_cases/snmp.py: Add basic generic snmp use cases (wrappers around SNMPv2).</li> <li>platform/debian: lighttpd and tftpd use the same directory</li> <li>Add generic scp command implementation to linux device.</li> </ul>"},{"location":"changelog/#fix_22","title":"Fix","text":"<ul> <li>resources:configs:kamailio.cfg: configure kamailio to send \"181 Call is Being Forwarded\" packet on call forward busy</li> <li>debian_fxs: remove reply with code implementation</li> <li>devices:softphone.py: hardening of the phone_config and phone_start of softphone device to fix issues</li> <li>lib,use_cases:voice.py: add new use cases for sipserver/voice rtp, remove the legacy ones and add support for media attribute, connection info check</li> <li>devices:debian_fxs,devices:kamailio: harden the implementations of fxs and sip server devices</li> <li>devices:debian_isc.py: provide a different acs url from config file both for v4 and v6 when dhcp vendor options are configured</li> <li>common.py: split send_to_influx further into validate_influx_connection</li> <li>change gui resolution to 1920x1080</li> <li>influx_db_helper.py: add timeout parameter to influx db connection request</li> <li>lockableresources.py: Fix wifi enclosure device selection based on board type</li> <li>lib:installers.py: add recovery solution when acs server console is hung during apt install</li> <li>devices/serialphone.py: modify the wrapper function exit_python_on_exception</li> <li>use_cases: fix docstrings to make sphinx happy</li> <li>kamailio.cfg: modify configurations to use nonce value only once for authentication</li> <li>quagga: add natting on router</li> <li>lib/common.py: remove unused self argument from configure_ovpn. Return bool success value</li> <li>installers.py: add fix for openvpn ipv6 server connection</li> <li>implement-voice-conference-APIs: derive implementation for Voice conference call signatures</li> <li>devices-base_devices-sip_template: update signatures</li> <li>env_helper.py: handle scenarios with list of dictionaries and list of strings in env request validation</li> <li>installers.py: add print statements instead of debug for lan client IRC scripts</li> <li>fix pylint errors</li> <li>Do not restart interface twice during CC. Flush tcpdump buffer before kill</li> </ul>"},{"location":"changelog/#refactor_9","title":"Refactor","text":"<ul> <li>linux.py: return dhcp renew output</li> <li>axiros_acs: fix the interface name</li> <li>axiros_acs: add acs aux iface name</li> <li>change lib to docsis_lib globally</li> </ul>"},{"location":"development/","title":"Development (How-to-Guide)","text":""},{"location":"development/#writing-a-boardfarm-plugin","title":"Writing a Boardfarm plugin","text":"<p>A Boardfarm plugin project typically follows the convention <code>boardfarm_&lt;plugin_name&gt;</code> and contains a small, focused set of packages that implement devices, plugin registration, templates, use cases and shared libraries.</p> <p>Note: below I use DeviceA as a generic device implementation name. Replace DeviceA and  with your concrete names. <pre><code>boardfarm_&lt;plugin_name&gt;/\n\u251c\u2500\u2500 devices/             # concrete device implementations (classes)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 device_a.py\n\u251c\u2500\u2500 plugins/             # modules that register to the plugin manager (hookimpl)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 registration.py\n\u251c\u2500\u2500 templates/           # optional: extra Template ABCs (vendor/plugin-specific)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 custom_template.py\n\u251c\u2500\u2500 use_cases/           # optional: plugin-level use cases\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 provisioning.py\n\u251c\u2500\u2500 lib/                 # helper libraries reused by devices / use cases\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 helpers.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"development/#directory-roles","title":"Directory roles","text":"<ul> <li><code>devices/</code> \u2014 Concrete implementations of templates (e.g. <code>DeviceA</code>). These classes will be instantiated by Boardfarm (via <code>DeviceManager</code>) when inventory entries reference your <code>type</code>.</li> <li><code>plugins/</code> \u2014 Module(s) that export <code>@hookimpl</code> functions such as <code>boardfarm_add_devices()</code>, <code>boardfarm_add_cmdline_args()</code>, <code>boardfarm_setup_env()</code>, etc. These make your package discoverable to Boardfarm and Pluggy.</li> <li><code>templates/</code> \u2014 (optional) Plugin-specific additional ABCs or mixins. Prefer extending the main boardfarm repo templates where possible.</li> <li><code>use_cases/</code> \u2014 (optional) Higher-level plugin logic composed from template methods (for internal tests or helper scripts).</li> <li><code>lib/</code> \u2014 Shared utilities used by your device drivers (parsers, networking helpers, common retry wrappers, \u2026).</li> <li><code>pyproject.toml</code> \u2014 Project metadata and entry-points so Boardfarm can discover the plugin.</li> </ul>"},{"location":"development/#pyprojecttoml-entry-point","title":"pyproject.toml (entry-point)","text":"<p>Boardfarm discovers plugins by loading setuptools/PEP-621 entry-points in the <code>boardfarm</code> group.</p> <p>Here's an example <code>pyproject.toml</code> (replace <code>&lt;plugin_name&gt;</code> with your package name \u2014 example below uses <code>boardfarm_plugin_a</code>):</p> <pre><code>[project]\nname = \"boardfarm_plugin_a\"\nversion = \"0.0.1\"\ndescription = \"Boardfarm plugin with Device A\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11\"\nauthors = [\n  { name = \"Ketone\", email = \"devs@ketone.example\" }\n]\n\n[project.entry-points.\"boardfarm\"]\n# the importable module path that contains your @hookimpl functions\nboardfarm_plugin = \"boardfarm_plugin_a.plugins.registration\"\n</code></pre> <p>Template (Generic):</p> <pre><code>[project]\nname = \"boardfarm_&lt;plugin_name&gt;\"\n...\n[project.entry-points.\"boardfarm\"]\nboardfarm_plugin = \"boardfarm_&lt;plugin_name&gt;.plugins.registration\"\n\n</code></pre> <p>Notes:</p> <ul> <li><code>boardfarm_plugin</code> is an arbitrary key \u2014 Boardfarm will load the value (plugin module) in the <code>boardfarm</code> entry-point group.</li> <li>Ensure your package name and entry-point module are importable when the package is installed.</li> </ul>"},{"location":"development/#making-your-plugin-discoverable","title":"Making your plugin discoverable","text":"<p>From your project root, install the package (use editable option during development):</p> <pre><code>pip install -e .\n</code></pre> <p>This registers the <code>boardfarm</code> entry-point for your package in the current environment so <code>plugin_manager.load_setuptools_entrypoints(\"boardfarm\")</code> can find it. This way the runner registers the @hookimpl functions with the Pluggy PluginManager.</p> <p>After loading:</p> <ul> <li>Boardfarm may call your core hooks (e.g., <code>boardfarm_add_cmdline_args</code>) during runner setup.</li> <li>The runner uses <code>boardfarm_add_devices()</code> mapping to know which concrete classes correspond to inventory \"type\" values.</li> </ul>"},{"location":"development/#writing-a-device-class","title":"Writing a Device class","text":""},{"location":"development/#minimal-plugin-example","title":"Minimal plugin example","text":"<p>Create <code>plugins/registration.py</code> and implement <code>@hookimpl</code> functions. Keep core hooks module-level and device hooks as <code>@hookimpl</code> instance methods inside device classes in <code>devices/</code>.</p>"},{"location":"development/#pluginregistrationpy","title":"<code>plugin/registration.py</code>","text":"<pre><code># plugins/registration.py\nfrom boardfarm3 import hookimpl\nfrom boardfarm3.devices.base_devices import BoardfarmDevice\nfrom boardfarm_&lt;plugin_name&gt;.devices.device_a import DeviceA  # replace with your package\n\n@hookimpl\ndef boardfarm_add_devices() -&gt; dict[str, type[BoardfarmDevice]]:\n    \"\"\"Register the concrete device types this package provides.\"\"\"\n    return {\n        \"device_a\": DeviceA,\n    }\n\n@hookimpl\ndef boardfarm_add_cmdline_args(argparser):\n    argparser.add_argument(\"--devicea-debug\", action=\"store_true\", help=\"Enable DeviceA plugin debug\")\n\n</code></pre>"},{"location":"development/#templatesdevicepy-skeleton","title":"<code>templates/device.py</code> (Skeleton)","text":"<pre><code># templates/device.py\nfrom abc import ABC, abstractmethod\n\nclass DevA(ABC):\n    \"\"\"Minimal template for DeviceA-style devices.\n\n    Implementations must provide `method_x`. Use cases and tests should\n    depend on this ABC, not concrete classes.\n    \"\"\"\n\n    @abstractmethod\n    def method_x(self, payload=None, timeout=None):\n        \"\"\"Perform method_x on the device.\n\n        :param payload: optional input data\n        :param timeout: optional timeout in seconds\n        :return: result (implementation-specific)\n        \"\"\"\n        raise NotImplementedError\n\n</code></pre>"},{"location":"development/#devicesdevice_apy-skeleton","title":"<code>devices/device_a.py</code> (Skeleton)","text":"<pre><code># devices/device_a.py\nfrom boardfarm3 import hookimpl\nfrom boardfarm3.devices.base_devices import LinuxDevice\nfrom boardfarm_plugin_a.templates.device import DevA\n\nclass DeviceA(LinuxDevice, DevA):\n    def __init__(self, config, cmdline_args):\n        super().__init__(config, cmdline_args)\n        # initialization...\n\n    def method_x(self, payload=None, timeout=None):\n        \"\"\"Concrete implementation of the template method.\"\"\"\n        # do device interaction (SSH/HTTP/console/etc.)\n        return {\"status\": \"ok\", \"payload\": payload}\n\n    @hookimpl\n    def boardfarm_server_boot(self):\n        self._connect()\n        # any init steps\n\n    @hookimpl\n    def contingency_check(self, env_req, device_manager=None):\n        # raise ContingencyCheckError on failure, or return None on success\n        pass\n</code></pre> <p>Why instance methods for device hooks?</p> <p>Device hooks often require access to device instance state (console, HTTP client, config). Decorating instance methods with @hookimpl allows the runner to call the method on the instantiated device object.</p>"},{"location":"development/#inventory-example-for-devicea","title":"Inventory example for <code>DeviceA</code>","text":"<p>Boardfarm looks up the <code>type</code> value from the inventory and instantiates the registered class (e.g. <code>DeviceA</code>) for that entry. The root-level key in this example is <code>plugin-a-board1</code> and it contains a <code>devices</code> list.</p> <pre><code>{\n  \"plugin-a-board1\": {\n    \"devices\": [\n      {\n        \"name\": \"devicea-1\",\n        \"type\": \"device_a\",\n        \"connection_type\": \"authenticated_ssh\",\n        \"ipaddr\": \"192.168.1.10\",\n        \"port\": 22,\n        \"username\": \"root\",\n        \"password\": \"changeme\",\n        \"options\": \"some-option,other-flag\",\n        \"color\": \"blue\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"development/#runtime-behavior","title":"Runtime behavior","text":"<ul> <li>At setup the runner passes the device entry (the full dict) into the device constructor: <code>DeviceA(config_for_entry, cmdline_args)</code>.</li> <li>Device implementations should read required fields from their <code>config</code> (e.g. <code>self._config.get(\"ipaddr\")</code>) and raise a clear error if required keys are missing.</li> <li>If your driver needs additional inventory keys (serial, product_class, oui, vlans, etc.), document them in your plugin README and validate them in <code>validate_device_requirements</code> or during device instantiation.</li> </ul>"},{"location":"development/#writing-a-connection-class","title":"Writing a Connection class","text":""},{"location":"development/#connection-layer-transport-vs-device-logic","title":"Connection layer (transport vs device logic)","text":"<p>Boardfarm separates transport (how you talk to a device) from device logic (what you do with the device). The connection layer (classes like <code>SSHConnection</code>, <code>TelnetConnection</code>, <code>LocalCmd</code>, etc.) implements a small, consistent console API (based on <code>BoardfarmPexpect</code>) that device implementations use to execute commands, read output, and perform interactive tasks.</p> <p>The <code>connection_factory(...)</code> centralizes creating the right connection object based on the inventory <code>connection_type</code> and parameters. Devices call the factory, get back a <code>BoardfarmPexpect</code>-derived object, and use its methods (<code>sendline</code>, <code>expect</code>, <code>execute_command</code>, <code>get_last_output</code>, async variants, etc.) \u2014 the device code does not need to know whether the transport is SSH, serial, telnet or a <code>docker exec</code>-style local command.</p>"},{"location":"development/#benefits","title":"Benefits","text":"<ul> <li>Transport abstraction \u2014 device code is written once; the transport can change without touching use-cases or device implementations.</li> <li>Consistent API \u2014 devices always call the same methods (sync/async) on the returned connection object.</li> <li>Centralized error handling &amp; logging \u2014 connection classes raise framework errors (<code>DeviceConnectionError</code>, <code>BoardfarmException</code>, <code>EnvConfigError</code>) and handle console-log saving in one place.</li> <li>Easier testing &amp; mocking \u2014 swap real connections for fakes/mocks implementing the same API.</li> <li>Extensibility \u2014 add new transports by implementing a connection class and registering it in <code>connection_factory</code>.</li> <li>Async support \u2014 many connection classes provide both sync and async methods (<code>login_to_server_async</code>, <code>execute_command_async</code>) for scalable parallel provisioning.</li> </ul>"},{"location":"development/#how-devices-use-it-typical-flow-_connect","title":"How devices use it \u2014 typical flow (<code>_connect</code>)","text":"<p>A device usually implements a <code>_connect()</code> helper that:</p> <ol> <li>Calls <code>connection_factory(...)</code> with <code>connection_type</code> and connection params from the <code>inventory</code> JSON entry.</li> <li>Calls <code>login_to_server(...)</code> (or <code>login_to_server_async(...)</code>) to complete authentication.</li> <li>Normalizes the terminal (for example <code>stty columns 400; export TERM=xterm</code>) to make command output parsing stable.</li> </ol>"},{"location":"development/#compact-example-_connect-method-for-device-a","title":"Compact example (<code>_connect</code> method for device A)","text":"<pre><code>def _connect(self) -&gt; None:\n    \"\"\"Establish connection to the device via SSH (or other transport).\"\"\"\n    if self._console is None:\n        # create the right connection object based on inventory\n        self._console = connection_factory(\n            self._config.get(\"connection_type\"), # check INV JSON\n            f\"{self.device_name}.console\",\n            ... # remaining args\n        )\n\n        # perform authentication (sync or async variant)\n        self._console.login_to_server(password=self._password)\n\n        # stabilize terminal for predictable parsing\n        self._console.execute_command(\"stty columns 400; export TERM=xterm\")\n</code></pre>"},{"location":"development/#notes-tips","title":"Notes / tips","text":"<ul> <li>Use <code>connection_factory</code> rather than creating transport objects directly \u2014 it keeps device code portable and consistent.</li> <li>Prefer high-level helpers like <code>execute_command()</code> unless you need fine-grained <code>expect()</code> control. High-level helpers handle prompt/timeout edge cases for you.</li> <li>Validate required inventory fields (<code>ipaddr</code>, <code>port</code>, <code>username</code>, etc.) during device construction or in <code>validate_device_requirements</code> so failures are detected early.</li> <li>Use async methods for concurrency: if your device supports asyncio and you implement <code>*_async</code> hooks, call <code>login_to_server_async()</code> and <code>execute_command_async()</code> to avoid blocking other provisioning tasks.</li> </ul>"},{"location":"development/#writing-a-use-case","title":"Writing a Use Case","text":"<p>This short how-to shows a small use case that provisions a <code>DeviceA</code>-style device by calling the templated API <code>method_x</code>. The use case depends only on the template (ABC) \u2014 <code>DevA</code> \u2014 not on any concrete implementation. This keeps tests and scripts vendor-agnostic.</p> <p>File: <code>use_cases/provisioning.py</code></p> <pre><code># use_cases/provisioning.py\nfrom __future__ import annotations\nfrom typing import Any\n\n# import the template/ABC, not a concrete class\nfrom boardfarm_plugin_a.templates.device import DevA\n\n\ndef provision_device(\n    device: DevA,\n    config: dict[str, Any] | None = None,\n    timeout: int | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Provision a DeviceA-style device.\"\"\"\n    payload = config or {\"action\": \"default_provision\"}\n\n    # call the templated API\n    # concrete DeviceA (or any other implementation)\n    # will perform the actual transport/IO\n    result = device.method_x(payload=payload, timeout=timeout)\n\n    # basic validation of result (example)\n    if not isinstance(result, dict) or result.get(\"status\") != \"ok\":\n        raise RuntimeError(f\"Provisioning failed: {result}\")\n\n    return result\n</code></pre>"},{"location":"development/#example-usage","title":"Example Usage","text":""},{"location":"development/#interactive-shell-ipython","title":"Interactive Shell (IPython)","text":"<pre><code>from boardfarm_plugin_a.templates.device import DevA\nfrom boardfarm3.lib.device_manager import DeviceManager\nfrom boardfarm_plugin_a.use_cases.provisioning import provision_device\n\n# device_manager is provided by the runner / interact session\ndevice: DevA = device_manager.get_device_by_type(DevA)\nresult = provision_device(device, config={\"action\": \"apply_profile\", \"profile\": \"A1\"})\nprint(result)\n\n</code></pre>"},{"location":"development/#pytest-example","title":"Pytest Example","text":"<pre><code>def test_provision_device(device_manager):\n    device = device_manager.get_device_by_type(DevA)\n    res = provision_device(device, {\"action\": \"apply_profile\", \"profile\": \"CI\"}, timeout=60)\n    assert res[\"status\"] == \"ok\"\n\n</code></pre>"},{"location":"development/#design-notes-best-practices","title":"Design notes &amp; best practices","text":"<ul> <li>Type hints use the template (ABC) \u2014 <code>DevA</code> \u2014 so the use case is independent of concrete drivers.</li> <li>Keep use cases small and focused \u2014 orchestration and business logic belong here; transport and vendor quirks remain in device implementations.</li> <li>Propagate errors so tests/runner can handle retries or fail fast. Optionally use retry helpers (e.g. <code>retry_on_exception</code>) for transient operations.</li> <li>Return a stable structure (e.g. <code>{\"status\": \"ok\", \"data\": {...}}</code>) so callers can assert on consistent fields across vendors.</li> <li>Document expected payload keys for <code>config</code> in the plugin README so integrators know which fields a concrete <code>DeviceA</code> expects.</li> </ul> <p>Tip \u2014 use-cases are business logic, name them by protocol/behavior, not by device type. In networking, prefer protocol- or feature-oriented names for use case modules (for example <code>use_cases/tr069.py</code> for ACS/TR-069 operations) rather than <code>use_cases/acs_device.py</code>. Templates abstract device types \u2014 use case names should reflect the business operation (e.g. <code>tr069</code>, <code>dhcp_provision</code>, <code>firmware_flash</code>) so they remain meaningful across different implementations.</p>"},{"location":"getting_started/","title":"Getting Started with Boardfarm","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>Depending on your distribution you need some dependencies. On Debian these usually are:</p> <pre><code>sudo apt install -y automake libtool libsnmp-dev bison make gcc flex git libglib2.0-dev libfl-dev python3.13-venv\n</code></pre> <p>It is recommended to install boardfarm in a virtualenv:</p> <pre><code>python3.13 -m venv --prompt bf-venv venv\nsource venv/bin/activate\npip install --upgrade pip wheel\n</code></pre>"},{"location":"getting_started/#install-latest-release","title":"Install Latest Release","text":"<pre><code>(bf-venv)$ pip install boardfarm\n</code></pre>"},{"location":"getting_started/#install-development-build","title":"Install Development Build","text":"<p>Start by cloning the repository and installing boardfarm:</p> <pre><code>(bf-venv)$ git clone https://github.com/lgirdk/boardfarm\n(bf-venv)$ cd boardfarm &amp;&amp; pip install -e .[doc,dev,test]\n</code></pre> <p>Note: For certain boardfarm plugin packages like <code>boardfarm[docsis]</code>, additional tools need to be installed as prerequisite. e.g. DOCSIS bootfile encoder tool</p>"},{"location":"getting_started/#running-an-interactive-session","title":"Running an interactive session","text":"<p>Interact is a key feature in boardfarm that connects to every device currently deployed in a testbed and exposes a menu-driven CLI to interact with any of those devices. Every console interaction can be preserved in per-device log files.</p> <p>Boardfarm also provides an interactive IPython console that enables a user to execute commands on their devices via their corresponding Python APIs.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":""},{"location":"getting_started/#no-hardware-testbed-try-a-virtual-environment","title":"No hardware testbed? Try a virtual environment","text":"<p>In case you don\u2019t have access to a physical testbed, we have a Docker Compose script that spins up a virtual CPE (PrplOS) with a back-office. This lets you explore interact sessions and device APIs locally on your workstation.</p> <p>More details can be found in the raikou-net project if you\u2019re interested in a more complete and in depth virtualized setup. To quickly deploy a local environment, run:</p> <pre><code># Assuming boardfarm repo is already cloned\n\ncd resources/deploy/prplos\ndocker compose up -f docker-compose.yaml -d\n</code></pre> <p>Note: If you want to explore more examples, see <code>/examples/double_hop</code> directory in raikou-net</p>"},{"location":"getting_started/#understanding-inventory-and-environment-files","title":"Understanding Inventory and Environment files","text":"<p>Boardfarm needs two configuration files to know what to deploy and how to interact with it:</p>"},{"location":"getting_started/#inventory-file-inventoryjson","title":"Inventory file (<code>inventory.json</code>)","text":"<ul> <li>Describes the devices in your testbed and how Boardfarm connects to them.</li> <li>Each device entry specifies:</li> <li>connection type (serial, ssh, docker exec, etc.)</li> <li>login credentials / ports / proxies</li> <li>role/type (CPE, WAN, LAN, ACS, DHCP, SIP server, phones, etc.)</li> <li>options that customize network behavior (e.g., static IPs, DHCP off/on, DNS, VLAN).</li> <li>Think of it as a map of your deployed infrastructure and the \u201cdoorways\u201d Boardfarm can use to reach each device.</li> </ul> <p>Example (excerpt taken from <code>boardfarm3/configs/boardfarm_config_example.json</code>):</p> <pre><code>{\n   \"prplos-docker-1\": {\n   \"devices\": [\n      {\n      \"conn_cmd\": [\"docker exec -it cpe ash\"],\n      \"connection_type\": \"local_cmd\",\n      \"name\": \"board\",\n      \"type\": \"bf_cpe\",\n      \"gui_password\": \"admin\"\n      },\n      {\n      \"connection_type\": \"authenticated_ssh\",\n      \"ipaddr\": \"localhost\",\n      \"port\": 4001,\n      \"name\": \"wan\",\n      \"type\": \"bf_wan\",\n      \"options\": \"wan-no-dhcp-server, dns-server, wan-static-ip:172.25.1.2/24\"\n      }\n      // ... more devices like lan, acs, phones, provisioner, etc.\n   ]\n   }\n}\n</code></pre> <p>In this setup, the board is reached through a local Docker exec command, while WAN, LAN, ACS, and phones are accessed via SSH on different forwarded ports.</p> <p>Please see Inventory Schema for a list of all possible options that can be configured for a device in an Inventory file.</p>"},{"location":"getting_started/#environment-file-envjson","title":"Environment file (<code>env.json</code>)","text":"<ul> <li>Tells Boardfarm how to provision the testbed once devices are connected.</li> <li>Defines higher-level testbed behavior and requirements, such as:</li> <li>Which firmware to flash on the board/CPE</li> <li>How DHCP should behave (options, VLANs, DNS)</li> <li>Whether to create multiple LAN/WLAN containers</li> <li>How subscriber configurations look if an LTS (Line Termination System) is present</li> <li>Other provisioning knobs (IPv4/IPv6 mode, model identifiers, etc.)</li> </ul> <p>Example (simple):</p> <pre><code>{\n   \"environment_def\": {\n   \"board\": {\n      \"eRouter_Provisioning_mode\": \"ipv4\",\n      \"model\": \"prplOS\"\n      }\n   }\n}\n</code></pre>"},{"location":"getting_started/#how-they-work-together","title":"How they work together?","text":"<p>Inventory = \u201cwhat\u2019s there\u201d</p> <ul> <li>A catalog of devices, connection methods, roles.</li> </ul> <p>Environment = \u201cwhat to do with it\u201d</p> <ul> <li>Provisioning rules, firmware flashing, DHCP setup, network topology.</li> </ul> <p>This tells Boardfarm:</p> <p>Connect to all devices listed in the inventory. Provision and configure them according to the environment definition. Expose them via the interact session (menu + IPython).</p>"},{"location":"getting_started/#start-an-interact-session","title":"Start an interact session","text":"<p>Now that we have our environment and inventory files, we can start an interactive session with Boardfarm.</p> <pre><code>boardfarm --board-name  prplos-docker-1 \\\n    --env-config ./boardfarm3/configs/boardfarm_env_example.json \\\n    --inventory-config ./boardfarm3/configs/boardfarm_config_example.json \\\n    --skip-boot --legacy\n</code></pre> <p>(Optional) --save-console-logs enabled to persist console logs to disk.</p> <p>This will bring up the Boardfarm Interactive Shell, where all deployed devices are listed and ready for interaction. </p> <p>When you see this menu:</p> <pre><code>                BOARDFARM INTERACTIVE SHELL\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  Choice   Description                           Consoles\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    1      board (bf_cpe)                           1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    2      genieacs (bf_acs)                        1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    3      lan (bf_lan)                             1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    4      lan_phone (bf_phone)                     1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    5      provisioner (bf_dhcp)                    1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    6      sipcenter (bf_kamailio)                  1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    7      wan (bf_wan)                             1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    8      wan_phone (bf_phone)                     1\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    p      python interactive shell (ptpython)\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    q      exit\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnter your choice: [1/2/3/4/5/6/7/8/p/q]:\n</code></pre> <p>You have two main options:</p> <ul> <li> <p>Device console access \u2192 enter the number (1\u20138) beside a device to drop directly into its console session.</p> </li> <li> <p>Python interactive shell \u2192 enter <code>p</code> to open an IPython-like interface (ptpython) where you can import devices and call their Python APIs to run commands or tests programmatically.</p> </li> </ul> <p>This makes it easy to switch between manual console exploration and Python-based automation in the same session.</p>"},{"location":"getting_started/#booting-up-a-lab-environment","title":"Booting up a lab environment","text":"<p>In the previous example, we started Boardfarm with the <code>--skip-boot</code> option to quickly attach to already running devices. If we remove the <code>--skip-boot</code> option, Boardfarm will not just connect to devices \u2014 it will also provision them based on the environment file you provided.</p> <p>Behind the scenes, Boardfarm uses Pluggy (the same plugin system used by pytest). This means that devices participate in different lifecycle phases by implementing specific plugin hooks.</p>"},{"location":"getting_started/#bootprovisioning-hooks","title":"Boot/Provisioning Hooks","text":"<p>When boot is not skipped, Boardfarm\u2019s plugin manager executes the following hooks in order:</p> <pre><code>boardfarm_server_boot\n\u2193\nboardfarm_server_configure\n\u2193\nboardfarm_device_boot\n\u2193\nboardfarm_device_configure\n\u2193\nboardfarm_attached_device_boot\n\u2193\nboardfarm_attached_device_configure\n</code></pre> <p>Each of the above is an actual <code>@hookspec</code> that a device class can implement. If a registered device provides an implementation, it will participate in that phase of booting/provisioning.</p> <ul> <li>Server hooks (<code>boardfarm_server_*</code>) \u2192 for back office infrastructure or virtualized service containers (e.g., DHCP, DNS, WAN, ACS, SIP servers).</li> <li>Device hooks (<code>boardfarm_device_*</code>) \u2192 for the main CPE/board a.k.a DUT.</li> <li>Attached device hooks (<code>boardfarm_attached_device_*</code>) \u2192 for LAN/WLAN clients, phones, or other peripherals that can only be provisioned once the main board is up.</li> </ul> <p>This layered boot sequence ensures that back-office infrastructure services are available before devices boot, and devices are provisioned before attached clients are configured.</p> <p>Please have a look at the boardfarm hooks section for more details.</p>"},{"location":"getting_started/#tldr","title":"TLDR","text":"<pre><code>git clone https://github.com/lgirdk/boardfarm.git\ncd boardfarm\n\ncd resources/deploy/prplos\ndocker-compose up -f docker-compose.yaml -d\ndocker ps # make sure the containers are up and running\n\ncd - # go back to the boardfarm repo root dir\n\npython3.13 -m venv --prompt bf-venv venv # will work on 3.11 as well\nsource venv/bin/activate\n\npip install -U pip wheel\npip install -e .[dev,test,doc]\n# or pip install boardfarm3[pytest]\n\nboardfarm --board-name  prplos-docker-1 \\\n          --env-config ./boardfarm3/configs/boardfarm_env_example.json \\\n          --inventory-config ./boardfarm3/configs/boardfarm_config_example.json \\\n          --save-console-logs ./logs\n</code></pre>"},{"location":"reference/hooks/","title":"Hooks","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs","title":"hookspecs","text":"<p>Boardfarm plugin hookspecs.</p> <p>Modules:</p> Name Description <code>core</code> <p>Boardfarm main hook specifications.</p> <code>devices</code> <p>Boardfarm device hook specifications.</p>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core","title":"core","text":"<p>Boardfarm main hook specifications.</p> <p>Functions:</p> Name Description <code>boardfarm_add_cmdline_args</code> <p>Add new command line argument(s).</p> <code>boardfarm_add_devices</code> <p>Add devices to known devices list.</p> <code>boardfarm_add_hookspecs</code> <p>Add new hookspecs to extend and/or update the framework.</p> <code>boardfarm_cmdline_parse</code> <p>Parse command line arguments.</p> <code>boardfarm_configure</code> <p>Configure boardfarm based on command line arguments or environment config.</p> <code>boardfarm_parse_config</code> <p>Parse the config.</p> <code>boardfarm_post_setup_env</code> <p>Call after the environment setup is completed for all the devices.</p> <code>boardfarm_register_devices</code> <p>Register device to plugin manager.</p> <code>boardfarm_release_devices</code> <p>Release reserved devices after use.</p> <code>boardfarm_reserve_devices</code> <p>Reserve devices before starting the deployment.</p> <code>boardfarm_setup_env</code> <p>Boardfarm environment setup for all the devices.</p> <code>boardfarm_shutdown_device</code> <p>Shutdown boardfarm device after use.</p>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_add_cmdline_args","title":"boardfarm_add_cmdline_args","text":"<pre><code>boardfarm_add_cmdline_args(argparser: ArgumentParser) -&gt; None\n</code></pre> <p>Add new command line argument(s).</p> <p>Parameters:</p> Name Type Description Default <code>ArgumentParser</code> <p>argument parser</p> required Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec\ndef boardfarm_add_cmdline_args(argparser: ArgumentParser) -&gt; None:\n    \"\"\"Add new command line argument(s).\n\n    :param argparser: argument parser\n    :type argparser: ArgumentParser\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_add_cmdline_args(argparser)","title":"<code>argparser</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_add_devices","title":"boardfarm_add_devices","text":"<pre><code>boardfarm_add_devices() -&gt; dict[str, type[BoardfarmDevice]]\n</code></pre> <p>Add devices to known devices list.</p> <p>This hook is used to let boardfarm know the devices which are configured in the inventory config. Each repo with a boardfarm device should implement this hook to add each devices to the list of known devices.</p> <p>Returns:</p> Type Description <code>dict[str, type[BoardfarmDevice]]</code> <p>dictionary with device name and class</p> Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec\ndef boardfarm_add_devices() -&gt; dict[str, type[BoardfarmDevice]]:\n    \"\"\"Add devices to known devices list.\n\n    This hook is used to let boardfarm know the devices which are configured\n    in the inventory config.\n    Each repo with a boardfarm device should implement this hook to add each\n    devices to the list of known devices.\n\n    :return: dictionary with device name and class\n    :rtype: dict[str, type[BoardfarmDevice]]\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_add_hookspecs","title":"boardfarm_add_hookspecs","text":"<pre><code>boardfarm_add_hookspecs(plugin_manager: PluginManager) -&gt; None\n</code></pre> <p>Add new hookspecs to extend and/or update the framework.</p> <p>Parameters:</p> Name Type Description Default <code>PluginManager</code> <p>plugin manager</p> required Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec\ndef boardfarm_add_hookspecs(plugin_manager: PluginManager) -&gt; None:\n    \"\"\"Add new hookspecs to extend and/or update the framework.\n\n    :param plugin_manager: plugin manager\n    :type plugin_manager: PluginManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_add_hookspecs(plugin_manager)","title":"<code>plugin_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_cmdline_parse","title":"boardfarm_cmdline_parse","text":"<pre><code>boardfarm_cmdline_parse(\n    argparser: ArgumentParser, cmdline_args: list[str]\n) -&gt; Namespace\n</code></pre> <p>Parse command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>ArgumentParser</code> <p>argument parser</p> required <code>list[str]</code> <p>command line arguments</p> required <p>Returns:</p> Type Description <code>Namespace</code> <p>command line arguments</p> Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec(firstresult=True)\ndef boardfarm_cmdline_parse(\n    argparser: ArgumentParser,\n    cmdline_args: list[str],\n) -&gt; Namespace:\n    \"\"\"Parse command line arguments.\n\n    :param argparser: argument parser\n    :type argparser: ArgumentParser\n    :param cmdline_args: command line arguments\n    :type cmdline_args: list[str]\n    :return: command line arguments\n    :rtype: Namespace\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_cmdline_parse(argparser)","title":"<code>argparser</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_cmdline_parse(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_configure","title":"boardfarm_configure","text":"<pre><code>boardfarm_configure(cmdline_args: Namespace, plugin_manager: PluginManager) -&gt; None\n</code></pre> <p>Configure boardfarm based on command line arguments or environment config.</p> <p>This hook allows to register/deregister boardfarm plugins when you pass a command line argument. This way a plugin will be registered to boardfarm only when required.</p> <p>Parameters:</p> Name Type Description Default <code>Namespace</code> <p>command line arguments</p> required <code>PluginManager</code> <p>plugin manager</p> required Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec\ndef boardfarm_configure(cmdline_args: Namespace, plugin_manager: PluginManager) -&gt; None:\n    \"\"\"Configure boardfarm based on command line arguments or environment config.\n\n    This hook allows to register/deregister boardfarm plugins when you pass a\n    command line argument. This way a plugin will be registered to boardfarm only\n    when required.\n\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param plugin_manager: plugin manager\n    :type plugin_manager: PluginManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_configure(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_configure(plugin_manager)","title":"<code>plugin_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_parse_config","title":"boardfarm_parse_config","text":"<pre><code>boardfarm_parse_config(\n    cmdline_args: Namespace,\n    inventory_config: dict[str, Any],\n    env_config: dict[str, Any],\n) -&gt; BoardfarmConfig\n</code></pre> <p>Parse the config.</p> <p>This hook allows for the modification (if needed) of the configuration files, like inventory and environment, by using cmd line overrides.</p> <p>Parameters:</p> Name Type Description Default <code>Namespace</code> <p>command line arguments</p> required <code>dict[str, Any]</code> <p>inventory json</p> required <code>dict[str, Any]</code> <p>environment json</p> required <p>Returns:</p> Type Description <code>BoardfarmConfig</code> <p>a BoardfarmConfig object</p> Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec(firstresult=True)\ndef boardfarm_parse_config(\n    cmdline_args: Namespace,\n    inventory_config: dict[str, Any],\n    env_config: dict[str, Any],\n) -&gt; BoardfarmConfig:\n    \"\"\"Parse the config.\n\n    This hook allows for the modification (if needed) of the configuration files,\n    like inventory and environment, by using cmd line overrides.\n\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param inventory_config: inventory json\n    :type inventory_config: dict[str, Any]\n    :param env_config: environment json\n    :type env_config: dict[str, Any]\n    :return: a BoardfarmConfig object\n    :rtype: BoardfarmConfig\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_parse_config(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_parse_config(inventory_config)","title":"<code>inventory_config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_parse_config(env_config)","title":"<code>env_config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_post_setup_env","title":"boardfarm_post_setup_env","text":"<pre><code>boardfarm_post_setup_env(\n    cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Call after the environment setup is completed for all the devices.</p> <p>This hook is used to perform required operations after the board is deployed.</p> <p>Parameters:</p> Name Type Description Default <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec\ndef boardfarm_post_setup_env(\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Call after the environment setup is completed for all the devices.\n\n    This hook is used to perform required operations after the board is deployed.\n\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_post_setup_env(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_post_setup_env(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_register_devices","title":"boardfarm_register_devices","text":"<pre><code>boardfarm_register_devices(\n    config: BoardfarmConfig, cmdline_args: Namespace, plugin_manager: PluginManager\n) -&gt; DeviceManager\n</code></pre> <p>Register device to plugin manager.</p> <p>This hook is responsible to register devices to the device manager after initialization based on the given inventory and environment config.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>PluginManager</code> <p>plugin manager instance</p> required <p>Returns:</p> Type Description <code>DeviceManager</code> <p>device manager with all registered devices</p> Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec(firstresult=True)\ndef boardfarm_register_devices(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    plugin_manager: PluginManager,\n) -&gt; DeviceManager:\n    \"\"\"Register device to plugin manager.\n\n    This hook is responsible to register devices to the device manager after\n    initialization based on the given inventory and environment config.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param plugin_manager: plugin manager instance\n    :type plugin_manager: PluginManager\n    :return: device manager with all registered devices\n    :rtype: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_register_devices(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_register_devices(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_register_devices(plugin_manager)","title":"<code>plugin_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_release_devices","title":"boardfarm_release_devices","text":"<pre><code>boardfarm_release_devices(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    plugin_manager: PluginManager,\n    deployment_status: dict[str, Any],\n) -&gt; None\n</code></pre> <p>Release reserved devices after use.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>PluginManager</code> <p>plugin manager instance</p> required <code>dict[str, Any]</code> <p>deployment status data</p> required Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec\ndef boardfarm_release_devices(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    plugin_manager: PluginManager,\n    deployment_status: dict[str, Any],\n) -&gt; None:\n    \"\"\"Release reserved devices after use.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param plugin_manager: plugin manager instance\n    :type plugin_manager: PluginManager\n    :param deployment_status: deployment status data\n    :type deployment_status: Dict[str, Any]\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_release_devices(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_release_devices(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_release_devices(plugin_manager)","title":"<code>plugin_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_release_devices(deployment_status)","title":"<code>deployment_status</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_reserve_devices","title":"boardfarm_reserve_devices","text":"<pre><code>boardfarm_reserve_devices(\n    cmdline_args: Namespace, plugin_manager: PluginManager\n) -&gt; dict[str, Any]\n</code></pre> <p>Reserve devices before starting the deployment.</p> <p>This hook is used to reserve devices before deployment.</p> <p>Parameters:</p> Name Type Description Default <code>Namespace</code> <p>command line arguments</p> required <code>PluginManager</code> <p>plugin manager instance</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>inventory configuration</p> Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec(firstresult=True)\ndef boardfarm_reserve_devices(\n    cmdline_args: Namespace,\n    plugin_manager: PluginManager,\n) -&gt; dict[str, Any]:\n    \"\"\"Reserve devices before starting the deployment.\n\n    This hook is used to reserve devices before deployment.\n\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param plugin_manager: plugin manager instance\n    :type plugin_manager: PluginManager\n    :return: inventory configuration\n    :rtype: dict[str, Any]\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_reserve_devices(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_reserve_devices(plugin_manager)","title":"<code>plugin_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_setup_env","title":"boardfarm_setup_env","text":"<pre><code>boardfarm_setup_env(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    plugin_manager: PluginManager,\n    device_manager: DeviceManager,\n) -&gt; DeviceManager\n</code></pre> <p>Boardfarm environment setup for all the devices.</p> <p>This hook is used to deploy boardfarm devices.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config</p> required <code>Namespace</code> <p>command line arguments</p> required <code>PluginManager</code> <p>plugin manager instance</p> required <code>DeviceManager</code> <p>device manager instance</p> required <p>Returns:</p> Type Description <code>DeviceManager</code> <p>device manager with all devices in the environment</p> Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec(firstresult=True)\ndef boardfarm_setup_env(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    plugin_manager: PluginManager,\n    device_manager: DeviceManager,\n) -&gt; DeviceManager:\n    \"\"\"Boardfarm environment setup for all the devices.\n\n    This hook is used to deploy boardfarm devices.\n\n    :param config: boardfarm config\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param plugin_manager: plugin manager instance\n    :type plugin_manager: PluginManager\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    :return: device manager with all devices in the environment\n    :rtype: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_setup_env(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_setup_env(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_setup_env(plugin_manager)","title":"<code>plugin_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_setup_env(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.core.boardfarm_shutdown_device","title":"boardfarm_shutdown_device","text":"<pre><code>boardfarm_shutdown_device() -&gt; None\n</code></pre> <p>Shutdown boardfarm device after use.</p> <p>This hook should be used by a device to perform a clean shutdown of a device after releasing all the resources (e.g. close all of the open ssh connections) before the shutdown of the framework.</p> Source code in <code>boardfarm3/plugins/hookspecs/core.py</code> <pre><code>@hookspec\ndef boardfarm_shutdown_device() -&gt; None:\n    \"\"\"Shutdown boardfarm device after use.\n\n    This hook should be used by a device to perform a clean shutdown of a device\n    after releasing all the resources (e.g. close all of the open ssh connections)\n    before the shutdown of the framework.\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices","title":"devices","text":"<p>Boardfarm device hook specifications.</p> <p>A Boardfarm device should belong to one of the following categories:</p> <pre><code>1. server, i.e. DHCP, ACS...\n2. device, i.e. a connectivity CPE\n3. attached device, i.e. a LAN client\n</code></pre> <p>Every device should fulfill the following responsibilities at different stages of the deployment.</p> <p>Hook responsibilities:</p> <pre><code>1. skip boot\n    - device can be interacted with as it is without making\n      any changes to it\n\n2. boot\n    - device is running with required software\n    - device can be interacted with, e.g. via console\n    - device has a management IP address or direct console access\n      if the device has a console\n\n3. configure\n    - all of the points from boot\n    - user driven configurations are applied to the device\n    - device has a service IP address if applicable\n        Eg: A CPE device has access network IP address,\n            eRouter IP, except in disabled mode, eMTA IP\n    - for Wi-Fi clients, no connection to the Wi-Fi network\n      is made and no IP address on service interface is assigned\n</code></pre> <p>Functions:</p> Name Description <code>boardfarm_attached_device_boot</code> <p>Boot boardfarm attached device.</p> <code>boardfarm_attached_device_boot_async</code> <p>Boot boardfarm attached device leveraging the asyncio library.</p> <code>boardfarm_attached_device_configure</code> <p>Configure boardfarm attached device.</p> <code>boardfarm_attached_device_configure_async</code> <p>Configure boardfarm attached device.</p> <code>boardfarm_device_boot</code> <p>Boot boardfarm device.</p> <code>boardfarm_device_configure</code> <p>Configure boardfarm device.</p> <code>boardfarm_device_configure_async</code> <p>Configure boardfarm device.</p> <code>boardfarm_server_boot</code> <p>Boot boardfarm server device.</p> <code>boardfarm_server_configure</code> <p>Configure boardfarm server device.</p> <code>boardfarm_server_configure_async</code> <p>Configure boardfarm server device leveraging the asyncio library.</p> <code>boardfarm_skip_boot</code> <p>Skips the booting for the device connected.</p> <code>boardfarm_skip_boot_async</code> <p>Skips the booting for the device connected.</p> <code>contingency_check</code> <p>Perform contingency check to make sure the device is working fine before use.</p> <code>validate_device_requirements</code> <p>Validate device requirements.</p> <code>validate_device_requirements_async</code> <p>Validate device requirements.</p>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot","title":"boardfarm_attached_device_boot","text":"<pre><code>boardfarm_attached_device_boot(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Boot boardfarm attached device.</p> <p>This hook should be used to boot a device which is attached to a device in the environment. E.g. LAN.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_attached_device_boot(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Boot boardfarm attached device.\n\n    This hook should be used to boot a device which is attached to a device\n    in the environment. E.g. LAN.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot_async","title":"boardfarm_attached_device_boot_async  <code>async</code>","text":"<pre><code>boardfarm_attached_device_boot_async(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Boot boardfarm attached device leveraging the asyncio library.</p> <p>This hook should be used to boot a device which is attached to a device in the environment. E.g. LAN. To be used for the asynchronous implementation.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\nasync def boardfarm_attached_device_boot_async(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Boot boardfarm attached device leveraging the asyncio library.\n\n    This hook should be used to boot a device which is attached to a device\n    in the environment. E.g. LAN.\n    To be used for the asynchronous implementation.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot_async(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot_async(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_boot_async(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure","title":"boardfarm_attached_device_configure","text":"<pre><code>boardfarm_attached_device_configure(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Configure boardfarm attached device.</p> <p>This hook should be used to configure a device, after having it booted, which is attached to a device in the environment. E.g. LAN.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_attached_device_configure(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Configure boardfarm attached device.\n\n    This hook should be used to configure a device, after having it booted,\n    which is attached to a device in the environment. E.g. LAN.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure_async","title":"boardfarm_attached_device_configure_async  <code>async</code>","text":"<pre><code>boardfarm_attached_device_configure_async(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Configure boardfarm attached device.</p> <p>This hook should be used to configure a device, after having it booted, which is attached to a device in the environment. E.g. LAN.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\nasync def boardfarm_attached_device_configure_async(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Configure boardfarm attached device.\n\n    This hook should be used to configure a device, after having it booted,\n    which is attached to a device in the environment. E.g. LAN.\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure_async(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure_async(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_attached_device_configure_async(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_boot","title":"boardfarm_device_boot","text":"<pre><code>boardfarm_device_boot(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Boot boardfarm device.</p> <p>This hook should be used to boot a device which is dependent on one or more servers in the environment. E.g. CPE.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_device_boot(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Boot boardfarm device.\n\n    This hook should be used to boot a device which is dependent on one or more\n    servers in the environment. E.g. CPE.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_boot(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_boot(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_boot(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure","title":"boardfarm_device_configure","text":"<pre><code>boardfarm_device_configure(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Configure boardfarm device.</p> <p>This hook should be used to configure a device, after having it booted, which is dependent on one or more servers in the environment. E.g. CPE.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_device_configure(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Configure boardfarm device.\n\n    This hook should be used to configure a device, after having it booted,\n    which is dependent on one or more servers in the environment. E.g. CPE.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure_async","title":"boardfarm_device_configure_async  <code>async</code>","text":"<pre><code>boardfarm_device_configure_async(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Configure boardfarm device.</p> <p>This hook should be used to configure a device, after having it booted, which is dependent on one or more servers in the environment. E.g. CPE.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\nasync def boardfarm_device_configure_async(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Configure boardfarm device.\n\n    This hook should be used to configure a device, after having it booted,\n    which is dependent on one or more servers in the environment. E.g. CPE.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure_async(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure_async(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_device_configure_async(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_boot","title":"boardfarm_server_boot","text":"<pre><code>boardfarm_server_boot(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Boot boardfarm server device.</p> <p>This hook should be used to boot a device which is not dependent on other devices in the environment. E.g. WAN and CMTS.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_server_boot(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Boot boardfarm server device.\n\n    This hook should be used to boot a device which is not dependent on other\n    devices in the environment. E.g. WAN and CMTS.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_boot(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_boot(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_boot(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure","title":"boardfarm_server_configure","text":"<pre><code>boardfarm_server_configure(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Configure boardfarm server device.</p> <p>This hook should be used to configure a device, after having it booted, which is not dependent on other devices in the environment. E.g. WAN and CMTS</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_server_configure(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Configure boardfarm server device.\n\n    This hook should be used to configure a device, after having it booted,\n    which is not dependent on other devices in the environment. E.g. WAN and CMTS\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure_async","title":"boardfarm_server_configure_async","text":"<pre><code>boardfarm_server_configure_async(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Configure boardfarm server device leveraging the asyncio library.</p> <p>This hook should be used to configure a device, after having it booted, which is not dependent on other devices in the environment. E.g. WAN and CMTS To be used for the asynchronous implementation.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_server_configure_async(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Configure boardfarm server device leveraging the asyncio library.\n\n    This hook should be used to configure a device, after having it booted,\n    which is not dependent on other devices in the environment. E.g. WAN and CMTS\n    To be used for the asynchronous implementation.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure_async(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure_async(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_server_configure_async(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot","title":"boardfarm_skip_boot","text":"<pre><code>boardfarm_skip_boot(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Skips the booting for the device connected.</p> <p>This hook skip the booting process on those devices that implement the boot_device hook</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef boardfarm_skip_boot(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Skips the booting for the device connected.\n\n    This hook skip the booting process on those\n    devices that implement the boot_device hook\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot_async","title":"boardfarm_skip_boot_async  <code>async</code>","text":"<pre><code>boardfarm_skip_boot_async(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Skips the booting for the device connected.</p> <p>This hook skip the booting process on those devices that implement the boot_device hook</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\nasync def boardfarm_skip_boot_async(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Skips the booting for the device connected.\n\n    This hook skip the booting process on those\n    devices that implement the boot_device hook\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot_async(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot_async(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.boardfarm_skip_boot_async(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.contingency_check","title":"contingency_check","text":"<pre><code>contingency_check(env_req: dict[str, Any], device_manager: DeviceManager) -&gt; None\n</code></pre> <p>Perform contingency check to make sure the device is working fine before use.</p> <p>This hook could be used by any device. It is used by the pytest-boardfarm plugin to make sure the device is in good condition before running each test.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, Any]</code> <p>environment request dictionary</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef contingency_check(env_req: dict[str, Any], device_manager: DeviceManager) -&gt; None:\n    \"\"\"Perform contingency check to make sure the device is working fine before use.\n\n    This hook could be used by any device.\n    It is used by the pytest-boardfarm plugin to make sure the device is in\n    good condition before running each test.\n\n    :param env_req: environment request dictionary\n    :type env_req: dict[str, Any]\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.contingency_check(env_req)","title":"<code>env_req</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.contingency_check(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements","title":"validate_device_requirements","text":"<pre><code>validate_device_requirements(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Validate device requirements.</p> <p>This hook is responsible to validate the requirements of a device before deploying devices to the environment. This allows us to fail the deployment early.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\ndef validate_device_requirements(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Validate device requirements.\n\n    This hook is responsible to validate the requirements of a device before\n    deploying devices to the environment.\n    This allows us to fail the deployment early.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements_async","title":"validate_device_requirements_async  <code>async</code>","text":"<pre><code>validate_device_requirements_async(\n    config: BoardfarmConfig, cmdline_args: Namespace, device_manager: DeviceManager\n) -&gt; None\n</code></pre> <p>Validate device requirements.</p> <p>This hook is responsible to validate the requirements of a device before deploying devices to the environment. This allows us to fail the deployment early.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>boardfarm config instance</p> required <code>Namespace</code> <p>command line arguments</p> required <code>DeviceManager</code> <p>device manager instance</p> required Source code in <code>boardfarm3/plugins/hookspecs/devices.py</code> <pre><code>@hookspec\nasync def validate_device_requirements_async(\n    config: BoardfarmConfig,\n    cmdline_args: Namespace,\n    device_manager: DeviceManager,\n) -&gt; None:\n    \"\"\"Validate device requirements.\n\n    This hook is responsible to validate the requirements of a device before\n    deploying devices to the environment.\n    This allows us to fail the deployment early.\n\n    :param config: boardfarm config instance\n    :type config: BoardfarmConfig\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements_async(config)","title":"<code>config</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements_async(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/hooks/#boardfarm3.plugins.hookspecs.devices.validate_device_requirements_async(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/libs/","title":"Lib","text":""},{"location":"reference/libs/#boardfarm3.lib","title":"lib","text":"<p>Boardfarm libs.</p> <p>Modules:</p> Name Description <code>SNMPv2</code> <p>SNMP v2 module for SNMP communication.</p> <code>boardfarm_config</code> <p>Boardfarm environment config module.</p> <code>boardfarm_pexpect</code> <p>Boardfarm pexpect session module.</p> <code>connection_factory</code> <p>Connection decider module.</p> <code>connections</code> <p>Boardfarm connections package.</p> <code>cpe_sw</code> <p>Common libraries of CPE Sw component.</p> <code>custom_typing</code> <p>Boardfarm3 custom type hints package.</p> <code>dataclass</code> <p>Boardfarm3 dataclasses.</p> <code>device_manager</code> <p>Boardfarm device manager.</p> <code>dmcli</code> <p>RDKB dmcli command line interface module.</p> <code>docker_factory</code> <p>Docker Factory v2 related libraries.</p> <code>gui</code> <p>Keep SonarQube happy.</p> <code>hal</code> <p>Hardware abstraction layers for different CPE components.</p> <code>interactive_shell</code> <p>Boardfarm interactive shell module.</p> <code>mibs_compiler</code> <p>MIBs to JSON compiler module.</p> <code>multicast</code> <p>Multicast library.</p> <code>network_utils</code> <p>Network utilities module.</p> <code>networking</code> <p>Boardfarm networking module.</p> <code>odh</code> <p>Boardfarm ODH client Package.</p> <code>parsers</code> <p>Linux command output parsers.</p> <code>power</code> <p>Power module.</p> <code>python_executor</code> <p>Python executor module.</p> <code>regexlib</code> <p>Useful regexes library.</p> <code>shell_prompt</code> <p>Boardfarm v3 base device shell prompts.</p> <code>utils</code> <p>Boardfarm common utilities module.</p> <code>wrappers</code> <p>Boardfarm decorators module.</p>"},{"location":"reference/libs/#boardfarm3.lib.SNMPv2","title":"SNMPv2","text":"<p>SNMP v2 module for SNMP communication.</p> <p>Classes:</p> Name Description <code>SNMPv2</code> <p>SNMP v2 module for SNMP communication.</p>"},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2","title":"SNMPv2","text":"<pre><code>SNMPv2(device: WAN, target_ip: str, mibs_compiler: MibsCompiler)\n</code></pre> <p>SNMP v2 module for SNMP communication.</p> <p>Initialize SNMPv2.</p> <p>Parameters:</p> Name Type Description Default <code>WAN</code> <p>device instance</p> required <code>str</code> <p>target ip address</p> required <code>MibsCompiler</code> <p>mibs compiler instance</p> required <p>Methods:</p> Name Description <code>snmpbulkget</code> <p>Perform SNMP bulkget on the device with given arguments.</p> <code>snmpget</code> <p>Perform an snmpget with given arguments.</p> <code>snmpset</code> <p>Perform an snmpset with given arguments.</p> <code>snmpwalk</code> <p>Perform an snmpwalk with given arguments.</p> Source code in <code>boardfarm3/lib/SNMPv2.py</code> <pre><code>def __init__(\n    self,\n    device: WAN,\n    target_ip: str,\n    mibs_compiler: MibsCompiler,\n) -&gt; None:\n    \"\"\"Initialize SNMPv2.\n\n    :param device: device instance\n    :type device: WAN\n    :param target_ip: target ip address\n    :type target_ip: str\n    :param mibs_compiler: mibs compiler instance\n    :type mibs_compiler: MibsCompiler\n    \"\"\"\n    self._device = device\n    self._target_ip = target_ip\n    self._mibs_compiler = mibs_compiler\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2(device)","title":"<code>device</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2(target_ip)","title":"<code>target_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2(mibs_compiler)","title":"<code>mibs_compiler</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget","title":"snmpbulkget","text":"<pre><code>snmpbulkget(\n    mib_name: str,\n    index: int | None = None,\n    community: str = \"private\",\n    non_repeaters: int = 0,\n    max_repetitions: int = 10,\n    retries: int = 3,\n    timeout: int = 100,\n    extra_args: str = \"\",\n    cmd_timeout: int = 30,\n) -&gt; list[tuple[str, str, str]]\n</code></pre> <p>Perform SNMP bulkget on the device with given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>mib name used to perform snmp</p> required <code>int | None</code> <p>index used along with mib_name, defaults to None</p> <code>None</code> <code>str</code> <p>SNMP Community string, defaults to \"private\"</p> <code>'private'</code> <code>int</code> <p>value treated as get request, defaults to 0</p> <code>0</code> <code>int</code> <p>value treated as get next operation, defaults to 10</p> <code>10</code> <code>int</code> <p>no.of time commands are executed on exception, defaults to 3</p> <code>3</code> <code>int</code> <p>timeout in seconds, defaults to 100</p> <code>100</code> <code>str</code> <p>extra arguments to be passed in the command, defaults to \"\"</p> <code>''</code> <code>int</code> <p>timeout to wait for command to give otuput</p> <code>30</code> <p>Returns:</p> Type Description <code>list[tuple[str, str, str]]</code> <p>output of snmpbulkget command</p> <p>Raises:</p> Type Description <code>SNMPError</code> <p>when MIB is not available</p> Source code in <code>boardfarm3/lib/SNMPv2.py</code> <pre><code>def snmpbulkget(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    mib_name: str,\n    index: int | None = None,\n    community: str = \"private\",\n    non_repeaters: int = 0,\n    max_repetitions: int = 10,\n    retries: int = 3,\n    timeout: int = 100,\n    extra_args: str = \"\",\n    cmd_timeout: int = 30,\n) -&gt; list[tuple[str, str, str]]:\n    \"\"\"Perform SNMP bulkget on the device with given arguments.\n\n    :param mib_name: mib name used to perform snmp\n    :type mib_name: str\n    :param index: index used along with mib_name, defaults to None\n    :type index: int, optional\n    :param community: SNMP Community string, defaults to \"private\"\n    :type community: str\n    :param non_repeaters: value treated as get request, defaults to 0\n    :type non_repeaters: int\n    :param max_repetitions: value treated as get next operation, defaults to 10\n    :type max_repetitions: int\n    :param retries:  no.of time commands are executed on exception, defaults to 3\n    :type retries: int\n    :param timeout: timeout in seconds, defaults to 100\n    :type timeout: int\n    :param extra_args: extra arguments to be passed in the command, defaults to \"\"\n    :type extra_args: str\n    :param cmd_timeout: timeout to wait for command to give otuput\n    :type cmd_timeout: int\n    :raises SNMPError: when MIB is not available\n    :return: output of snmpbulkget command\n    :rtype: list[tuple[str, str, str]]\n    \"\"\"\n    if mib_name:\n        try:\n            oid = self._get_mib_oid(mib_name)\n            if index:\n                oid = f\"{oid}.{index!s}\"\n        except (ValueError, SNMPError) as exception:\n            msg = f\"MIB not available, Error: {exception}\"\n            raise SNMPError(msg) from exception\n    else:\n        oid = \"\"\n    cmd = (\n        f\"snmpbulkget -v2c -On{extra_args} -Cn{non_repeaters} -Cr{max_repetitions}\"\n        f\" -c {community} -t {timeout} -r {retries} {self._target_ip} {oid}\"\n        if extra_args\n        else f\"snmpbulkget -v2c -Cn{non_repeaters} -Cr{max_repetitions}\"\n        f\" -c {community} -t {timeout} -r {retries} {self._target_ip} {oid}\"\n    )\n    return self._parse_snmpbulk_output(\n        self._device.execute_snmp_command(cmd, timeout=cmd_timeout)\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(mib_name)","title":"<code>mib_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(index)","title":"<code>index</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(community)","title":"<code>community</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(non_repeaters)","title":"<code>non_repeaters</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(max_repetitions)","title":"<code>max_repetitions</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(retries)","title":"<code>retries</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpbulkget(cmd_timeout)","title":"<code>cmd_timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget","title":"snmpget","text":"<pre><code>snmpget(\n    mib_name: str,\n    index: int = 0,\n    community: str = \"private\",\n    extra_args: str = \"\",\n    timeout: int = 10,\n    retries: int = 3,\n    cmd_timeout: int = 30,\n) -&gt; tuple[str, str, str]\n</code></pre> <p>Perform an snmpget with given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>mib name used to perform snmp</p> required <code>int</code> <p>index used along with mib_name</p> <code>0</code> <code>str</code> <p>SNMP Community string that allows access to DUT, defaults to 'private'</p> <code>'private'</code> <code>str</code> <p>Any extra arguments to be passed in the command</p> <code>''</code> <code>int</code> <p>timeout in seconds</p> <code>10</code> <code>int</code> <p>the no. of time the commands are executed on exception/timeout</p> <code>3</code> <code>int</code> <p>timeout to wait for command to give otuput</p> <code>30</code> <p>Returns:</p> Type Description <code>Tuple[str, str, str]</code> <p>value, value type and complete output</p> Source code in <code>boardfarm3/lib/SNMPv2.py</code> <pre><code>def snmpget(  # noqa: PLR0913 # pylint: disable=too-many-arguments\n    self,\n    mib_name: str,\n    index: int = 0,\n    community: str = \"private\",\n    extra_args: str = \"\",\n    timeout: int = 10,\n    retries: int = 3,\n    cmd_timeout: int = 30,\n) -&gt; tuple[str, str, str]:\n    \"\"\"Perform an snmpget with given arguments.\n\n    :param mib_name: mib name used to perform snmp\n    :type mib_name: str\n    :param index: index used along with mib_name\n    :type index: int\n    :param community: SNMP Community string that allows access to DUT,\n                        defaults to 'private'\n    :type community: str\n    :param extra_args: Any extra arguments to be passed in the command\n    :type extra_args: str\n    :param timeout: timeout in seconds\n    :type timeout: int\n    :param retries: the no. of time the commands are executed on exception/timeout\n    :type retries: int\n    :param cmd_timeout: timeout to wait for command to give otuput\n    :type cmd_timeout: int\n    :return: value, value type and complete output\n    :rtype: Tuple[str, str, str]\n    \"\"\"\n    oid = self._get_mib_oid(mib_name) + f\".{index!s}\"\n    output = self._run_snmp_command(\n        \"snmpget\",\n        community,\n        oid,\n        timeout,\n        retries,\n        extra_args=extra_args,\n        cmd_timeout=cmd_timeout,\n    )\n    return self._parse_snmp_output(oid, output)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget(mib_name)","title":"<code>mib_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget(index)","title":"<code>index</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget(community)","title":"<code>community</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget(retries)","title":"<code>retries</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpget(cmd_timeout)","title":"<code>cmd_timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset","title":"snmpset","text":"<pre><code>snmpset(\n    mib_name: str,\n    value: str,\n    stype: str,\n    index: int = 0,\n    community: str = \"private\",\n    extra_args: str = \"\",\n    timeout: int = 10,\n    retries: int = 3,\n    cmd_timeout: int = 30,\n) -&gt; tuple[str, str, str]\n</code></pre> <p>Perform an snmpset with given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>mib name used to perform snmp</p> required <code>str</code> <p>value to be set for the mib name</p> required <code>str</code> <p>defines the datatype of value to be set for mib_name stype: one of i, u, t, a, o, s, x, d, b i: INTEGER, u: unsigned INTEGER, t: TIMETICKS, a: IPADDRESS o: OBJID, s: STRING, x: HEX STRING, d: DECIMAL STRING, b: BITS U: unsigned int64, I: signed int64, F: float, D: double</p> required <code>int</code> <p>index used along with mib_name</p> <code>0</code> <code>str</code> <p>SNMP Community string that allows access to DUT, defaults to 'private'</p> <code>'private'</code> <code>str</code> <p>Any extra arguments to be passed in the command</p> <code>''</code> <code>int</code> <p>timeout in seconds</p> <code>10</code> <code>int</code> <p>the no. of time the commands are executed on exception/timeout</p> <code>3</code> <code>int</code> <p>timeout to wait for command to give otuput</p> <code>30</code> <p>Returns:</p> Type Description <code>Tuple[str, str, str]</code> <p>value, value type and complete output</p> Source code in <code>boardfarm3/lib/SNMPv2.py</code> <pre><code>def snmpset(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    mib_name: str,\n    value: str,\n    stype: str,\n    index: int = 0,\n    community: str = \"private\",\n    extra_args: str = \"\",\n    timeout: int = 10,\n    retries: int = 3,\n    cmd_timeout: int = 30,\n) -&gt; tuple[str, str, str]:\n    \"\"\"Perform an snmpset with given arguments.\n\n    :param mib_name: mib name used to perform snmp\n    :type mib_name: str\n    :param value: value to be set for the mib name\n    :type value: str\n    :param stype: defines the datatype of value to be set for mib_name\n                    stype: one of i, u, t, a, o, s, x, d, b\n                    i: INTEGER, u: unsigned INTEGER, t: TIMETICKS, a: IPADDRESS\n                    o: OBJID, s: STRING, x: HEX STRING, d: DECIMAL STRING, b: BITS\n                    U: unsigned int64, I: signed int64, F: float, D: double\n    :type stype: str\n    :param index: index used along with mib_name\n    :type index: int\n    :param community: SNMP Community string that allows access to DUT,\n                    defaults to 'private'\n    :type community: str\n    :param extra_args: Any extra arguments to be passed in the command\n    :type extra_args: str\n    :param timeout: timeout in seconds\n    :type timeout: int\n    :param retries: the no. of time the commands are executed on exception/timeout\n    :type retries: int\n    :param cmd_timeout: timeout to wait for command to give otuput\n    :type cmd_timeout: int\n    :return: value, value type and complete output\n    :rtype: Tuple[str, str, str]\n    \"\"\"\n    oid = self._get_mib_oid(mib_name) + f\".{index!s}\"\n    if re.findall(r\"\\s\", value.strip()) and stype == \"s\":\n        value = f\"{value!r}\"\n    if str(value).lower().startswith(\"0x\"):\n        set_value = f\"{stype} '{value[2:].upper()}'\"\n    else:\n        set_value = f\"{stype} '{value}'\"\n    output = self._run_snmp_command(\n        \"snmpset\",\n        community,\n        oid,\n        timeout,\n        retries,\n        set_value=set_value,\n        extra_args=extra_args,\n        cmd_timeout=cmd_timeout,\n    )\n    return self._parse_snmp_output(oid, output, value)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(mib_name)","title":"<code>mib_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(value)","title":"<code>value</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(stype)","title":"<code>stype</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(index)","title":"<code>index</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(community)","title":"<code>community</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(retries)","title":"<code>retries</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpset(cmd_timeout)","title":"<code>cmd_timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk","title":"snmpwalk","text":"<pre><code>snmpwalk(\n    mib_name: str,\n    index: int | None = None,\n    community: str = \"private\",\n    retries: int = 3,\n    timeout: int = 100,\n    extra_args: str = \"\",\n    cmd_timeout: int = 30,\n) -&gt; tuple[dict[str, list[str]], str]\n</code></pre> <p>Perform an snmpwalk with given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>mib name used to perform snmp</p> required <code>int | None</code> <p>index used along with mib_name</p> <code>None</code> <code>str</code> <p>SNMP Community string that allows access to DUT, defaults to 'private'</p> <code>'private'</code> <code>int</code> <p>the no. of time the commands are executed on exception/timeout</p> <code>3</code> <code>int</code> <p>timeout in seconds</p> <code>100</code> <code>str</code> <p>Any extra arguments to be passed in the command</p> <code>''</code> <code>int</code> <p>timeout to wait for command to give otuput</p> <code>30</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, List[str]], str]</code> <p>dictionary of mib_oid as key and list(value, type) as value and complete output</p> <p>Raises:</p> Type Description <code>SNMPError</code> <p>no matching output</p> Source code in <code>boardfarm3/lib/SNMPv2.py</code> <pre><code>def snmpwalk(  # noqa: PLR0913 # pylint: disable=too-many-arguments\n    self,\n    mib_name: str,\n    index: int | None = None,\n    community: str = \"private\",\n    retries: int = 3,\n    timeout: int = 100,\n    extra_args: str = \"\",\n    cmd_timeout: int = 30,\n) -&gt; tuple[dict[str, list[str]], str]:\n    \"\"\"Perform an snmpwalk with given arguments.\n\n    :param mib_name: mib name used to perform snmp\n    :type mib_name: str\n    :param index: index used along with mib_name\n    :type index: int\n    :param community: SNMP Community string that allows access to DUT,\n                        defaults to 'private'\n    :type community: str\n    :param retries: the no. of time the commands are executed on exception/timeout\n    :type retries: int\n    :param timeout: timeout in seconds\n    :type timeout: int\n    :param extra_args: Any extra arguments to be passed in the command\n    :type extra_args: str\n    :param cmd_timeout: timeout to wait for command to give otuput\n    :type cmd_timeout: int\n    :return: dictionary of mib_oid as key and list(value, type) as value\n                        and complete output\n    :rtype: Tuple[Dict[str, List[str]], str]\n    :raises SNMPError: no matching output\n    \"\"\"\n    if mib_name:\n        try:\n            oid = self._get_mib_oid(mib_name)\n            if index:\n                oid = oid + f\".{index!s}\"\n        except (ValueError, SNMPError) as exception:\n            msg = f\"MIB not available, Error: {exception}\"\n            raise SNMPError(msg) from exception\n    else:\n        oid = \"\"\n    output = self._run_snmp_command(\n        \"snmpwalk\",\n        community,\n        oid,\n        timeout,\n        retries,\n        extra_args=extra_args,\n        cmd_timeout=cmd_timeout,\n    )\n    return self._parse_snmpwalk_output(oid, output)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk(mib_name)","title":"<code>mib_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk(index)","title":"<code>index</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk(community)","title":"<code>community</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk(retries)","title":"<code>retries</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.SNMPv2.SNMPv2.snmpwalk(cmd_timeout)","title":"<code>cmd_timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config","title":"boardfarm_config","text":"<p>Boardfarm environment config module.</p> <p>Classes:</p> Name Description <code>BoardfarmConfig</code> <p>Boardfarm environment config.</p> <p>Functions:</p> Name Description <code>get_inventory_config</code> <p>Return inventory config based on given arguments.</p> <code>get_json</code> <p>Get the inventory json either from a URL or a system path.</p> <code>parse_boardfarm_config</code> <p>Get environment config from given json files.</p>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig","title":"BoardfarmConfig","text":"<pre><code>BoardfarmConfig(\n    merged_config: list[dict],\n    env_config: dict[str, Any],\n    inventory_config: dict[str, Any],\n)\n</code></pre> <p>Boardfarm environment config.</p> <p>Initialize boardfarm config.</p> <p>Parameters:</p> Name Type Description Default <code>list[dict]</code> <p>merged devices config</p> required <code>dict[str, Any]</code> <p>environment configuration</p> required <code>dict[str, Any]</code> <p>inventory configuration</p> required <p>Methods:</p> Name Description <code>get_board_model</code> <p>Return the env config [\"environment_def\"][\"board\"][\"model\"].</p> <code>get_board_sku</code> <p>Return the env config [\"environment_def\"][\"board\"][\"SKU\"] value.</p> <code>get_board_station_number</code> <p>Get station number of the board.</p> <code>get_device_config</code> <p>Get device merged config.</p> <code>get_devices_config</code> <p>Get merged devices config.</p> <code>get_prov_mode</code> <p>Return the provisioning mode of the DUT.</p> <p>Attributes:</p> Name Type Description <code>env_config</code> <code>dict[str, Any]</code> <p>Environment config dictionary.</p> <code>inventory_config</code> <code>dict[str, Any]</code> <p>Inventory config dictionary.</p> <code>resource_name</code> <code>str</code> <p>Resource name.</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def __init__(\n    self,\n    merged_config: list[dict],\n    env_config: dict[str, Any],\n    inventory_config: dict[str, Any],\n):\n    \"\"\"Initialize boardfarm config.\n\n    :param merged_config: merged devices config\n    :param env_config: environment configuration\n    :param inventory_config: inventory configuration\n    \"\"\"\n    self._env_config = env_config\n    self._inventory_config = inventory_config\n    self._merged_devices_config = merged_config\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig(merged_config)","title":"<code>merged_config</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig(env_config)","title":"<code>env_config</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig(inventory_config)","title":"<code>inventory_config</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.env_config","title":"env_config  <code>property</code>","text":"<pre><code>env_config: dict[str, Any]\n</code></pre> <p>Environment config dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>env config response</p>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.inventory_config","title":"inventory_config  <code>property</code>","text":"<pre><code>inventory_config: dict[str, Any]\n</code></pre> <p>Inventory config dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>inventory config response</p>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.resource_name","title":"resource_name  <code>cached</code> <code>property</code>","text":"<pre><code>resource_name: str\n</code></pre> <p>Resource name.</p> <p>Returns:</p> Type Description <code>str</code> <p>resource name of the board</p>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.get_board_model","title":"get_board_model","text":"<pre><code>get_board_model() -&gt; str\n</code></pre> <p>Return the env config [\"environment_def\"][\"board\"][\"model\"].</p> <p>Returns:</p> Type Description <code>str</code> <p>Board model</p> <p>Raises:</p> Type Description <code>EnvConfigError</code> <p>when given model is unknown</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_board_model(self) -&gt; str:\n    \"\"\"Return the env config [\"environment_def\"][\"board\"][\"model\"].\n\n    :return: Board model\n    :raises EnvConfigError: when given model is unknown\n    \"\"\"\n    try:\n        return self.env_config[\"environment_def\"][\"board\"][\"model\"]\n    except (KeyError, AttributeError) as e:\n        msg = \"Unable to find board.model entry in env config.\"\n        raise EnvConfigError(\n            msg,\n        ) from e\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.get_board_sku","title":"get_board_sku","text":"<pre><code>get_board_sku() -&gt; str\n</code></pre> <p>Return the env config [\"environment_def\"][\"board\"][\"SKU\"] value.</p> <p>Returns:</p> Type Description <code>str</code> <p>SKU value</p> <p>Raises:</p> Type Description <code>EnvConfigError</code> <p>when given sku is unknown</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_board_sku(self) -&gt; str:\n    \"\"\"Return the env config [\"environment_def\"][\"board\"][\"SKU\"] value.\n\n    :return: SKU value\n    :raises EnvConfigError: when given sku is unknown\n    \"\"\"\n    try:\n        return self.env_config[\"environment_def\"][\"board\"][\"SKU\"]\n    except (KeyError, AttributeError) as e:\n        msg = \"Board SKU is not found in env config.\"\n        raise EnvConfigError(msg) from e\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.get_board_station_number","title":"get_board_station_number","text":"<pre><code>get_board_station_number() -&gt; int\n</code></pre> <p>Get station number of the board.</p> <p>Returns:</p> Type Description <code>int</code> <p>station number</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_board_station_number(self) -&gt; int:\n    \"\"\"Get station number of the board.\n\n    :returns: station number\n    \"\"\"\n    return int(self.resource_name.split(\"-\")[-1])\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.get_device_config","title":"get_device_config","text":"<pre><code>get_device_config(device_name: str) -&gt; dict[str, Any]\n</code></pre> <p>Get device merged config.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>device name</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>merged device config</p> <p>Raises:</p> Type Description <code>EnvConfigError</code> <p>when given device name is unknown</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_device_config(self, device_name: str) -&gt; dict[str, Any]:\n    \"\"\"Get device merged config.\n\n    :param device_name: device name\n    :returns: merged device config\n    :raises EnvConfigError: when given device name is unknown\n    \"\"\"\n    for device_config in self._merged_devices_config:\n        if device_config.get(\"name\") == device_name:\n            return device_config\n    msg = f\"{device_name} - Unknown device name\"\n    raise EnvConfigError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.get_device_config(device_name)","title":"<code>device_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.get_devices_config","title":"get_devices_config","text":"<pre><code>get_devices_config() -&gt; list[dict]\n</code></pre> <p>Get merged devices config.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>merged devices config</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_devices_config(self) -&gt; list[dict]:\n    \"\"\"Get merged devices config.\n\n    :returns: merged devices config\n    \"\"\"\n    return self._merged_devices_config\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.BoardfarmConfig.get_prov_mode","title":"get_prov_mode","text":"<pre><code>get_prov_mode() -&gt; str\n</code></pre> <p>Return the provisioning mode of the DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>ipv4, ipv6, dslite, dualstack, disabled</p> <p>Raises:</p> Type Description <code>EnvConfigError</code> <p>when given sku is unknown</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_prov_mode(self) -&gt; str:\n    \"\"\"Return the provisioning mode of the DUT.\n\n    :return: ipv4, ipv6, dslite, dualstack, disabled\n    :raises EnvConfigError: when given sku is unknown\n    \"\"\"\n    try:\n        return self.env_config[\"environment_def\"][\"board\"][\n            \"eRouter_Provisioning_mode\"\n        ]\n    except (KeyError, AttributeError) as e:\n        msg = \"Unable to find eRouter_Provisioning_mode entry in env config.\"\n        raise EnvConfigError(\n            msg,\n        ) from e\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.get_inventory_config","title":"get_inventory_config","text":"<pre><code>get_inventory_config(resource_name: str, inventory_json_path: str) -&gt; dict[str, Any]\n</code></pre> <p>Return inventory config based on given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>inventory resource name</p> required <code>str</code> <p>inventory json config path</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>inventory configuration</p> <p>Raises:</p> Type Description <code>EnvConfigError</code> <p>on resource name not found in inventory config</p> <code>EnvConfigError</code> <p>on invalid location config</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_inventory_config(\n    resource_name: str,\n    inventory_json_path: str,\n) -&gt; dict[str, Any]:\n    \"\"\"Return inventory config based on given arguments.\n\n    :param resource_name: inventory resource name\n    :type resource_name: str\n    :param inventory_json_path: inventory json config path\n    :type inventory_json_path: str\n    :raises EnvConfigError: on resource name not found in inventory config\n    :raises EnvConfigError: on invalid location config\n    :return: inventory configuration\n    :rtype: dict[str, Any]\n    \"\"\"\n    full_inventory_config = get_json(inventory_json_path)\n    if resource_name not in full_inventory_config:\n        msg = f\"{resource_name!r} resource not found in inventory config\"\n        raise EnvConfigError(\n            msg,\n        )\n    inventory_config = full_inventory_config.get(resource_name)\n    if \"location\" in inventory_config:\n        if locations := full_inventory_config.get(\n            \"locations\",\n            {},\n        ):  # optional, lab dependent\n            inventory_config[\"devices\"] += locations[\n                inventory_config.pop(\"location\")\n            ].get(\"devices\", [])\n        else:\n            msg = f\"{inventory_config['location']!r} invalid location config\"\n            raise EnvConfigError(msg)\n    for device in inventory_config.get(\"devices\", []):\n        if device[\"name\"] == \"board\":\n            device[\"resource_name\"] = resource_name\n            break\n    return inventory_config\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.get_inventory_config(resource_name)","title":"<code>resource_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.get_inventory_config(inventory_json_path)","title":"<code>inventory_json_path</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.get_json","title":"get_json","text":"<pre><code>get_json(resource_name: str) -&gt; dict[str, Any]\n</code></pre> <p>Get the inventory json either from a URL or a system path.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>inventory resource name</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>the inventory json from the specified path</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def get_json(resource_name: str) -&gt; dict[str, Any]:\n    \"\"\"Get the inventory json either from a URL or a system path.\n\n    :param resource_name: inventory resource name\n    :type resource_name: str\n    :return: the inventory json from the specified path\n    :rtype: dict[str, Any]\n    \"\"\"\n    if resource_name.startswith((\"http://\", \"https://\")):\n        json_dict = requests.get(resource_name, timeout=30).text\n    else:\n        json_dict = Path(resource_name).read_text(encoding=\"utf-8\")\n    return cast(\"dict[str, Any]\", json.loads(json_dict))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.get_json(resource_name)","title":"<code>resource_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.parse_boardfarm_config","title":"parse_boardfarm_config","text":"<pre><code>parse_boardfarm_config(\n    inventory_config: dict[str, Any], env_json_config: dict[str, Any]\n) -&gt; BoardfarmConfig\n</code></pre> <p>Get environment config from given json files.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, Any]</code> <p>inventory config</p> required <code>dict[str, Any]</code> <p>environment config</p> required <p>Returns:</p> Type Description <code>BoardfarmConfig</code> <p>boardfarm config instance</p> Source code in <code>boardfarm3/lib/boardfarm_config.py</code> <pre><code>def parse_boardfarm_config(\n    inventory_config: dict[str, Any],\n    env_json_config: dict[str, Any],\n) -&gt; BoardfarmConfig:\n    \"\"\"Get environment config from given json files.\n\n    :param inventory_config: inventory config\n    :type inventory_config: dict[str, Any]\n    :param env_json_config: environment config\n    :type env_json_config: dict[str, Any]\n    :return: boardfarm config instance\n    :rtype: BoardfarmConfig\n    \"\"\"\n    # disable jsonmerge debug logs\n    logging.getLogger(\"jsonmerge\").setLevel(logging.WARNING)\n    wifi_devices = [\n        device\n        for device in inventory_config[\"devices\"]\n        if device[\"type\"] in [\"bf_wlan\", \"debian_wifi\"]\n    ]\n    lan_devices = [\n        device\n        for device in inventory_config[\"devices\"]\n        if device[\"type\"] in [\"bf_lan\", \"debian_lan\"]\n    ]\n    other_devices = [\n        device\n        for device in inventory_config[\"devices\"]\n        if device not in wifi_devices + lan_devices\n    ]\n    merged_devices_config = []\n    environment_def = env_json_config.get(\"environment_def\")\n    for device in other_devices:\n        device_name = device.get(\"name\")\n        merged_devices_config.append(\n            (\n                jsonmerge.merge(device, environment_def[device_name])\n                if device_name in environment_def\n                else device\n            ),\n        )\n    merged_devices_config += _merge_with_lan_config(lan_devices, env_json_config)\n    merged_devices_config += _merge_with_wifi_config(wifi_devices, env_json_config)\n    return BoardfarmConfig(merged_devices_config, env_json_config, inventory_config)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.parse_boardfarm_config(inventory_config)","title":"<code>inventory_config</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_config.parse_boardfarm_config(env_json_config)","title":"<code>env_json_config</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect","title":"boardfarm_pexpect","text":"<p>Boardfarm pexpect session module.</p> <p>Classes:</p> Name Description <code>BoardfarmPexpect</code> <p>Boardfarm pexpect session.</p>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect","title":"BoardfarmPexpect","text":"<pre><code>BoardfarmPexpect(\n    session_name: str,\n    command: str,\n    save_console_logs: str,\n    args: list[str],\n    **kwargs: dict[str, Any],\n)\n</code></pre> <p>Boardfarm pexpect session.</p> <p>Initialize boardfarm pexpect.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>pexpect session name</p> required <code>str</code> <p>command to start pexpect session</p> required <code>str</code> <p>save console logs to the disk</p> required <code>list[str]</code> <p>additional arguments to the command</p> required <code>dict[str, Any]</code> <p>may contains the 'env' for pexpect, optional</p> <code>{}</code> <p>Methods:</p> Name Description <code>execute_command</code> <p>Execute a command in the pexpect session.</p> <code>get_last_output</code> <p>Get last output from the buffer.</p> <code>start_interactive_session</code> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def __init__(\n    self,\n    session_name: str,\n    command: str,\n    save_console_logs: str,\n    args: list[str],\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Initialize boardfarm pexpect.\n\n    :param session_name: pexpect session name\n    :type session_name: str\n    :param command: command to start pexpect session\n    :type command: str\n    :param save_console_logs: save console logs to the disk\n    :type save_console_logs: str\n    :param args: additional arguments to the command\n    :type args: list[str]\n    :param kwargs: may contains the 'env' for pexpect, optional\n    :type kwargs: dict[str, Any]\n    \"\"\"\n    kwargs.setdefault(\"env\", {\"PATH\": os.getenv(\"PATH\"), \"TERM\": \"dumb\"})\n    super().__init__(\n        command=command,\n        args=list(args),\n        encoding=\"utf-8\",\n        dimensions=(24, 240),\n        codec_errors=\"ignore\",\n        env=kwargs.get(\"env\"),\n    )\n    self._configure_logging(session_name, save_console_logs)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect(session_name)","title":"<code>session_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect(save_console_logs)","title":"<code>save_console_logs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect.execute_command","title":"execute_command  <code>abstractmethod</code>","text":"<pre><code>execute_command(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the pexpect session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. Defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>output of given command execution</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>@abstractmethod\ndef execute_command(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the pexpect session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. Defaults to -1\n    :returns: output of given command execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect.execute_command(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect.execute_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect.get_last_output","title":"get_last_output","text":"<pre><code>get_last_output() -&gt; str\n</code></pre> <p>Get last output from the buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>last output from the buffer</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def get_last_output(self) -&gt; str:\n    \"\"\"Get last output from the buffer.\n\n    :returns: last output from the buffer\n    \"\"\"\n    return self.before.strip()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.boardfarm_pexpect.BoardfarmPexpect.start_interactive_session","title":"start_interactive_session","text":"<pre><code>start_interactive_session() -&gt; None\n</code></pre> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def start_interactive_session(self) -&gt; None:\n    \"\"\"Start interactive pexpect session.\"\"\"\n    with disable_logs(\"pexpect\"):\n        self.interact()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connection_factory","title":"connection_factory","text":"<p>Connection decider module.</p> <p>Functions:</p> Name Description <code>connection_factory</code> <p>Return connection of given type.</p>"},{"location":"reference/libs/#boardfarm3.lib.connection_factory.connection_factory","title":"connection_factory","text":"<pre><code>connection_factory(\n    connection_type: str, connection_name: str, **kwargs: Any\n) -&gt; BoardfarmPexpect\n</code></pre> <p>Return connection of given type.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>type of the connection</p> required <code>str</code> <p>name of the connection</p> required <code>Any</code> <p>arguments to the connection</p> <code>{}</code> <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>BoardfarmPexpect: connection of given type</p> <p>Raises:</p> Type Description <code>EnvConfigError</code> <p>when given connection type is not supported</p> Source code in <code>boardfarm3/lib/connection_factory.py</code> <pre><code>def connection_factory(\n    connection_type: str,\n    connection_name: str,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; BoardfarmPexpect:\n    \"\"\"Return connection of given type.\n\n    :param connection_type: type of the connection\n    :param connection_name: name of the connection\n    :param kwargs: arguments to the connection\n    :returns: BoardfarmPexpect: connection of given type\n    :raises EnvConfigError: when given connection type is not supported\n    \"\"\"\n    connection_dispatcher = {\n        \"ssh_connection\": SSHConnection,\n        \"authenticated_ssh\": SSHConnection,\n        \"ldap_authenticated_serial\": LdapAuthenticatedSerial,\n        \"local_cmd\": LocalCmd,\n        \"serial\": SerialConnection,\n        \"ser2net\": _ser2net_param_parser,\n        \"telnet\": _telnet_param_parser,\n    }\n    connection_obj = connection_dispatcher.get(connection_type)\n    if connection_obj is not None and callable(connection_obj):\n        if connection_type == \"ssh_connection\":\n            kwargs.pop(\"password\")\n        return connection_obj(connection_name, **kwargs)\n    # Handle unsupported connection types\n    msg = f\"Unsupported connection type: {connection_type}\"\n    raise EnvConfigError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connection_factory.connection_factory(connection_type)","title":"<code>connection_type</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connection_factory.connection_factory(connection_name)","title":"<code>connection_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connection_factory.connection_factory(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections","title":"connections","text":"<p>Boardfarm connections package.</p> <p>Modules:</p> Name Description <code>connect_and_run</code> <p>Connect and run module.</p> <code>ldap_authenticated_serial</code> <p>SSH connection module.</p> <code>local_cmd</code> <p>Connect to a device with a local command.</p> <code>ser2net_connection</code> <p>ser2net connection module.</p> <code>serial_connection</code> <p>Connect to a device with a local serial command.</p> <code>ssh_connection</code> <p>SSH connection module.</p> <code>telnet</code> <p>Telnet connection module.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.connect_and_run","title":"connect_and_run","text":"<p>Connect and run module.</p> <p>Classes:</p> Name Description <code>RuntimeConnectable</code> <p>Runtine connectable protocol class.</p> <p>Functions:</p> Name Description <code>connect_and_run</code> <p>Connect run and disconnect to console at runtime.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.connect_and_run.RuntimeConnectable","title":"RuntimeConnectable","text":"<p>Runtine connectable protocol class.</p> <p>Methods:</p> Name Description <code>connect_console</code> <p>Connect to the console.</p> <code>disconnect_console</code> <p>Disconnect from the console.</p> <code>is_console_connected</code> <p>Get status of the connection.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.connect_and_run.RuntimeConnectable.connect_console","title":"connect_console","text":"<pre><code>connect_console() -&gt; None\n</code></pre> <p>Connect to the console.</p> Source code in <code>boardfarm3/lib/connections/connect_and_run.py</code> <pre><code>def connect_console(self) -&gt; None:\n    \"\"\"Connect to the console.\"\"\"\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.connect_and_run.RuntimeConnectable.disconnect_console","title":"disconnect_console","text":"<pre><code>disconnect_console() -&gt; None\n</code></pre> <p>Disconnect from the console.</p> Source code in <code>boardfarm3/lib/connections/connect_and_run.py</code> <pre><code>def disconnect_console(self) -&gt; None:\n    \"\"\"Disconnect from the console.\"\"\"\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.connect_and_run.RuntimeConnectable.is_console_connected","title":"is_console_connected","text":"<pre><code>is_console_connected() -&gt; bool\n</code></pre> <p>Get status of the connection.</p> Source code in <code>boardfarm3/lib/connections/connect_and_run.py</code> <pre><code>def is_console_connected(self) -&gt; bool:\n    \"\"\"Get status of the connection.\"\"\"\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.connect_and_run.connect_and_run","title":"connect_and_run","text":"<pre><code>connect_and_run(func: Callable[P, T]) -&gt; Callable[P, T]\n</code></pre> <p>Connect run and disconnect to console at runtime.</p> <p>Note: This is implemented only for instance methods</p> <p>Parameters:</p> Name Type Description Default <code>Callable[P, T]</code> <p>the decorated method</p> required <p>Returns:</p> Type Description <code>Callable[P, T]</code> <p>True or False</p> Source code in <code>boardfarm3/lib/connections/connect_and_run.py</code> <pre><code>def connect_and_run(func: Callable[P, T]) -&gt; Callable[P, T]:\n    \"\"\"Connect run and disconnect to console at runtime.\n\n    Note: This is implemented only for instance methods\n\n    :param func: the decorated method\n    :return: True or False\n    :rtype: Callable[P, T]\n    \"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; T:\n        instance = args[0]\n        exc_to_raise = None\n        conn_exception = None\n        if not isinstance(instance, RuntimeConnectable):\n            msg = (\n                f\"Provided instance {instance} do not ,\"\n                f\"follows the protocol RuntimeConnectable .i.e {RuntimeConnectable}\"\n            )\n            raise TypeError(msg)\n\n        if not instance.is_console_connected():\n            # Adding a retry\n            for _ in range(10):\n                try:\n                    instance.connect_console()\n                    break\n                except DeviceConnectionError as exc:\n                    conn_exception = exc\n                    sleep(15)\n            else:\n                raise conn_exception\n\n        try:\n            output = func(*args, **kwargs)\n        except Exception as e:  # noqa: BLE001 pylint: disable=W0718\n            exc_to_raise = e\n        finally:\n            if instance.is_console_connected():\n                instance.disconnect_console()\n        if exc_to_raise:\n            raise exc_to_raise\n        return output\n\n    return wrapper\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.connect_and_run.connect_and_run(func)","title":"<code>func</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial","title":"ldap_authenticated_serial","text":"<p>SSH connection module.</p> <p>Classes:</p> Name Description <code>LdapAuthenticatedSerial</code> <p>Connect to a serial with ldap credentials.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial","title":"LdapAuthenticatedSerial","text":"<pre><code>LdapAuthenticatedSerial(\n    name: str,\n    ip_addr: str,\n    ldap_credentials: str,\n    shell_prompt: list[str],\n    port: int = 22,\n    save_console_logs: str = \"\",\n    **kwargs: dict[str, Any],\n)\n</code></pre> <p>Connect to a serial with ldap credentials.</p> <p>Initialize ldap authenticated serial connection.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>connection name</p> required <code>str</code> <p>server ip address</p> required <code>str</code> <p>ldap credentials</p> required <code>list[str]</code> <p>shell prompt patterns</p> required <code>int</code> <p>port number, defaults to 22</p> <code>22</code> <code>str</code> <p>save console logs to disk, defaults to \"\"</p> <code>''</code> <code>dict[str, Any]</code> <p>other keyword arguments</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>invalid LDAP credentials</p> <p>Methods:</p> Name Description <code>check_output</code> <p>Return an output of the command.</p> <code>execute_command</code> <p>Execute a command in the SSH session.</p> <code>execute_command_async</code> <p>Execute a command in the SSH session.</p> <code>get_last_output</code> <p>Get last output from the buffer.</p> <code>login_to_server</code> <p>Login to serial server.</p> <code>login_to_server_async</code> <p>Login to serial server.</p> <code>start_interactive_session</code> <p>Start interactive pexpect session.</p> <code>sudo_sendline</code> <p>Add sudo in the sendline if username is root.</p> Source code in <code>boardfarm3/lib/connections/ldap_authenticated_serial.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    name: str,\n    ip_addr: str,\n    ldap_credentials: str,\n    shell_prompt: list[str],\n    port: int = 22,\n    save_console_logs: str = \"\",\n    **kwargs: dict[str, Any],  # ignore other arguments  # noqa: ARG002\n) -&gt; None:\n    \"\"\"Initialize ldap authenticated serial connection.\n\n    :param name: connection name\n    :type name: str\n    :param ip_addr: server ip address\n    :type ip_addr: str\n    :param ldap_credentials: ldap credentials\n    :type ldap_credentials: str\n    :param shell_prompt: shell prompt patterns\n    :type shell_prompt: list[str]\n    :param port: port number, defaults to 22\n    :type port: int\n    :param save_console_logs: save console logs to disk, defaults to \"\"\n    :type save_console_logs: str\n    :param kwargs: other keyword arguments\n    :raises ValueError: invalid LDAP credentials\n    \"\"\"\n    if \";\" not in ldap_credentials:\n        msg = \"Invalid LDAP credentials\"\n        raise ValueError(msg)\n    username, password = ldap_credentials.split(\";\")\n    super().__init__(\n        name,\n        ip_addr,\n        username,\n        shell_prompt,\n        port,\n        password,\n        save_console_logs,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial(name)","title":"<code>name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial(ip_addr)","title":"<code>ip_addr</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial(ldap_credentials)","title":"<code>ldap_credentials</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial(shell_prompt)","title":"<code>shell_prompt</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial(save_console_logs)","title":"<code>save_console_logs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.check_output","title":"check_output","text":"<pre><code>check_output(cmd: str, timeout: int = 30) -&gt; str\n</code></pre> <p>Return an output of the command.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout for command execute, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>if command doesn't execute in specified timeout</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def check_output(self, cmd: str, timeout: int = 30) -&gt; str:\n    \"\"\"Return an output of the command.\n\n    :param cmd: command to execute\n    :param timeout: timeout for command execute, defaults to 30\n    :raises BoardfarmException: if command doesn't execute in specified timeout\n    :return: command output\n    \"\"\"\n    self.sendline(\"\\n\" + cmd)\n    self.expect_exact(cmd, timeout=timeout)\n    try:\n        self.expect(self._shell_prompt, timeout=timeout)\n    except Exception as e:\n        self.sendcontrol(\"c\")\n        msg = (\n            f\"Command did not complete within {timeout} seconds. \"\n            f\"{self.name} prompt was not seen.\"\n        )\n        raise BoardfarmException(\n            msg,\n        ) from e\n    return str(self.before.strip())\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.check_output(cmd)","title":"<code>cmd</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.check_output(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.execute_command","title":"execute_command","text":"<pre><code>execute_command(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the SSH session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def execute_command(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the SSH session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    self.expect_exact(command)\n    self.expect(self.linesep)\n    self.expect(self._shell_prompt, timeout=timeout)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.execute_command(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.execute_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.execute_command_async","title":"execute_command_async  <code>async</code>","text":"<pre><code>execute_command_async(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the SSH session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>async def execute_command_async(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the SSH session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    await self.expect_exact(command, async_=True)\n    await self.expect(self.linesep, async_=True)\n    await self.expect(self._shell_prompt, timeout=timeout, async_=True)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.execute_command_async(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.execute_command_async(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.get_last_output","title":"get_last_output","text":"<pre><code>get_last_output() -&gt; str\n</code></pre> <p>Get last output from the buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>last output from the buffer</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def get_last_output(self) -&gt; str:\n    \"\"\"Get last output from the buffer.\n\n    :returns: last output from the buffer\n    \"\"\"\n    return self.before.strip()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.login_to_server","title":"login_to_server","text":"<pre><code>login_to_server(password: str | None = None) -&gt; None\n</code></pre> <p>Login to serial server.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>LDAP password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>failed to connect to device via serial</p> Source code in <code>boardfarm3/lib/connections/ldap_authenticated_serial.py</code> <pre><code>def login_to_server(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to serial server.\n\n    :param password: LDAP password\n    :type password: str\n    :raises DeviceConnectionError: failed to connect to device via serial\n    \"\"\"\n    if password is None:\n        password = self._password\n    if self.expect([\"Password:\", pexpect.EOF, pexpect.TIMEOUT]):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n    self.sendline(password)\n\n    if (\n        self.expect_exact(\n            [\"OpenGear Serial Server\", pexpect.TIMEOUT, pexpect.EOF],\n            timeout=10,\n        )\n        == _EOF_INDEX\n    ):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n    # In case of SSH communication over different geological WAN:\n    # The SSH channel does not start to display data post connection.\n    # Instead the user needs to enter some key to refresh. e.g. ENTER\n    # This is generally due to poor connection.\n    # Providing a few input below and flushing the buffer after 5 sec.\n    self.sendline()\n    self.sendline()\n    self.expect(pexpect.TIMEOUT, timeout=5)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.login_to_server(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.login_to_server_async","title":"login_to_server_async  <code>async</code>","text":"<pre><code>login_to_server_async(password: str | None = None) -&gt; None\n</code></pre> <p>Login to serial server.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>LDAP password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>failed to connect to device via serial</p> Source code in <code>boardfarm3/lib/connections/ldap_authenticated_serial.py</code> <pre><code>async def login_to_server_async(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to serial server.\n\n    :param password: LDAP password\n    :type password: str\n    :raises DeviceConnectionError: failed to connect to device via serial\n    \"\"\"\n    if password is None:\n        password = self._password\n    if await self.expect([\"Password:\", pexpect.EOF, pexpect.TIMEOUT], async_=True):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n    self.sendline(password)\n\n    if (\n        await self.expect_exact(\n            [\"OpenGear Serial Server\", pexpect.TIMEOUT, pexpect.EOF],\n            timeout=10,\n            async_=True,\n        )\n        == _EOF_INDEX\n    ):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n    # In case of SSH communication over different geological WAN:\n    # The SSH channel does not start to display data post connection.\n    # Instead the user needs to enter some key to refresh. e.g. ENTER\n    # This is generally due to poor connection.\n    # Providing a few input below and flushing the buffer after 5 sec.\n    self.sendline()\n    self.sendline()\n    await self.expect(pexpect.TIMEOUT, timeout=5, async_=True)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.login_to_server_async(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.start_interactive_session","title":"start_interactive_session","text":"<pre><code>start_interactive_session() -&gt; None\n</code></pre> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def start_interactive_session(self) -&gt; None:\n    \"\"\"Start interactive pexpect session.\"\"\"\n    with disable_logs(\"pexpect\"):\n        self.interact()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.sudo_sendline","title":"sudo_sendline","text":"<pre><code>sudo_sendline(cmd: str) -&gt; None\n</code></pre> <p>Add sudo in the sendline if username is root.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to send</p> required Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def sudo_sendline(self, cmd: str) -&gt; None:\n    \"\"\"Add sudo in the sendline if username is root.\n\n    :param cmd: command to send\n    \"\"\"\n    if self._username != \"root\":\n        self.sendline(\"sudo true\")\n        password_requested = self.expect(\n            [*self._shell_prompt, \"password for .*:\", \"Password:\"],\n        )\n        if password_requested:\n            self.sendline(self._password)\n            self.expect(self._shell_prompt)\n        cmd = \"sudo \" + cmd\n    self.sendline(cmd)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ldap_authenticated_serial.LdapAuthenticatedSerial.sudo_sendline(cmd)","title":"<code>cmd</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd","title":"local_cmd","text":"<p>Connect to a device with a local command.</p> <p>Classes:</p> Name Description <code>LocalCmd</code> <p>Connect to a device with a local command.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd","title":"LocalCmd","text":"<pre><code>LocalCmd(\n    name: str,\n    conn_command: str,\n    save_console_logs: str,\n    shell_prompt: list[str] | None = None,\n    args: list[str] | None = None,\n    **kwargs: dict[str, Any],\n)\n</code></pre> <p>Connect to a device with a local command.</p> <p>Initialize local command connection.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>connection name</p> required <code>str</code> <p>command to start the session</p> required <code>str</code> <p>save console logs to disk</p> required <code>list[str] | None</code> <p>shell prompt pattern, defaults to None</p> <code>None</code> <code>list[str] | None</code> <p>arguments to the command, defaults to None</p> <code>None</code> <code>dict[str, Any]</code> <p>additional keyword args</p> <code>{}</code> <p>Methods:</p> Name Description <code>execute_command</code> <p>Execute a command in the local command session.</p> <code>get_last_output</code> <p>Get last output from the buffer.</p> <code>login_to_server</code> <p>Login.</p> <code>start_interactive_session</code> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/connections/local_cmd.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,  # pylint: disable=unused-argument\n    name: str,\n    conn_command: str,\n    save_console_logs: str,\n    shell_prompt: list[str] | None = None,\n    args: list[str] | None = None,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Initialize local command connection.\n\n    :param name: connection name\n    :type name: str\n    :param conn_command: command to start the session\n    :type conn_command: str\n    :param save_console_logs: save console logs to disk\n    :type save_console_logs: str\n    :param shell_prompt: shell prompt pattern, defaults to None\n    :type shell_prompt: list[str]\n    :param args: arguments to the command, defaults to None\n    :type args: list[str], optional\n    :param kwargs: additional keyword args\n    \"\"\"\n    self._shell_prompt = shell_prompt\n    if args is None:\n        args = []\n    super().__init__(\n        name,\n        conn_command,\n        save_console_logs,\n        args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd(name)","title":"<code>name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd(conn_command)","title":"<code>conn_command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd(save_console_logs)","title":"<code>save_console_logs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd(shell_prompt)","title":"<code>shell_prompt</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd.execute_command","title":"execute_command","text":"<pre><code>execute_command(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the local command session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/local_cmd.py</code> <pre><code>def execute_command(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the local command session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    self.expect_exact(command)\n    self.expect(self.linesep)\n    # TODO: is this needed? is the shell prompt of Local(Jenkins or any user)?\n    self.expect(self._shell_prompt, timeout=timeout)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd.execute_command(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd.execute_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd.get_last_output","title":"get_last_output","text":"<pre><code>get_last_output() -&gt; str\n</code></pre> <p>Get last output from the buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>last output from the buffer</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def get_last_output(self) -&gt; str:\n    \"\"\"Get last output from the buffer.\n\n    :returns: last output from the buffer\n    \"\"\"\n    return self.before.strip()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd.login_to_server","title":"login_to_server","text":"<pre><code>login_to_server(password: str | None = None) -&gt; None\n</code></pre> <p>Login.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>ssh password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>connection failed via local command</p> <code>ValueError</code> <p>if shell prompt is unavailable</p> Source code in <code>boardfarm3/lib/connections/local_cmd.py</code> <pre><code>def login_to_server(self, password: str | None = None) -&gt; None:\n    \"\"\"Login.\n\n    :param password: ssh password\n    :raises DeviceConnectionError: connection failed via local command\n    :raises ValueError: if shell prompt is unavailable\n    \"\"\"\n    if password is not None:\n        if self.expect(\n            [\"password:\", pexpect.EOF, pexpect.TIMEOUT],\n        ):\n            raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n        self.sendline(password)\n    # TODO: temp fix for now. To be decided if shell prompt to be used.\n    if not self._shell_prompt:\n        raise ValueError(_SHELL_PROMPT_UNAVAILABLE_STR)\n    if (\n        self.expect(\n            [\n                pexpect.EOF,\n                pexpect.TIMEOUT,\n                *self._shell_prompt,\n            ],\n        )\n        &lt; _CONNECTION_ERROR_THRESHOLD\n    ):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd.login_to_server(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.local_cmd.LocalCmd.start_interactive_session","title":"start_interactive_session","text":"<pre><code>start_interactive_session() -&gt; None\n</code></pre> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def start_interactive_session(self) -&gt; None:\n    \"\"\"Start interactive pexpect session.\"\"\"\n    with disable_logs(\"pexpect\"):\n        self.interact()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection","title":"ser2net_connection","text":"<p>ser2net connection module.</p> <p>Classes:</p> Name Description <code>Ser2NetConnection</code> <p>Allow telnet session to be established with the ser2net daemon.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection","title":"Ser2NetConnection","text":"<pre><code>Ser2NetConnection(\n    session_name: str, command: str, save_console_logs: str, args: list[str]\n)\n</code></pre> <p>Allow telnet session to be established with the ser2net daemon.</p> <p>Requires the ser2net daemon to be running. Configuration to be stored in /etc/ser2net.conf Several devices can be connected to a host without the need for a terminal server. The following is a sample configuration for a single console:</p> <p>2001:telnet:0:/dev/ttyUSB0:115200 NONE 1STOPBIT 8DATABITS XONXOFF             banner max-connections=1</p> <p>The telnet:0 disables the timeout on the telnet session. No authentication needed.</p> <p>Initialize the Ser2Net connection.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>pexpect session name</p> required <code>str</code> <p>command to start the pexpect session</p> required <code>str</code> <p>save console logs to disk</p> required <code>list[str]</code> <p>additional arguments to the command</p> required <p>Methods:</p> Name Description <code>close</code> <p>Close the connection.</p> <code>execute_command</code> <p>Execute a command in the Telnet session.</p> <code>execute_command_async</code> <p>Execute a command in the Telnet session.</p> <code>get_last_output</code> <p>Get last output from the buffer.</p> <code>login_to_server</code> <p>Login to Ser2Net server.</p> <code>login_to_server_async</code> <p>Login to Ser2Net server using asyncio.</p> <code>start_interactive_session</code> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/connections/ser2net_connection.py</code> <pre><code>def __init__(\n    self,\n    session_name: str,\n    command: str,\n    save_console_logs: str,\n    args: list[str],\n) -&gt; None:\n    \"\"\"Initialize the Ser2Net connection.\n\n    :param session_name: pexpect session name\n    :type session_name: str\n    :param command: command to start the pexpect session\n    :type command: str\n    :param save_console_logs: save console logs to disk\n    :type save_console_logs: str\n    :param args: additional arguments to the command\n    :type args: list[str  |  list[str]]\n    \"\"\"\n    self._ip_addr, self._port = args[0], args[1]\n    super().__init__(\n        session_name,\n        command,\n        save_console_logs,\n        args,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection(session_name)","title":"<code>session_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection(save_console_logs)","title":"<code>save_console_logs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.close","title":"close","text":"<pre><code>close(force: bool = True) -&gt; None\n</code></pre> <p>Close the connection.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>True to send a SIGKILL, False for SIGINT/UP, default True</p> <code>True</code> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>def close(self, force: bool = True) -&gt; None:\n    \"\"\"Close the connection.\n\n    :param force: True to send a SIGKILL, False for SIGINT/UP, default True\n    :type force: bool\n    \"\"\"\n    self.sendcontrol(\"]\")\n    self.sendline(\"q\")\n    super().close(force=force)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.close(force)","title":"<code>force</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.execute_command","title":"execute_command","text":"<pre><code>execute_command(command: str, timeout: int = 30) -&gt; str\n</code></pre> <p>Execute a command in the Telnet session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to be executed</p> required <code>int</code> <p>timeout for command execute, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>def execute_command(self, command: str, timeout: int = 30) -&gt; str:\n    \"\"\"Execute a command in the Telnet session.\n\n    :param command: command to be executed\n    :type command: str\n    :param timeout: timeout for command execute, defaults to 30\n    :type timeout: int\n    :return: command output\n    :rtype: str\n    \"\"\"\n    self.sendline(command)\n    self.expect_exact(command)\n    self.expect(self._shell_prompt, timeout=timeout)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.execute_command(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.execute_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.execute_command_async","title":"execute_command_async  <code>async</code>","text":"<pre><code>execute_command_async(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the Telnet session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>async def execute_command_async(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the Telnet session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    await self.expect_exact(command, async_=True)\n    await self.expect(self.linesep, async_=True)\n    await self.expect(self._shell_prompt, timeout=timeout, async_=True)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.execute_command_async(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.execute_command_async(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.get_last_output","title":"get_last_output","text":"<pre><code>get_last_output() -&gt; str\n</code></pre> <p>Get last output from the buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>last output from the buffer</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def get_last_output(self) -&gt; str:\n    \"\"\"Get last output from the buffer.\n\n    :returns: last output from the buffer\n    \"\"\"\n    return self.before.strip()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.login_to_server","title":"login_to_server","text":"<pre><code>login_to_server(password: str | None = None) -&gt; None\n</code></pre> <p>Login to Ser2Net server.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>Telnet password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>connection failed to Telnet server</p> Source code in <code>boardfarm3/lib/connections/ser2net_connection.py</code> <pre><code>def login_to_server(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to Ser2Net server.\n\n    :param password: Telnet password\n    :raises DeviceConnectionError: connection failed to Telnet server\n    \"\"\"\n    super().login_to_server(password)\n    if self.expect(\n        [f\"ser2net port.*{self._port}\", pexpect.TIMEOUT],\n        timeout=10,\n    ):\n        msg = f\"ser2net: Failed to run 'telnet {self._ip_addr} {self._port}'\"\n        raise DeviceConnectionError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.login_to_server(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.login_to_server_async","title":"login_to_server_async  <code>async</code>","text":"<pre><code>login_to_server_async(password: str | None = None) -&gt; None\n</code></pre> <p>Login to Ser2Net server using asyncio.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>Telnet password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>connection failed to Telnet server</p> Source code in <code>boardfarm3/lib/connections/ser2net_connection.py</code> <pre><code>async def login_to_server_async(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to Ser2Net server using asyncio.\n\n    :param password: Telnet password\n    :raises DeviceConnectionError: connection failed to Telnet server\n    \"\"\"\n    await super().login_to_server_async(password)\n    if (\n        await self.expect(\n            [f\"ser2net port.*{self._port}\", pexpect.TIMEOUT],\n            timeout=10,\n            async_=True,\n        )\n        == 1\n    ):\n        msg = f\"ser2net: Failed to run 'telnet {self._ip_addr} {self._port}'\"\n        raise DeviceConnectionError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.login_to_server_async(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ser2net_connection.Ser2NetConnection.start_interactive_session","title":"start_interactive_session","text":"<pre><code>start_interactive_session() -&gt; None\n</code></pre> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def start_interactive_session(self) -&gt; None:\n    \"\"\"Start interactive pexpect session.\"\"\"\n    with disable_logs(\"pexpect\"):\n        self.interact()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection","title":"serial_connection","text":"<p>Connect to a device with a local serial command.</p> <p>Basically a local command with no authentication on connection.</p> <p>Classes:</p> Name Description <code>SerialConnection</code> <p>Connect to a device with local serail command.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection","title":"SerialConnection","text":"<pre><code>SerialConnection(\n    name: str,\n    conn_command: str,\n    save_console_logs: str,\n    shell_prompt: list[str] | None = None,\n    args: list[str] | None = None,\n    **kwargs: dict[str, Any],\n)\n</code></pre> <p>Connect to a device with local serail command.</p> <p>No authentication needed. Just connect!</p> <p>Initialize local command serial connection.</p> <p>No authentication!</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>connection name</p> required <code>str</code> <p>command to start the session</p> required <code>str</code> <p>save console logs to disk</p> required <code>list[str] | None</code> <p>shell prompt pattern, defaults to None</p> <code>None</code> <code>list[str] | None</code> <p>arguments to the command, defaults to None</p> <code>None</code> <code>dict[str, Any]</code> <p>additional keyword args</p> <code>{}</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>on connection failure</p> <p>Methods:</p> Name Description <code>execute_command</code> <p>Execute a command in the local command session.</p> <code>get_last_output</code> <p>Get last output from the buffer.</p> <code>login_to_server</code> <p>Do not do anything, just connect.</p> <code>start_interactive_session</code> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/connections/serial_connection.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,  # pylint: disable=unused-argument\n    name: str,\n    conn_command: str,\n    save_console_logs: str,\n    shell_prompt: list[str] | None = None,\n    args: list[str] | None = None,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Initialize local command serial connection.\n\n    No authentication!\n\n    :param name: connection name\n    :type name: str\n    :param conn_command: command to start the session\n    :type conn_command: str\n    :param save_console_logs: save console logs to disk\n    :type save_console_logs: str\n    :param shell_prompt: shell prompt pattern, defaults to None\n    :type shell_prompt: list[str]\n    :param args: arguments to the command, defaults to None\n    :type args: list[str], optional\n    :param kwargs: additional keyword args\n    :raises DeviceConnectionError: on connection failure\n    \"\"\"\n    if args is None:\n        args = conn_command.split()\n        conn_command = args.pop(0)\n    if kwargs.get(\"env\") is None:\n        # some serial commands need a terminal that is not \"dumb\"\n        kwargs[\"env\"] = {\n            \"PATH\": os.getenv(\"PATH\"),\n            \"TERM\": os.getenv(\"TERM\") if os.getenv(\"TERM\") else \"xterm\",\n        }\n    super().__init__(\n        name, conn_command, save_console_logs, shell_prompt, args, **kwargs\n    )\n    try:\n        self.expect(\"Terminal ready\", 5)\n    except EOF as exc:\n        raise DeviceConnectionError(self.before) from exc\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection(name)","title":"<code>name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection(conn_command)","title":"<code>conn_command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection(save_console_logs)","title":"<code>save_console_logs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection(shell_prompt)","title":"<code>shell_prompt</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection.execute_command","title":"execute_command","text":"<pre><code>execute_command(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the local command session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/serial_connection.py</code> <pre><code>def execute_command(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the local command session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    self.expect_exact(command)\n    self.expect(self.linesep)\n    # TODO: is this needed? is the shell prompt of Local(Jenkins or any user)?\n    self.expect(self._shell_prompt, timeout=timeout)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection.execute_command(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection.execute_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection.get_last_output","title":"get_last_output","text":"<pre><code>get_last_output() -&gt; str\n</code></pre> <p>Get last output from the buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>last output from the buffer</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def get_last_output(self) -&gt; str:\n    \"\"\"Get last output from the buffer.\n\n    :returns: last output from the buffer\n    \"\"\"\n    return self.before.strip()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection.login_to_server","title":"login_to_server","text":"<pre><code>login_to_server(password: str | None = None) -&gt; None\n</code></pre> <p>Do not do anything, just connect.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>unused</p> <code>None</code> Source code in <code>boardfarm3/lib/connections/serial_connection.py</code> <pre><code>def login_to_server(self, password: str | None = None) -&gt; None:\n    \"\"\"Do not do anything, just connect.\n\n    :param password: unused\n    \"\"\"\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection.login_to_server(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.serial_connection.SerialConnection.start_interactive_session","title":"start_interactive_session","text":"<pre><code>start_interactive_session() -&gt; None\n</code></pre> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def start_interactive_session(self) -&gt; None:\n    \"\"\"Start interactive pexpect session.\"\"\"\n    with disable_logs(\"pexpect\"):\n        self.interact()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection","title":"ssh_connection","text":"<p>SSH connection module.</p> <p>Classes:</p> Name Description <code>SSHConnection</code> <p>Connect to a device via SSH.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection","title":"SSHConnection","text":"<pre><code>SSHConnection(\n    name: str,\n    ip_addr: str,\n    username: str,\n    shell_prompt: list[str],\n    port: int = 22,\n    password: str | None = None,\n    save_console_logs: str = \"\",\n    **kwargs: dict[str, Any],\n)\n</code></pre> <p>Connect to a device via SSH.</p> <p>Initialize SSH connection.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>connection name</p> required <code>str</code> <p>ip address</p> required <code>str</code> <p>ssh username</p> required <code>list[str]</code> <p>shell prompt pattern</p> required <code>int</code> <p>port number, defaults to 22</p> <code>22</code> <code>str | None</code> <p>password, defaults to None</p> <code>None</code> <code>str</code> <p>save console logs, defaults to \"\"</p> <code>''</code> <code>dict[str, Any]</code> <p>other keyword arguments</p> <code>{}</code> <p>Methods:</p> Name Description <code>check_output</code> <p>Return an output of the command.</p> <code>execute_command</code> <p>Execute a command in the SSH session.</p> <code>execute_command_async</code> <p>Execute a command in the SSH session.</p> <code>get_last_output</code> <p>Get last output from the buffer.</p> <code>login_to_server</code> <p>Login to SSH session.</p> <code>login_to_server_async</code> <p>Login to SSH session.</p> <code>start_interactive_session</code> <p>Start interactive pexpect session.</p> <code>sudo_sendline</code> <p>Add sudo in the sendline if username is root.</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,  # pylint: disable=unused-argument\n    name: str,\n    ip_addr: str,\n    username: str,\n    shell_prompt: list[str],\n    port: int = 22,\n    password: str | None = None,\n    save_console_logs: str = \"\",\n    **kwargs: dict[str, Any],  # ignore other arguments  # noqa: ARG002\n) -&gt; None:\n    \"\"\"Initialize SSH connection.\n\n    :param name: connection name\n    :type name: str\n    :param ip_addr: ip address\n    :type ip_addr: str\n    :param username: ssh username\n    :type username: str\n    :param shell_prompt: shell prompt pattern\n    :type shell_prompt: list[str]\n    :param port: port number, defaults to 22\n    :type port: int\n    :param password: password, defaults to None\n    :type password: str\n    :param save_console_logs: save console logs, defaults to \"\"\n    :type save_console_logs: str\n    :param kwargs: other keyword arguments\n    \"\"\"\n    self._shell_prompt = shell_prompt\n    self._username = username\n    self._password = password\n    args = [\n        f\"{username}@{ip_addr}\",\n        f\"-p {port}\",\n        \"-o StrictHostKeyChecking=no\",\n        \"-o UserKnownHostsFile=/dev/null\",\n        \"-o ServerAliveInterval=60\",\n        \"-o ServerAliveCountMax=10\",\n        \"-o IdentitiesOnly=yes\",\n        \"-o HostKeyAlgorithms=+ssh-rsa\",\n    ]\n    super().__init__(name, \"ssh\", save_console_logs, args)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(name)","title":"<code>name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(ip_addr)","title":"<code>ip_addr</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(username)","title":"<code>username</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(shell_prompt)","title":"<code>shell_prompt</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(save_console_logs)","title":"<code>save_console_logs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.check_output","title":"check_output","text":"<pre><code>check_output(cmd: str, timeout: int = 30) -&gt; str\n</code></pre> <p>Return an output of the command.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout for command execute, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>if command doesn't execute in specified timeout</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def check_output(self, cmd: str, timeout: int = 30) -&gt; str:\n    \"\"\"Return an output of the command.\n\n    :param cmd: command to execute\n    :param timeout: timeout for command execute, defaults to 30\n    :raises BoardfarmException: if command doesn't execute in specified timeout\n    :return: command output\n    \"\"\"\n    self.sendline(\"\\n\" + cmd)\n    self.expect_exact(cmd, timeout=timeout)\n    try:\n        self.expect(self._shell_prompt, timeout=timeout)\n    except Exception as e:\n        self.sendcontrol(\"c\")\n        msg = (\n            f\"Command did not complete within {timeout} seconds. \"\n            f\"{self.name} prompt was not seen.\"\n        )\n        raise BoardfarmException(\n            msg,\n        ) from e\n    return str(self.before.strip())\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.check_output(cmd)","title":"<code>cmd</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.check_output(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.execute_command","title":"execute_command","text":"<pre><code>execute_command(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the SSH session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def execute_command(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the SSH session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    self.expect_exact(command)\n    self.expect(self.linesep)\n    self.expect(self._shell_prompt, timeout=timeout)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.execute_command(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.execute_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.execute_command_async","title":"execute_command_async  <code>async</code>","text":"<pre><code>execute_command_async(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the SSH session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>async def execute_command_async(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the SSH session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    await self.expect_exact(command, async_=True)\n    await self.expect(self.linesep, async_=True)\n    await self.expect(self._shell_prompt, timeout=timeout, async_=True)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.execute_command_async(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.execute_command_async(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.get_last_output","title":"get_last_output","text":"<pre><code>get_last_output() -&gt; str\n</code></pre> <p>Get last output from the buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>last output from the buffer</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def get_last_output(self) -&gt; str:\n    \"\"\"Get last output from the buffer.\n\n    :returns: last output from the buffer\n    \"\"\"\n    return self.before.strip()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.login_to_server","title":"login_to_server","text":"<pre><code>login_to_server(password: str | None = None) -&gt; None\n</code></pre> <p>Login to SSH session.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>ssh password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>connection failed to SSH server</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def login_to_server(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to SSH session.\n\n    :param password: ssh password\n    :raises DeviceConnectionError: connection failed to SSH server\n    \"\"\"\n    if password is None:\n        password = self._password\n    if self.expect(\n        [\"password:\", pexpect.EOF, pexpect.TIMEOUT],\n    ):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n    self.sendline(password)\n    if (\n        self.expect(\n            [\n                pexpect.EOF,\n                pexpect.TIMEOUT,\n                *self._shell_prompt,\n            ],\n        )\n        &lt; _CONNECTION_ERROR_THRESHOLD\n    ):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.login_to_server(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.login_to_server_async","title":"login_to_server_async  <code>async</code>","text":"<pre><code>login_to_server_async(password: str | None = None) -&gt; None\n</code></pre> <p>Login to SSH session.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>ssh password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>connection failed to SSH server</p> Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>async def login_to_server_async(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to SSH session.\n\n    :param password: ssh password\n    :raises DeviceConnectionError: connection failed to SSH server\n    \"\"\"\n    if password is None:\n        password = self._password\n    if await self.expect(\n        [\"password:\", pexpect.EOF, pexpect.TIMEOUT],\n        async_=True,\n    ):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n    self.sendline(password)\n    if (\n        await self.expect(\n            [\n                pexpect.EOF,\n                pexpect.TIMEOUT,\n                *self._shell_prompt,\n            ],\n            async_=True,\n        )\n        &lt; _CONNECTION_ERROR_THRESHOLD\n    ):\n        raise DeviceConnectionError(_CONNECTION_FAILED_STR)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.login_to_server_async(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.start_interactive_session","title":"start_interactive_session","text":"<pre><code>start_interactive_session() -&gt; None\n</code></pre> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def start_interactive_session(self) -&gt; None:\n    \"\"\"Start interactive pexpect session.\"\"\"\n    with disable_logs(\"pexpect\"):\n        self.interact()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.sudo_sendline","title":"sudo_sendline","text":"<pre><code>sudo_sendline(cmd: str) -&gt; None\n</code></pre> <p>Add sudo in the sendline if username is root.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to send</p> required Source code in <code>boardfarm3/lib/connections/ssh_connection.py</code> <pre><code>def sudo_sendline(self, cmd: str) -&gt; None:\n    \"\"\"Add sudo in the sendline if username is root.\n\n    :param cmd: command to send\n    \"\"\"\n    if self._username != \"root\":\n        self.sendline(\"sudo true\")\n        password_requested = self.expect(\n            [*self._shell_prompt, \"password for .*:\", \"Password:\"],\n        )\n        if password_requested:\n            self.sendline(self._password)\n            self.expect(self._shell_prompt)\n        cmd = \"sudo \" + cmd\n    self.sendline(cmd)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.ssh_connection.SSHConnection.sudo_sendline(cmd)","title":"<code>cmd</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet","title":"telnet","text":"<p>Telnet connection module.</p> <p>Classes:</p> Name Description <code>TelnetConnection</code> <p>A simple telnet session.</p>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection","title":"TelnetConnection","text":"<pre><code>TelnetConnection(\n    session_name: str, command: str, save_console_logs: str, args: list[str]\n)\n</code></pre> <p>A simple telnet session.</p> <p>Initialize the Ser2Net connection.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>pexpect session name</p> required <code>str</code> <p>command to start the pexpect session</p> required <code>str</code> <p>save console logs to disk</p> required <code>list[str]</code> <p>additional arguments to the command</p> required <p>Methods:</p> Name Description <code>close</code> <p>Close the connection.</p> <code>execute_command</code> <p>Execute a command in the Telnet session.</p> <code>execute_command_async</code> <p>Execute a command in the Telnet session.</p> <code>get_last_output</code> <p>Get last output from the buffer.</p> <code>login_to_server</code> <p>Login to Telnet server.</p> <code>login_to_server_async</code> <p>Login to Telnet seerver using asyncio.</p> <code>start_interactive_session</code> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>def __init__(\n    self,\n    session_name: str,\n    command: str,\n    save_console_logs: str,\n    args: list[str],\n) -&gt; None:\n    \"\"\"Initialize the Ser2Net connection.\n\n    :param session_name: pexpect session name\n    :type session_name: str\n    :param command: command to start the pexpect session\n    :type command: str\n    :param save_console_logs: save console logs to disk\n    :type save_console_logs: str\n    :param args: additional arguments to the command\n    :type args: list[str]\n    \"\"\"\n    self._ip_addr, self._port, self._shell_prompt = args[0], args[1], args.pop(2)\n    super().__init__(\n        session_name=session_name,\n        command=command,\n        save_console_logs=save_console_logs,\n        args=args,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection(session_name)","title":"<code>session_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection(save_console_logs)","title":"<code>save_console_logs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.close","title":"close","text":"<pre><code>close(force: bool = True) -&gt; None\n</code></pre> <p>Close the connection.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>True to send a SIGKILL, False for SIGINT/UP, default True</p> <code>True</code> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>def close(self, force: bool = True) -&gt; None:\n    \"\"\"Close the connection.\n\n    :param force: True to send a SIGKILL, False for SIGINT/UP, default True\n    :type force: bool\n    \"\"\"\n    self.sendcontrol(\"]\")\n    self.sendline(\"q\")\n    super().close(force=force)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.close(force)","title":"<code>force</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.execute_command","title":"execute_command","text":"<pre><code>execute_command(command: str, timeout: int = 30) -&gt; str\n</code></pre> <p>Execute a command in the Telnet session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to be executed</p> required <code>int</code> <p>timeout for command execute, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>def execute_command(self, command: str, timeout: int = 30) -&gt; str:\n    \"\"\"Execute a command in the Telnet session.\n\n    :param command: command to be executed\n    :type command: str\n    :param timeout: timeout for command execute, defaults to 30\n    :type timeout: int\n    :return: command output\n    :rtype: str\n    \"\"\"\n    self.sendline(command)\n    self.expect_exact(command)\n    self.expect(self._shell_prompt, timeout=timeout)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.execute_command(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.execute_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.execute_command_async","title":"execute_command_async  <code>async</code>","text":"<pre><code>execute_command_async(command: str, timeout: int = -1) -&gt; str\n</code></pre> <p>Execute a command in the Telnet session.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command to execute</p> required <code>int</code> <p>timeout in seconds. defaults to -1</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>async def execute_command_async(self, command: str, timeout: int = -1) -&gt; str:\n    \"\"\"Execute a command in the Telnet session.\n\n    :param command: command to execute\n    :param timeout: timeout in seconds. defaults to -1\n    :returns: command output\n    \"\"\"\n    self.sendline(command)\n    await self.expect_exact(command, async_=True)\n    await self.expect(self.linesep, async_=True)\n    await self.expect(self._shell_prompt, timeout=timeout, async_=True)\n    return self.get_last_output()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.execute_command_async(command)","title":"<code>command</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.execute_command_async(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.get_last_output","title":"get_last_output","text":"<pre><code>get_last_output() -&gt; str\n</code></pre> <p>Get last output from the buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>last output from the buffer</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def get_last_output(self) -&gt; str:\n    \"\"\"Get last output from the buffer.\n\n    :returns: last output from the buffer\n    \"\"\"\n    return self.before.strip()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.login_to_server","title":"login_to_server","text":"<pre><code>login_to_server(password: str | None = None) -&gt; None\n</code></pre> <p>Login to Telnet server.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>Telnet password</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>connection failed to Telnet server</p> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>def login_to_server(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to Telnet server.\n\n    :param password: Telnet password\n    :raises DeviceConnectionError: connection failed to Telnet server\n    \"\"\"\n    if password is not None:\n        msg = \"Authenticated Telnet not supported.\"\n        raise DeviceConnectionError(msg)\n    if self.expect(\n        [\n            f\"Connected to {self._ip_addr}\",\n            \"Escape character is '^]'.\",\n            pexpect.TIMEOUT,\n        ],\n        timeout=10,\n    ):\n        msg = f\"Failed to run 'telnet {self._ip_addr} {self._port}'\"\n        raise DeviceConnectionError(\n            msg,\n        )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.login_to_server(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.login_to_server_async","title":"login_to_server_async  <code>async</code>","text":"<pre><code>login_to_server_async(password: str | None = None) -&gt; None\n</code></pre> <p>Login to Telnet seerver using asyncio.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>Telnet password (currently unused)</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>connection failed to Telnet server</p> Source code in <code>boardfarm3/lib/connections/telnet.py</code> <pre><code>async def login_to_server_async(self, password: str | None = None) -&gt; None:\n    \"\"\"Login to Telnet seerver using asyncio.\n\n    :param password: Telnet password (currently unused)\n    :raises DeviceConnectionError: connection failed to Telnet server\n    \"\"\"\n    if password is not None:\n        msg = \"Authenticated Telnet not supported.\"\n        raise DeviceConnectionError(msg)\n    if (\n        await self.expect(\n            [\n                f\"Connected to {self._ip_addr}\",\n                \"Escape character is '^]'.\",\n                pexpect.TIMEOUT,\n            ],\n            timeout=10,\n            async_=True,\n        )\n        &gt; 1\n    ):\n        msg = f\"Failed to run 'telnet {self._ip_addr} {self._port}'\"\n        raise DeviceConnectionError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.login_to_server_async(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.connections.telnet.TelnetConnection.start_interactive_session","title":"start_interactive_session","text":"<pre><code>start_interactive_session() -&gt; None\n</code></pre> <p>Start interactive pexpect session.</p> Source code in <code>boardfarm3/lib/boardfarm_pexpect.py</code> <pre><code>def start_interactive_session(self) -&gt; None:\n    \"\"\"Start interactive pexpect session.\"\"\"\n    with disable_logs(\"pexpect\"):\n        self.interact()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw","title":"cpe_sw","text":"<p>Common libraries of CPE Sw component.</p> <p>Classes:</p> Name Description <code>CPESwLibraries</code> <p>CPE SW common libraries.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries","title":"CPESwLibraries","text":"<pre><code>CPESwLibraries(hardware: CPEHW)\n</code></pre> <p>CPE SW common libraries.</p> <p>Initialise the CPE software.</p> <p>Parameters:</p> Name Type Description Default <code>CPEHW</code> <p>cpe hardware instance</p> required <p>Methods:</p> Name Description <code>add_info_to_file</code> <p>Add data into a file.</p> <code>enable_logs</code> <p>Enable logs for given component.</p> <code>factory_reset</code> <p>Perform factory reset CPE via given method.</p> <code>finalize_boot</code> <p>Validate board settings post boot.</p> <code>get_board_logs</code> <p>Get the console log for the time period mentioned.</p> <code>get_boottime_log</code> <p>Return the boot time log from the board.</p> <code>get_date</code> <p>Get the system date and time.</p> <code>get_file_content</code> <p>Get the content of the given file.</p> <code>get_interface_ipv4_netmask</code> <p>Return given interface IPv4 netmask.</p> <code>get_interface_ipv4addr</code> <p>Return given interface IPv4 address.</p> <code>get_interface_ipv6addr</code> <p>Return given interface IPv6 address.</p> <code>get_interface_link_local_ipv6_addr</code> <p>Return given interface link local IPv6 address.</p> <code>get_interface_mac_addr</code> <p>Return given interface mac address.</p> <code>get_interface_mtu_size</code> <p>Get the MTU size of the interface in bytes.</p> <code>get_load_avg</code> <p>Return current load average of the cable modem.</p> <code>get_memory_utilization</code> <p>Return current memory utilization of the cable modem.</p> <code>get_ntp_sync_status</code> <p>Execute ntpq command to get the synchronization status.</p> <code>get_provision_mode</code> <p>Return provision mode.</p> <code>get_running_processes</code> <p>Return the currently running processes in the CPE via the <code>ps</code> command.</p> <code>get_seconds_uptime</code> <p>Return uptime in seconds.</p> <code>get_tr069_log</code> <p>Return the TR-069 log from the board.</p> <code>is_link_up</code> <p>Check given interface is up or not.</p> <code>is_online</code> <p>Is the device online.</p> <code>is_production</code> <p>Is production software.</p> <code>is_tr069_connected</code> <p>Is TR-69 agent is connected.</p> <code>kill_process_immediately</code> <p>Kill the process based on the provided PID.</p> <code>read_event_logs</code> <p>Return the event logs from the <code>logread</code> command.</p> <code>reset</code> <p>Perform reset via given method.</p> <code>set_date</code> <p>Set the device's date and time.</p> <code>verify_cpe_is_booting</code> <p>Verify CPE is booting.</p> <code>wait_for_boot</code> <p>Wait for CPE to boot.</p> <p>Attributes:</p> Name Type Description <code>aftr_iface</code> <code>str</code> <p>AFTR interface name.</p> <code>cpe_id</code> <code>str</code> <p>TR069 CPE ID.</p> <code>dmcli</code> <code>DMCLIAPI</code> <p>Dmcli instance running in CPE Software.</p> <code>erouter_iface</code> <code>str</code> <p>e-Router interface name.</p> <code>firewall</code> <code>IptablesFirewall</code> <p>Firewall component of cpe software.</p> <code>guest_iface</code> <code>str</code> <p>Guest network interface name.</p> <code>gui_password</code> <code>str</code> <p>GUI login password.</p> <code>json_values</code> <code>dict[str, Any]</code> <p>CPE Specific JSON values.</p> <code>lan_gateway_ipv4</code> <code>IPv4Address</code> <p>LAN Gateway IPv4 address.</p> <code>lan_gateway_ipv6</code> <code>IPv6Address</code> <p>LAN Gateway IPv6 address.</p> <code>lan_iface</code> <code>str</code> <p>LAN interface name.</p> <code>lan_network_ipv4</code> <code>IPv4Network</code> <p>LAN IPv4 network.</p> <code>nw_utility</code> <code>NetworkUtility</code> <p>Network utility component of cpe software.</p> <code>tr69_cpe_id</code> <code>str</code> <p>TR-69 CPE Identifier.</p> <code>version</code> <code>str</code> <p>CPE software version.</p> <code>wifi</code> <code>WiFiHal</code> <p>Wifi instance CPE Software.</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def __init__(self, hardware: CPEHW) -&gt; None:\n    \"\"\"Initialise the CPE software.\n\n    :param hardware: cpe hardware instance\n    :type hardware: CPEHW\n    \"\"\"\n    self._hw = hardware\n    self._nw_utility = NetworkUtility(self._get_console(\"networking\"))\n    self._firewall = IptablesFirewall(self._get_console(\"networking\"))\n    self._dmcli = DMCLIAPI(hardware.get_console(\"console\"))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries(hardware)","title":"<code>hardware</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.aftr_iface","title":"aftr_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>aftr_iface: str\n</code></pre> <p>AFTR interface name.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.cpe_id","title":"cpe_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>cpe_id: str\n</code></pre> <p>TR069 CPE ID.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.dmcli","title":"dmcli  <code>property</code>","text":"<pre><code>dmcli: DMCLIAPI\n</code></pre> <p>Dmcli instance running in CPE Software.</p> <p>Returns:</p> Type Description <code>DMCLIAPI</code> <p>the object instance</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.erouter_iface","title":"erouter_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>erouter_iface: str\n</code></pre> <p>e-Router interface name.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.firewall","title":"firewall  <code>property</code>","text":"<pre><code>firewall: IptablesFirewall\n</code></pre> <p>Firewall component of cpe software.</p> <p>Returns:</p> Type Description <code>IptablesFirewall</code> <p>Network firewall libraries</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.guest_iface","title":"guest_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>guest_iface: str\n</code></pre> <p>Guest network interface name.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.gui_password","title":"gui_password  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>gui_password: str\n</code></pre> <p>GUI login password.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.json_values","title":"json_values  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>json_values: dict[str, Any]\n</code></pre> <p>CPE Specific JSON values.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.lan_gateway_ipv4","title":"lan_gateway_ipv4  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_gateway_ipv4: IPv4Address\n</code></pre> <p>LAN Gateway IPv4 address.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.lan_gateway_ipv6","title":"lan_gateway_ipv6  <code>property</code>","text":"<pre><code>lan_gateway_ipv6: IPv6Address\n</code></pre> <p>LAN Gateway IPv6 address.</p> <p>Returns:</p> Type Description <code>IPv6Address</code> <p>IPv6 address of LAN GW</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.lan_iface","title":"lan_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_iface: str\n</code></pre> <p>LAN interface name.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.lan_network_ipv4","title":"lan_network_ipv4  <code>property</code>","text":"<pre><code>lan_network_ipv4: IPv4Network\n</code></pre> <p>LAN IPv4 network.</p> <p>Returns:</p> Type Description <code>IPv4Network</code> <p>LAN IPv4 network</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.nw_utility","title":"nw_utility  <code>property</code>","text":"<pre><code>nw_utility: NetworkUtility\n</code></pre> <p>Network utility component of cpe software.</p> <p>Returns:</p> Type Description <code>NetworkUtility</code> <p>Network utility libraries</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.tr69_cpe_id","title":"tr69_cpe_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>tr69_cpe_id: str\n</code></pre> <p>TR-69 CPE Identifier.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.version","title":"version  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>version: str\n</code></pre> <p>CPE software version.</p> <p>This will reload after each flash.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.wifi","title":"wifi  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>wifi: WiFiHal\n</code></pre> <p>Wifi instance CPE Software.</p>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.add_info_to_file","title":"add_info_to_file","text":"<pre><code>add_info_to_file(to_add: str, fname: str) -&gt; None\n</code></pre> <p>Add data into a file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>contents/data to be added to a file.</p> required <code>str</code> <p>filename with absolute path</p> required Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def add_info_to_file(self, to_add: str, fname: str) -&gt; None:\n    \"\"\"Add data into a file.\n\n    :param to_add: contents/data to be added to a file.\n    :type to_add: str\n    :param fname: filename with absolute path\n    :type fname: str\n    \"\"\"\n    self._get_console(\"default_shell\").execute_command(f\"echo {to_add} &gt;&gt; {fname}\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.add_info_to_file(to_add)","title":"<code>to_add</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.add_info_to_file(fname)","title":"<code>fname</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.enable_logs","title":"enable_logs","text":"<pre><code>enable_logs(component: str, flag: str = 'enable') -&gt; None\n</code></pre> <p>Enable logs for given component.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>component name</p> required <code>str</code> <p>flag name, Default: \"enable\"</p> <code>'enable'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>pending implementation</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def enable_logs(self, component: str, flag: str = \"enable\") -&gt; None:\n    \"\"\"Enable logs for given component.\n\n    :param component: component name\n    :param flag: flag name, Default: \"enable\"\n    :raises NotImplementedError: pending implementation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.enable_logs(component)","title":"<code>component</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.enable_logs(flag)","title":"<code>flag</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.factory_reset","title":"factory_reset  <code>abstractmethod</code>","text":"<pre><code>factory_reset(method: str | None = None) -&gt; bool\n</code></pre> <p>Perform factory reset CPE via given method.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>factory reset method. Default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True on successful factory reset, False otherwise</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef factory_reset(self, method: str | None = None) -&gt; bool:\n    \"\"\"Perform factory reset CPE via given method.\n\n    :param method: factory reset method. Default None.\n    :type method: str | None\n    :return: True on successful factory reset, False otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.factory_reset(method)","title":"<code>method</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.finalize_boot","title":"finalize_boot  <code>abstractmethod</code>","text":"<pre><code>finalize_boot() -&gt; bool\n</code></pre> <p>Validate board settings post boot.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True on successful validation</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef finalize_boot(self) -&gt; bool:\n    \"\"\"Validate board settings post boot.\n\n    :return: True on successful validation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_board_logs","title":"get_board_logs","text":"<pre><code>get_board_logs(timeout: int = 300) -&gt; str\n</code></pre> <p>Get the console log for the time period mentioned.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>time value to collect the logs for, defaults to 300</p> <code>300</code> <p>Returns:</p> Type Description <code>str</code> <p>Console logs for a given time period</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>if the console is not initialised, i.e. board has no console connections</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_board_logs(self, timeout: int = 300) -&gt; str:\n    \"\"\"Get the console log for the time period mentioned.\n\n    :param timeout: time value to collect the logs for, defaults to 300\n    :type timeout: int\n    :return: Console logs for a given time period\n    :rtype: str\n    :raises BoardfarmException: if the console is not initialised,\n        i.e. board has no console connections\n    \"\"\"\n    if self._console:\n        self._console.sendline()\n        self._console.expect(pexpect.TIMEOUT, timeout=timeout)\n        return str(self._console.before)\n    msg = \"Console obj is not initialized\"\n    raise BoardfarmException(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_board_logs(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_boottime_log","title":"get_boottime_log","text":"<pre><code>get_boottime_log() -&gt; list[str]\n</code></pre> <p>Return the boot time log from the board.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>pending implementation</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_boottime_log(self) -&gt; list[str]:\n    \"\"\"Return the boot time log from the board.\n\n    :raises NotImplementedError: pending implementation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_date","title":"get_date","text":"<pre><code>get_date() -&gt; str | None\n</code></pre> <p>Get the system date and time.</p> <p>.. code-block:: python</p> <pre><code># example output\ndonderdag, mei 23, 2024 14:23:39\n</code></pre> <p>Returns:</p> Type Description <code>str | None</code> <p>date</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_date(self) -&gt; str | None:\n    \"\"\"Get the system date and time.\n\n    .. code-block:: python\n\n        # example output\n        donderdag, mei 23, 2024 14:23:39\n\n\n    :return: date\n    :rtype: str | None\n    \"\"\"\n    cpe_date = self._console.execute_command(\"date '+%A, %B %d, %Y %T'\")\n    date = re.search(\n        r\"(\\w+,\\s\\w+\\s\\d+,\\s\\d+\\s(([0-1]?[0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9])\",\n        cpe_date,\n    )\n    if date is not None:\n        return date.group(0)\n    return None\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_file_content","title":"get_file_content","text":"<pre><code>get_file_content(fname: str, timeout: int) -&gt; str\n</code></pre> <p>Get the content of the given file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required <code>int</code> <p>timeout value to fetch the file content</p> required <p>Returns:</p> Type Description <code>str</code> <p>contents of the file</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_file_content(self, fname: str, timeout: int) -&gt; str:\n    \"\"\"Get the content of the given file.\n\n    :param fname: name of the file with absolute path\n    :type fname: str\n    :param timeout: timeout value to fetch the file content\n    :type timeout: int\n    :return: contents of the file\n    :rtype: str\n    \"\"\"\n    return self._get_console(\"default_shell\").execute_command(\n        f\"cat {fname}\",\n        timeout,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_file_content(fname)","title":"<code>fname</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_file_content(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_ipv4_netmask","title":"get_interface_ipv4_netmask","text":"<pre><code>get_interface_ipv4_netmask(interface: str) -&gt; IPv4Address\n</code></pre> <p>Return given interface IPv4 netmask.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>IPv4Address</code> <p>netmask of the interface</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_interface_ipv4_netmask(self, interface: str) -&gt; IPv4Address:\n    \"\"\"Return given interface IPv4 netmask.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: netmask of the interface\n    :rtype: IPv4Address\n    \"\"\"\n    output = self._get_console(\"networking\").execute_command(\n        f\"ifconfig {interface}\",\n    )\n    netmask = output.split(\"Mask:\")[-1].split()[0]\n    return IPv4Address(netmask)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_ipv4_netmask(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_ipv4addr","title":"get_interface_ipv4addr","text":"<pre><code>get_interface_ipv4addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface IPv4 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if unable to parse IPv4Address</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_interface_ipv4addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface IPv4 address.\n\n    :param interface: interface name\n    :return: IPv4 address\n    :rtype: str\n    :raises ValueError: if unable to parse IPv4Address\n    \"\"\"\n    if ips := self._get_nw_interface_ip_address(interface, is_ipv6=False):\n        return ips[0]\n    msg = f\"Failed to get IPv4 address of {interface} interface\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_ipv4addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_ipv6addr","title":"get_interface_ipv6addr","text":"<pre><code>get_interface_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface IPv6 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_interface_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface IPv6 address.\n\n    :param interface: interface name\n    :return: IPv6 address\n    \"\"\"\n    return self._get_interface_ipv6_address(interface, \"global\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_link_local_ipv6_addr","title":"get_interface_link_local_ipv6_addr","text":"<pre><code>get_interface_link_local_ipv6_addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface link local IPv6 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>link local IPv6 address</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_interface_link_local_ipv6_addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface link local IPv6 address.\n\n    :param interface: interface name\n    :return: link local IPv6 address\n    \"\"\"\n    return self._get_interface_ipv6_address(interface, address_type=\"link-local\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_link_local_ipv6_addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_mac_addr","title":"get_interface_mac_addr","text":"<pre><code>get_interface_mac_addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface mac address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>mac address of the given interface</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_interface_mac_addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface mac address.\n\n    :param interface: interface name\n    :return: mac address of the given interface\n    \"\"\"\n    return (\n        self._get_console(\"networking\")\n        .execute_command(f\"cat /sys/class/net/{interface}/address\")\n        .strip()\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_mac_addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_mtu_size","title":"get_interface_mtu_size  <code>abstractmethod</code>","text":"<pre><code>get_interface_mtu_size(interface: str) -&gt; int\n</code></pre> <p>Get the MTU size of the interface in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>int</code> <p>size of the MTU in bytes</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_mtu_size(self, interface: str) -&gt; int:\n    \"\"\"Get the MTU size of the interface in bytes.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: size of the MTU in bytes\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_interface_mtu_size(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_load_avg","title":"get_load_avg","text":"<pre><code>get_load_avg() -&gt; float\n</code></pre> <p>Return current load average of the cable modem.</p> <p>Returns:</p> Type Description <code>float</code> <p>current load average for the past minute</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_load_avg(self) -&gt; float:\n    \"\"\"Return current load average of the cable modem.\n\n    :return: current load average for the past minute\n    :rtype: float\n    \"\"\"\n    return float(\n        self._get_console(\"default_shell\")\n        .execute_command(r\"cat /proc/loadavg | cut -d\\  -f1\")\n        .strip(),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_memory_utilization","title":"get_memory_utilization","text":"<pre><code>get_memory_utilization() -&gt; dict[str, int]\n</code></pre> <p>Return current memory utilization of the cable modem.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>current memory utilization of cpe</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_memory_utilization(self) -&gt; dict[str, int]:\n    \"\"\"Return current memory utilization of the cable modem.\n\n    :return: current memory utilization of cpe\n    :rtype: dict[str, int]\n    \"\"\"\n    memory_keys = []\n    memory_val: list[str] = []\n    result = self._get_console(\"default_shell\").execute_command(\"free -m\")\n    if regex_match := re.search(\n        r\"Mem:\\s+((\\d+)(\\s+)(\\d+)(\\s+)(\\d+)(\\s+)(\\d+)(\\s+)(\\d+)(\\s+)(\\d+))\",\n        result,\n    ):\n        memory_keys = [\n            \"total\",\n            \"used\",\n            \"free\",\n            \"shared\",\n            \"cache\",\n            \"available\",\n        ]\n        memory_val = regex_match.group(1).strip().split()\n    # ignoring pylint error as fixing it would cause mypy to complain\n    # about unreachable code...\n    return dict(zip(memory_keys, map(int, memory_val)))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_ntp_sync_status","title":"get_ntp_sync_status","text":"<pre><code>get_ntp_sync_status() -&gt; list[dict[str, Any]]\n</code></pre> <p>Execute ntpq command to get the synchronization status.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>pending implementation</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_ntp_sync_status(\n    self,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute ntpq command to get the synchronization status.\n\n    :raises NotImplementedError: pending implementation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_provision_mode","title":"get_provision_mode  <code>abstractmethod</code>","text":"<pre><code>get_provision_mode() -&gt; str\n</code></pre> <p>Return provision mode.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_provision_mode(self) -&gt; str:\n    \"\"\"Return provision mode.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_running_processes","title":"get_running_processes","text":"<pre><code>get_running_processes(ps_options: str | None = '-A') -&gt; Iterable[ParsedPSOutput]\n</code></pre> <p>Return the currently running processes in the CPE via the <code>ps</code> command.</p> <p>.. code-block:: python</p> <pre><code># parsed_ps_output\n[\n    {\"pid\": 1, \"tty\": None, \"time\": \"00:02:29\", \"cmd\": \"init\"},\n    {\"pid\": 2, \"tty\": None, \"time\": \"00:00:00\", \"cmd\": \"kthreadd\"},\n    {\"pid\": 3, \"tty\": None, \"time\": \"00:00:36\", \"cmd\": \"ksoftirqd/0\"},\n    {\"pid\": 5, \"tty\": None, \"time\": \"00:00:00\", \"cmd\": \"kworker/0:0H\"},\n    ...\n    {'pid': 2613, 'tty': None, 'time': '00:03:25', 'cmd': 'CcspTr069PaSsp'}\n    ...\n]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>The options to be passed to the ps command, defaults to \"-A\"</p> <code>'-A'</code> <p>Returns:</p> Type Description <code>Iterable[ParsedPSOutput]</code> <p>the currently running processes as a parsed tuple of dictionaries</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_running_processes(\n    self, ps_options: str | None = \"-A\"\n) -&gt; Iterable[ParsedPSOutput]:\n    \"\"\"Return the currently running processes in the CPE via the `ps` command.\n\n    .. code-block:: python\n\n        # parsed_ps_output\n        [\n            {\"pid\": 1, \"tty\": None, \"time\": \"00:02:29\", \"cmd\": \"init\"},\n            {\"pid\": 2, \"tty\": None, \"time\": \"00:00:00\", \"cmd\": \"kthreadd\"},\n            {\"pid\": 3, \"tty\": None, \"time\": \"00:00:36\", \"cmd\": \"ksoftirqd/0\"},\n            {\"pid\": 5, \"tty\": None, \"time\": \"00:00:00\", \"cmd\": \"kworker/0:0H\"},\n            ...\n            {'pid': 2613, 'tty': None, 'time': '00:03:25', 'cmd': 'CcspTr069PaSsp'}\n            ...\n        ]\n\n    :param ps_options: The options to be passed to the ps command, defaults to \"-A\"\n    :type ps_options: str | None\n    :return: the currently running processes as a parsed tuple of dictionaries\n    :rtype: Iterable[ParsedPSOutput]\n    \"\"\"\n    return cast(\n        \"tuple[ParsedPSOutput]\",\n        parse(\n            \"ps\",\n            self._get_console(\"default_shell\").execute_command(f\"ps {ps_options}\"),\n        ),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_running_processes(ps_options)","title":"<code>ps_options</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_seconds_uptime","title":"get_seconds_uptime","text":"<pre><code>get_seconds_uptime() -&gt; float\n</code></pre> <p>Return uptime in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>uptime in seconds</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if failed to get uptime</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_seconds_uptime(self) -&gt; float:\n    \"\"\"Return uptime in seconds.\n\n    :return: uptime in seconds\n    :rtype: float\n    :raises ValueError: if failed to get uptime\n    \"\"\"\n    result = self._get_console(\"default_shell\").execute_command(\"cat /proc/uptime\")\n    regex_match = re.search(r\"((\\d+)\\.(\\d{2}))(\\s)(\\d+)\\.(\\d{2})\", result)\n    if regex_match is None:\n        msg = \"Failed to get the uptime\"\n        raise ValueError(msg)\n    return float(regex_match[1])\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.get_tr069_log","title":"get_tr069_log","text":"<pre><code>get_tr069_log() -&gt; list[str]\n</code></pre> <p>Return the TR-069 log from the board.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>pending implementation</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def get_tr069_log(self) -&gt; list[str]:\n    \"\"\"Return the TR-069 log from the board.\n\n    :raises NotImplementedError: pending implementation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.is_link_up","title":"is_link_up","text":"<pre><code>is_link_up(interface: str, pattern: str = 'BROADCAST,MULTICAST,UP') -&gt; bool\n</code></pre> <p>Check given interface is up or not.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name, defaults to \"BROADCAST,MULTICAST,UP\"</p> required <code>str</code> <p>interface state</p> <code>'BROADCAST,MULTICAST,UP'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the link is up</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def is_link_up(\n    self,\n    interface: str,\n    pattern: str = \"BROADCAST,MULTICAST,UP\",\n) -&gt; bool:\n    \"\"\"Check given interface is up or not.\n\n    :param interface: interface name, defaults to \"BROADCAST,MULTICAST,UP\"\n    :type interface: str\n    :param pattern: interface state\n    :type pattern: str\n    :return: True if the link is up\n    :rtype: bool\n    \"\"\"\n    return is_link_up(self._get_console(\"networking\"), interface, pattern)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.is_link_up(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.is_link_up(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.is_online","title":"is_online","text":"<pre><code>is_online() -&gt; bool\n</code></pre> <p>Is the device online.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device is online, False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if erouter mode not in [\"dual\", \"ipv4\", \"ipv6\"]</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def is_online(self) -&gt; bool:\n    \"\"\"Is the device online.\n\n    :return: True if the device is online, False otherwise\n    :raises ValueError: if erouter mode not in [\"dual\", \"ipv4\", \"ipv6\"]\n    \"\"\"\n    mode = self._hw.config.get(\"eRouter_Provisioning_mode\", \"dual\")\n    if mode not in [\"dual\", \"ipv4\", \"ipv6\"]:\n        msg = f\"Unsupported mode: {mode}\"\n        raise ValueError(msg)\n    online: bool = True\n    try:\n        if mode in [\"dual\", \"ipv4\"]:\n            online &amp;= bool(self.get_interface_ipv4addr(self.erouter_iface))\n        if mode in [\"dual\", \"ipv6\"]:\n            online &amp;= bool(self.get_interface_ipv6addr(self.erouter_iface))\n    except ValueError:\n        online = False\n    return online\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.is_production","title":"is_production  <code>abstractmethod</code>","text":"<pre><code>is_production() -&gt; bool\n</code></pre> <p>Is production software.</p> <p>Production software has limited capabilities.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_production(self) -&gt; bool:\n    \"\"\"Is production software.\n\n    Production software has limited capabilities.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.is_tr069_connected","title":"is_tr069_connected","text":"<pre><code>is_tr069_connected() -&gt; bool\n</code></pre> <p>Is TR-69 agent is connected.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>pending implementation</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def is_tr069_connected(self) -&gt; bool:\n    \"\"\"Is TR-69 agent is connected.\n\n    :raises NotImplementedError: pending implementation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.kill_process_immediately","title":"kill_process_immediately","text":"<pre><code>kill_process_immediately(pid: int) -&gt; None\n</code></pre> <p>Kill the process based on the provided PID.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>process number</p> required Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def kill_process_immediately(self, pid: int) -&gt; None:\n    \"\"\"Kill the process based on the provided PID.\n\n    :param pid: process number\n    :type pid: int\n    \"\"\"\n    self._get_console(\"default_shell\").execute_command(f\"kill -9 {pid}\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.kill_process_immediately(pid)","title":"<code>pid</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.read_event_logs","title":"read_event_logs","text":"<pre><code>read_event_logs() -&gt; JSONDictType | list[JSONDictType] | Iterator[JSONDictType]\n</code></pre> <p>Return the event logs from the <code>logread</code> command.</p> <p>.. code-block:: python</p> <pre><code># example output\n[\n    {\n        \"priority\": None,\n        \"date\": \"May  8 02:28:26\",\n        \"hostname\": \"mv1cbn-arm\",\n        \"tag\": \"kern\",\n        \"content\": \".debug kernel: PP MC Session delete: failed for src...\",\n    },\n    {\n        \"priority\": None,\n        \"date\": \"May  8 02:42:46\",\n        \"hostname\": \"mv1cbn-arm\",\n        \"tag\": \"user\",\n        \"content\": \".debug MCPROXY: del mroute gaddr: 239.255.255.250, ...\",\n    },\n    {\n        \"priority\": None,\n        \"date\": \"May  8 02:42:56\",\n        \"hostname\": \"mv1cbn-arm\",\n        \"tag\": \"kern\",\n        \"content\": \".debug kernel: PP MC Session delete: failed for src...\",\n    },\n    {\n        \"priority\": None,\n        \"date\": \"May  8 02:57:16\",\n        \"hostname\": \"mv1cbn-arm\",\n        \"tag\": \"user\",\n        \"content\": \".debug MCPROXY: del mroute gaddr: 239.255.255.250, ...\",\n    },\n]\n</code></pre> <p>Returns:</p> Type Description <code>JSONDictType | list[JSONDictType] | Iterator[JSONDictType]</code> <p>the event logs from the <code>logread</code> command.</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def read_event_logs(\n    self,\n) -&gt; JSONDictType | list[JSONDictType] | Iterator[JSONDictType]:\n    \"\"\"Return the event logs from the `logread` command.\n\n    .. code-block:: python\n\n        # example output\n        [\n            {\n                \"priority\": None,\n                \"date\": \"May  8 02:28:26\",\n                \"hostname\": \"mv1cbn-arm\",\n                \"tag\": \"kern\",\n                \"content\": \".debug kernel: PP MC Session delete: failed for src...\",\n            },\n            {\n                \"priority\": None,\n                \"date\": \"May  8 02:42:46\",\n                \"hostname\": \"mv1cbn-arm\",\n                \"tag\": \"user\",\n                \"content\": \".debug MCPROXY: del mroute gaddr: 239.255.255.250, ...\",\n            },\n            {\n                \"priority\": None,\n                \"date\": \"May  8 02:42:56\",\n                \"hostname\": \"mv1cbn-arm\",\n                \"tag\": \"kern\",\n                \"content\": \".debug kernel: PP MC Session delete: failed for src...\",\n            },\n            {\n                \"priority\": None,\n                \"date\": \"May  8 02:57:16\",\n                \"hostname\": \"mv1cbn-arm\",\n                \"tag\": \"user\",\n                \"content\": \".debug MCPROXY: del mroute gaddr: 239.255.255.250, ...\",\n            },\n        ]\n\n    :return: the event logs from the `logread` command.\n    :rtype: JSONDictType | list[JSONDictType] | Iterator[JSONDictType]\n    \"\"\"\n    return parse(\n        \"syslog-bsd\",\n        self._get_console(\"default_shell\").execute_command(\"logread\"),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.reset","title":"reset  <code>abstractmethod</code>","text":"<pre><code>reset(method: str | None = None) -&gt; None\n</code></pre> <p>Perform reset via given method.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>reset method. Default None</p> <code>None</code> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef reset(self, method: str | None = None) -&gt; None:\n    \"\"\"Perform reset via given method.\n\n    :param method: reset method. Default None\n    :type method: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.reset(method)","title":"<code>method</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.set_date","title":"set_date","text":"<pre><code>set_date(date_string: str) -&gt; bool\n</code></pre> <p>Set the device's date and time.</p> <p>It should execute <code>date -s {date_string}</code> on the device's console.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>value to be changed</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if set is successful</p> Source code in <code>boardfarm3/lib/cpe_sw.py</code> <pre><code>def set_date(self, date_string: str) -&gt; bool:\n    \"\"\"Set the device's date and time.\n\n    It should execute `date -s {date_string}` on the device's console.\n\n    :param date_string: value to be changed\n    :type date_string: str\n    :return: True if set is successful\n    :rtype: bool\n    \"\"\"\n    cmd_out = self._console.execute_command(f\"date -s {date_string}\")\n    return bool(cmd_out)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.set_date(date_string)","title":"<code>date_string</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.verify_cpe_is_booting","title":"verify_cpe_is_booting  <code>abstractmethod</code>","text":"<pre><code>verify_cpe_is_booting() -&gt; None\n</code></pre> <p>Verify CPE is booting.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef verify_cpe_is_booting(self) -&gt; None:\n    \"\"\"Verify CPE is booting.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.cpe_sw.CPESwLibraries.wait_for_boot","title":"wait_for_boot  <code>abstractmethod</code>","text":"<pre><code>wait_for_boot() -&gt; None\n</code></pre> <p>Wait for CPE to boot.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef wait_for_boot(self) -&gt; None:\n    \"\"\"Wait for CPE to boot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.custom_typing","title":"custom_typing","text":"<p>Boardfarm3 custom type hints package.</p> <p>Modules:</p> Name Description <code>cpe</code> <p>Collection on Enum to be used.</p> <code>dhcp</code> <p>DHCP type hints for Provisioner Templates.</p> <code>jc</code> <p>Type hints for jc parsed output.</p>"},{"location":"reference/libs/#boardfarm3.lib.custom_typing.cpe","title":"cpe","text":"<p>Collection on Enum to be used.</p> <p>Classes:</p> Name Description <code>CPEInterfaces</code> <p>Define all the interfaces on CPE.</p> <code>HostInterfaces</code> <p>Define all the interfaces on the Host device.</p>"},{"location":"reference/libs/#boardfarm3.lib.custom_typing.cpe.CPEInterfaces","title":"CPEInterfaces","text":"<p>Define all the interfaces on CPE.</p> <p>The corresponding value should be available as an instance on board object.</p>"},{"location":"reference/libs/#boardfarm3.lib.custom_typing.cpe.HostInterfaces","title":"HostInterfaces","text":"<p>Define all the interfaces on the Host device.</p> <p>The corresponding value should be available as an instance on the device object.</p>"},{"location":"reference/libs/#boardfarm3.lib.custom_typing.dhcp","title":"dhcp","text":"<p>DHCP type hints for Provisioner Templates.</p>"},{"location":"reference/libs/#boardfarm3.lib.custom_typing.jc","title":"jc","text":"<p>Type hints for jc parsed output.</p> <p>Classes:</p> Name Description <code>ParsedPSOutput</code> <p>Typing for parsed output returned by jc for the ps command.</p>"},{"location":"reference/libs/#boardfarm3.lib.custom_typing.jc.ParsedPSOutput","title":"ParsedPSOutput","text":"<p>Typing for parsed output returned by jc for the ps command.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass","title":"dataclass","text":"<p>Boardfarm3 dataclasses.</p> <p>These are used to store/load information required by usecases.</p> <p>Modules:</p> Name Description <code>dhcp</code> <p>Dataclasses to store DHCP info.</p> <code>interface</code> <p>Data classes to store IP interface info.</p> <code>network_models</code> <p>Data classes to store all models related to network.</p> <code>packets</code> <p>Data classes to store network packets.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp","title":"dhcp","text":"<p>Dataclasses to store DHCP info.</p> <p>Classes:</p> Name Description <code>DHCPV6Options</code> <p>DHCPV6Options data class.</p> <code>DHCPV6TraceData</code> <p>DHCPv6TraceData data class.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options","title":"DHCPV6Options  <code>dataclass</code>","text":"<pre><code>DHCPV6Options(option_data: ResultDict)\n</code></pre> <p>DHCPV6Options data class.</p> <p>Attributes:</p> Name Type Description <code>option_1</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 1.</p> <code>option_14</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 14.</p> <code>option_16</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 16.</p> <code>option_17</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 17.</p> <code>option_2</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 2.</p> <code>option_20</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 20.</p> <code>option_23</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 23.</p> <code>option_24</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 24.</p> <code>option_25</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 25.</p> <code>option_26</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 26.</p> <code>option_3</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 3.</p> <code>option_5</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 5.</p> <code>option_6</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 6.</p> <code>option_64</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 64.</p> <code>option_8</code> <code>ResultDict | None</code> <p>DHCP IPv6 option 8.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_1","title":"option_1  <code>property</code>","text":"<pre><code>option_1: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 1.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 1.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_14","title":"option_14  <code>property</code>","text":"<pre><code>option_14: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 14.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 14.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_16","title":"option_16  <code>property</code>","text":"<pre><code>option_16: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 16.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 16.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_17","title":"option_17  <code>property</code>","text":"<pre><code>option_17: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 17.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 17.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_2","title":"option_2  <code>property</code>","text":"<pre><code>option_2: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 2.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 2.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_20","title":"option_20  <code>property</code>","text":"<pre><code>option_20: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 20.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 20.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_23","title":"option_23  <code>property</code>","text":"<pre><code>option_23: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 23.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 23.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_24","title":"option_24  <code>property</code>","text":"<pre><code>option_24: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 24.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 24.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_25","title":"option_25  <code>property</code>","text":"<pre><code>option_25: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 25.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 25.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_26","title":"option_26  <code>property</code>","text":"<pre><code>option_26: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 26.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 26.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_3","title":"option_3  <code>property</code>","text":"<pre><code>option_3: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 3.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 3.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_5","title":"option_5  <code>property</code>","text":"<pre><code>option_5: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 5.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 5.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_6","title":"option_6  <code>property</code>","text":"<pre><code>option_6: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 6.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 6.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_64","title":"option_64  <code>property</code>","text":"<pre><code>option_64: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 64.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 64.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6Options.option_8","title":"option_8  <code>property</code>","text":"<pre><code>option_8: ResultDict | None\n</code></pre> <p>DHCP IPv6 option 8.</p> <p>Returns:</p> Type Description <code>ResultDict | None</code> <p>DHCP IPv6 option 8.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.dhcp.DHCPV6TraceData","title":"DHCPV6TraceData  <code>dataclass</code>","text":"<pre><code>DHCPV6TraceData(\n    source: IPAddresses,\n    destination: IPAddresses,\n    dhcpv6_packet: ResultDict,\n    dhcpv6_message_type: int,\n)\n</code></pre> <p>DHCPv6TraceData data class.</p> <p>Holds source, destination, DHCPv6_packet and DHCPv6_message_type.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.interface","title":"interface","text":"<p>Data classes to store IP interface info.</p> <p>Classes:</p> Name Description <code>IPAddresses</code> <p>To store IP address information.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.interface.IPAddresses","title":"IPAddresses  <code>dataclass</code>","text":"<pre><code>IPAddresses(\n    ipv4: IPv4Address | None,\n    ipv6: IPv6Address | None,\n    link_local_ipv6: IPv6Address | None,\n)\n</code></pre> <p>To store IP address information.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.network_models","title":"network_models","text":"<p>Data classes to store all models related to network.</p> <p>Classes:</p> Name Description <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator data classes.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.network_models.IPerf3TrafficGenerator","title":"IPerf3TrafficGenerator  <code>dataclass</code>","text":"<pre><code>IPerf3TrafficGenerator(\n    traffic_sender: LAN | WAN | WLAN,\n    sender_pid: int | None,\n    traffic_receiver: LAN | WAN | WLAN,\n    receiver_pid: int | None,\n    server_log_file: str = \"\",\n    client_log_file: str = \"\",\n)\n</code></pre> <p>IPerf3TrafficGenerator data classes.</p> <p>It holds sender/receiver devices and their process IDs.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.packets","title":"packets","text":"<p>Data classes to store network packets.</p> <p>Classes:</p> Name Description <code>ICMPPacketData</code> <p>ICMP packet data class.</p> <code>RIPv2PacketData</code> <p>Class to hold RIP packet details for Use Case.</p>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.packets.ICMPPacketData","title":"ICMPPacketData  <code>dataclass</code>","text":"<pre><code>ICMPPacketData(query_code: int, source: IPAddresses, destination: IPAddresses)\n</code></pre> <p>ICMP packet data class.</p> <p>To hold all the packet information specific to ICMP packets.</p> <p><code>source</code> and <code>destination</code> could be either IPv4 or IPv6 addresses. <code>query_code</code> defines the type of message received or sent and could be among the following:</p> <pre><code>* Type 0 = Echo Reply\n* Type 8 = Echo Request\n* Type 9 = Router Advertisement\n* Type 10 = Router Solicitation\n* Type 13 = Timestamp Request\n* Type 14 = Timestamp Reply\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.dataclass.packets.RIPv2PacketData","title":"RIPv2PacketData  <code>dataclass</code>","text":"<pre><code>RIPv2PacketData(\n    source: IPv4Address,\n    destination: IPv4Address,\n    ip_address: list[IPv4Address],\n    subnet: list[IPv4Interface | IPv6Interface],\n    frame_time: datetime | None = None,\n)\n</code></pre> <p>Class to hold RIP packet details for Use Case.</p>"},{"location":"reference/libs/#boardfarm3.lib.device_manager","title":"device_manager","text":"<p>Boardfarm device manager.</p> <p>Classes:</p> Name Description <code>DeviceManager</code> <p>Manages all the devices in the environment.</p> <p>Functions:</p> Name Description <code>get_device_manager</code> <p>Return device manager instance if already instantiated.</p>"},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager","title":"DeviceManager","text":"<pre><code>DeviceManager(plugin_manager: PluginManager)\n</code></pre> <p>Manages all the devices in the environment.</p> <p>Initialize device manager.</p> <p>Parameters:</p> Name Type Description Default <code>PluginManager</code> <p>plugin manager</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when DeviceManager is already initialized</p> <p>Methods:</p> Name Description <code>get_device_by_type</code> <p>Get first device of the given type.</p> <code>get_devices_by_type</code> <p>Get devices of given type.</p> <code>register_device</code> <p>Register a device as plugin with boardfarm.</p> <code>unregister_device</code> <p>Unregister a device from boardfarm.</p> Source code in <code>boardfarm3/lib/device_manager.py</code> <pre><code>def __init__(self, plugin_manager: PluginManager) -&gt; None:\n    \"\"\"Initialize device manager.\n\n    :param plugin_manager: plugin manager\n    :raises ValueError: when DeviceManager is already initialized\n    \"\"\"\n    global _DEVICE_MANAGER_INSTANCE  # pylint: disable=global-statement  # noqa: PLW0603\n    if _DEVICE_MANAGER_INSTANCE is not None:\n        msg = \"DeviceManager is already initialized.\"  # type: ignore[unreachable]\n        raise ValueError(msg)\n    self._plugin_manager = plugin_manager\n    _DEVICE_MANAGER_INSTANCE = self\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager(plugin_manager)","title":"<code>plugin_manager</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.get_device_by_type","title":"get_device_by_type","text":"<pre><code>get_device_by_type(device_type: type[T]) -&gt; T\n</code></pre> <p>Get first device of the given type.</p> <p>In order to get all devices of given type use get_devices_by_type.</p> <p>Parameters:</p> Name Type Description Default <code>type[T]</code> <p>device type</p> required <p>Returns:</p> Type Description <code>T</code> <p>device of given type</p> <p>Raises:</p> Type Description <code>DeviceNotFound</code> <p>when device of given type not available</p> Source code in <code>boardfarm3/lib/device_manager.py</code> <pre><code>def get_device_by_type(self, device_type: type[T]) -&gt; T:\n    \"\"\"Get first device of the given type.\n\n    In order to get all devices of given type use get_devices_by_type.\n\n    :param device_type: device type\n    :returns: device of given type\n    :raises DeviceNotFound: when device of given type not available\n    \"\"\"\n    for _, plugin in self._plugin_manager.list_name_plugin():\n        if isinstance(plugin, device_type):\n            return plugin\n    msg = f\"No device available of type {device_type}\"\n    raise DeviceNotFound(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.get_device_by_type(device_type)","title":"<code>device_type</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.get_devices_by_type","title":"get_devices_by_type","text":"<pre><code>get_devices_by_type(device_type: type[T]) -&gt; dict[str, T]\n</code></pre> <p>Get devices of given type.</p> <p>Parameters:</p> Name Type Description Default <code>type[T]</code> <p>device type</p> required <p>Returns:</p> Type Description <code>dict[str, T]</code> <p>devices of given type</p> Source code in <code>boardfarm3/lib/device_manager.py</code> <pre><code>def get_devices_by_type(self, device_type: type[T]) -&gt; dict[str, T]:\n    \"\"\"Get devices of given type.\n\n    :param device_type: device type\n    :returns: devices of given type\n    \"\"\"\n    return {\n        name: plugin\n        for name, plugin in self._plugin_manager.list_name_plugin()\n        if isinstance(plugin, device_type)\n    }\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.get_devices_by_type(device_type)","title":"<code>device_type</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.register_device","title":"register_device","text":"<pre><code>register_device(device: BoardfarmDevice) -&gt; None\n</code></pre> <p>Register a device as plugin with boardfarm.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmDevice</code> <p>device instance to register</p> required Source code in <code>boardfarm3/lib/device_manager.py</code> <pre><code>def register_device(self, device: BoardfarmDevice) -&gt; None:\n    \"\"\"Register a device as plugin with boardfarm.\n\n    :param device: device instance to register\n    :type device: BoardfarmDevice\n    \"\"\"\n    # During the registration of a plugin to the boardfarm, Pluggy calls all\n    # of its properties. However, if a plugin has a method that throws an\n    # exception, it can cause the boardfarm to crash. To address this issue\n    # with Pluggy, we ignore the NotImplementedError and NotSupportedError\n    # exceptions while registering a plugin.\n    with mock.patch.object(\n        device.__class__,\n        \"__getattribute__\",\n        _get_attribute_with_ignore_exception,\n    ):\n        self._plugin_manager.register(device, device.device_name)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.register_device(device)","title":"<code>device</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.unregister_device","title":"unregister_device","text":"<pre><code>unregister_device(device_name: str) -&gt; None\n</code></pre> <p>Unregister a device from boardfarm.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of device to unregister</p> required Source code in <code>boardfarm3/lib/device_manager.py</code> <pre><code>def unregister_device(self, device_name: str) -&gt; None:\n    \"\"\"Unregister a device from boardfarm.\n\n    :param device_name: name of device to unregister\n    \"\"\"\n    self._plugin_manager.set_blocked(device_name)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.device_manager.DeviceManager.unregister_device(device_name)","title":"<code>device_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.device_manager.get_device_manager","title":"get_device_manager","text":"<pre><code>get_device_manager() -&gt; DeviceManager\n</code></pre> <p>Return device manager instance if already instantiated.</p> <p>When you run boardfarm it will initialize the DeviceManager.</p> <p>Returns:</p> Type Description <code>DeviceManager</code> <p>device manager instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when device manager in not instantiated</p> Source code in <code>boardfarm3/lib/device_manager.py</code> <pre><code>def get_device_manager() -&gt; DeviceManager:\n    \"\"\"Return device manager instance if already instantiated.\n\n    When you run boardfarm it will initialize the DeviceManager.\n\n    :raises ValueError: when device manager in not instantiated\n    :return: device manager instance\n    :rtype: DeviceManager\n    \"\"\"\n    if _DEVICE_MANAGER_INSTANCE is None:\n        msg = \"DeviceManager is not instantiated.\"\n        raise ValueError(msg)\n    return _DEVICE_MANAGER_INSTANCE\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.dmcli","title":"dmcli","text":"<p>RDKB dmcli command line interface module.</p> <p>Classes:</p> Name Description <code>DMCLIAPI</code> <p>RDKB dmcli command line interface utility.</p> <code>DMCLIError</code> <p>Raise this on DMCLI command line utility errors.</p> <code>DMCLIOut</code> <p>DMCLI command output data.</p>"},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI","title":"DMCLIAPI","text":"<pre><code>DMCLIAPI(console: BoardfarmPexpect)\n</code></pre> <p>RDKB dmcli command line interface utility.</p> <p>Initialize DMCLIAPI.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmPexpect</code> <p>console instance which has dmcli utility</p> required <p>Methods:</p> Name Description <code>AddObject</code> <p>Add object via dmcli.</p> <code>DelObject</code> <p>Add object via dmcli.</p> <code>GPV</code> <p>Get given parameter value via dmcli.</p> <code>SPV</code> <p>Set given parameter via dmcli.</p> Source code in <code>boardfarm3/lib/dmcli.py</code> <pre><code>def __init__(self, console: BoardfarmPexpect) -&gt; None:\n    \"\"\"Initialize DMCLIAPI.\n\n    :param console: console instance which has dmcli utility\n    :type console: BoardfarmPexpect\n    \"\"\"\n    self._console = console\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.AddObject","title":"AddObject","text":"<pre><code>AddObject(param: str) -&gt; DMCLIOut\n</code></pre> <p>Add object via dmcli.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>param to be added</p> required <p>Returns:</p> Type Description <code>DMCLIOut</code> <p>dmcli output object</p> Source code in <code>boardfarm3/lib/dmcli.py</code> <pre><code>def AddObject(self, param: str) -&gt; DMCLIOut:  # pylint: disable=invalid-name\n    \"\"\"Add object via dmcli.\n\n    :param param: param to be added\n    :return: dmcli output object\n    :rtype: DMCLIOut\n    \"\"\"\n    return self._trigger_dmcli_cmd(\"addtable\", param)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.AddObject(param)","title":"<code>param</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.DelObject","title":"DelObject","text":"<pre><code>DelObject(param: str) -&gt; DMCLIOut\n</code></pre> <p>Add object via dmcli.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>param to delete</p> required <p>Returns:</p> Type Description <code>DMCLIOut</code> <p>dmcli output object</p> Source code in <code>boardfarm3/lib/dmcli.py</code> <pre><code>def DelObject(self, param: str) -&gt; DMCLIOut:  # pylint: disable=invalid-name\n    \"\"\"Add object via dmcli.\n\n    :param param: param to delete\n    :return: dmcli output object\n    :rtype: DMCLIOut\n    \"\"\"\n    return self._trigger_dmcli_cmd(\"deltable\", param)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.DelObject(param)","title":"<code>param</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.GPV","title":"GPV","text":"<pre><code>GPV(param: str) -&gt; DMCLIOut\n</code></pre> <p>Get given parameter value via dmcli.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>param to get</p> required <p>Returns:</p> Type Description <code>DMCLIOut</code> <p>dmcli output object</p> Source code in <code>boardfarm3/lib/dmcli.py</code> <pre><code>def GPV(self, param: str) -&gt; DMCLIOut:  # pylint: disable=invalid-name\n    \"\"\"Get given parameter value via dmcli.\n\n    :param param: param to get\n    :type param: str\n    :return: dmcli output object\n    :rtype: DMCLIOut\n    \"\"\"\n    return self._trigger_dmcli_cmd(\"getvalues\", param)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.GPV(param)","title":"<code>param</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.SPV","title":"SPV","text":"<pre><code>SPV(\n    param: str, value: str, type_set: str = \"string\", sleep_timeout: float = 0.0\n) -&gt; DMCLIOut\n</code></pre> <p>Set given parameter via dmcli.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>param in which value is to be set</p> required <code>str</code> <p>value to be set</p> required <code>str</code> <p>type of value set, defaults to string</p> <code>'string'</code> <code>float</code> <p>sleep values when SPV, defaults to 0.0</p> <code>0.0</code> <p>Returns:</p> Type Description <code>DMCLIOut</code> <p>dmcli output object</p> Source code in <code>boardfarm3/lib/dmcli.py</code> <pre><code>def SPV(  # pylint: disable=invalid-name\n    self,\n    param: str,\n    value: str,\n    type_set: str = \"string\",\n    sleep_timeout: float = 0.0,\n) -&gt; DMCLIOut:\n    \"\"\"Set given parameter via dmcli.\n\n    :param param: param in which value is to be set\n    :param value: value to be set\n    :param type_set: type of value set, defaults to string\n    :param sleep_timeout: sleep values when SPV, defaults to 0.0\n    :return: dmcli output object\n    :rtype: DMCLIOut\n    \"\"\"\n    return self._trigger_dmcli_cmd(\n        \"setvalues\", f\"{param} {type_set} {value}\", sleep_timeout\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.SPV(param)","title":"<code>param</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.SPV(value)","title":"<code>value</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.SPV(type_set)","title":"<code>type_set</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIAPI.SPV(sleep_timeout)","title":"<code>sleep_timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIError","title":"DMCLIError","text":"<p>Raise this on DMCLI command line utility errors.</p>"},{"location":"reference/libs/#boardfarm3.lib.dmcli.DMCLIOut","title":"DMCLIOut  <code>dataclass</code>","text":"<pre><code>DMCLIOut(status: str, rtype: str, rval: str, console_out: str)\n</code></pre> <p>DMCLI command output data.</p> <p>Properties: status, rtype, rval, console_out</p>"},{"location":"reference/libs/#boardfarm3.lib.docker_factory","title":"docker_factory","text":"<p>Docker Factory v2 related libraries.</p> <p>Modules:</p> Name Description <code>docker_compose_generator</code> <p>Library to generate docker-compose.yml payload to docker factory v2.</p>"},{"location":"reference/libs/#boardfarm3.lib.docker_factory.docker_compose_generator","title":"docker_compose_generator","text":"<p>Library to generate docker-compose.yml payload to docker factory v2.</p> <p>Classes:</p> Name Description <code>DockerComposeGenerator</code> <p>Class to manage docker-compose.yml payload for docker factory v2.</p>"},{"location":"reference/libs/#boardfarm3.lib.docker_factory.docker_compose_generator.DockerComposeGenerator","title":"DockerComposeGenerator","text":"<pre><code>DockerComposeGenerator(boardfarm_config: BoardfarmConfig)\n</code></pre> <p>Class to manage docker-compose.yml payload for docker factory v2.</p> <p>Initialize the YMLManager for Docker Factory v2.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmConfig</code> <p>Boardfarm Config instance</p> required <p>Methods:</p> Name Description <code>generate_docker_compose</code> <p>Generate the docker-compose yml to be used as payload for docker factory.</p> Source code in <code>boardfarm3/lib/docker_factory/docker_compose_generator.py</code> <pre><code>def __init__(self, boardfarm_config: BoardfarmConfig) -&gt; None:\n    \"\"\"Initialize the YMLManager for Docker Factory v2.\n\n    :param boardfarm_config: Boardfarm Config instance\n    :type boardfarm_config: BoardfarmConfig\n    \"\"\"\n    self._templates_path = Path(__file__).parent / \"templates\"\n    self._boardfarm_config = boardfarm_config\n    self._devices_list: list[str] = []\n    self._get_devices(self._boardfarm_config.env_config)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.docker_factory.docker_compose_generator.DockerComposeGenerator(boardfarm_config)","title":"<code>boardfarm_config</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.docker_factory.docker_compose_generator.DockerComposeGenerator.generate_docker_compose","title":"generate_docker_compose","text":"<pre><code>generate_docker_compose() -&gt; dict[str, Any]\n</code></pre> <p>Generate the docker-compose yml to be used as payload for docker factory.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The docker compose payload for docker factory</p> Source code in <code>boardfarm3/lib/docker_factory/docker_compose_generator.py</code> <pre><code>def generate_docker_compose(self) -&gt; dict[str, Any]:\n    \"\"\"Generate the docker-compose yml to be used as payload for docker factory.\n\n    :return: The docker compose payload for docker factory\n    :rtype: dict[str, Any]\n    \"\"\"\n    base_compose = self._generate_base_compose()\n    for device in sorted(self._devices_list):\n        base_compose = self._merge_dicts(\n            base_compose,\n            self._generate_device_compose(device),\n        )\n    return jsonmerge.merge(\n        base_compose,\n        self._generate_orchestrator_compose(list(base_compose[\"services\"].keys())),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui","title":"gui","text":"<p>Keep SonarQube happy.</p> <p>Modules:</p> Name Description <code>gui_helper</code> <p>Module for Selenium webdriver interaction implementations.</p> <code>prplos</code> <p>Keep ruff happy.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper","title":"gui_helper","text":"<p>Module for Selenium webdriver interaction implementations.</p> <p>Classes:</p> Name Description <code>GuiHelper</code> <p>GuiHelper class to get webdrivers for testing.</p> <code>GuiHelperNoProxy</code> <p>GuiHelper without proxy.</p> <code>ScreenshotListener</code> <p>Take a screenshot on exceptions/events.</p> <p>Functions:</p> Name Description <code>element_is_present_by_css</code> <p>Determine if element is present by its css selector.</p> <code>firefox_webproxy_driver</code> <p>Initialize proxy firefox webdriver.</p> <code>get_web_driver</code> <p>Return proxy webdriver.</p> <code>save_screenshot</code> <p>Save screenshot of the driver window.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelper","title":"GuiHelper","text":"<pre><code>GuiHelper(\n    device: LAN | WAN | WLAN, default_delay: int = 20, output_dir: str | None = None\n)\n</code></pre> <p>GuiHelper class to get webdrivers for testing.</p> <p>GUI helper class.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>int</code> <p>default delay in seconds, defaults to 20</p> <code>20</code> <code>str | None</code> <p>output directory path, defaults to None</p> <code>None</code> <p>Methods:</p> Name Description <code>get_web_driver</code> <p>Return event firing web driver.</p> <code>get_webdriver_without_event_firing</code> <p>Return webdriver without the EventFiringWebDriver.</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def __init__(\n    self,\n    device: LAN | WAN | WLAN,\n    default_delay: int = 20,\n    output_dir: str | None = None,\n) -&gt; None:\n    \"\"\"GUI helper class.\n\n    :param device: device instance\n    :type device: LAN | WAN | WLAN\n    :param default_delay: default delay in seconds, defaults to 20\n    :type default_delay: int\n    :param output_dir: output directory path, defaults to None\n    :type output_dir: str | None\n    \"\"\"\n    if output_dir is None:\n        output_dir = pathlib.Path.cwd().joinpath(\"results\").as_posix()\n    self._device = device\n    self._default_delay = default_delay\n    self._test_name = get_pytest_name()\n    self._screenshot_path = str(\n        pathlib.PurePosixPath(output_dir).joinpath(self._test_name)\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelper(device)","title":"<code>device</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelper(default_delay)","title":"<code>default_delay</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelper(output_dir)","title":"<code>output_dir</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelper.get_web_driver","title":"get_web_driver","text":"<pre><code>get_web_driver() -&gt; EventFiringWebDriver\n</code></pre> <p>Return event firing web driver.</p> <p>Returns:</p> Type Description <code>EventFiringWebDriver</code> <p>web driver instance</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def get_web_driver(self) -&gt; EventFiringWebDriver:\n    \"\"\"Return event firing web driver.\n\n    :return: web driver instance\n    :rtype: EventFiringWebDriver\n    \"\"\"\n    webdriver = get_web_driver(\n        self._device, self._default_delay, headless=self._headless\n    )\n    event_firing_webdriver = EventFiringWebDriver(\n        webdriver, ScreenshotListener(self._screenshot_path)\n    )\n    event_firing_webdriver.screenshot_path = self._screenshot_path\n    return event_firing_webdriver\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelper.get_webdriver_without_event_firing","title":"get_webdriver_without_event_firing","text":"<pre><code>get_webdriver_without_event_firing(headless: bool = True) -&gt; WebDriver\n</code></pre> <p>Return webdriver without the EventFiringWebDriver.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>run in headless mode, defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>WebDriver</code> <p>web driver instance</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def get_webdriver_without_event_firing(self, headless: bool = True) -&gt; WebDriver:\n    \"\"\"Return webdriver without the EventFiringWebDriver.\n\n    :param headless: run in headless mode, defaults to True\n    :type headless: bool\n    :return: web driver instance\n    :rtype: WebDriver\n    \"\"\"\n    driver = get_web_driver(self._device, self._default_delay, headless=headless)\n    driver.screenshot_path = self._screenshot_path  # type: ignore[attr-defined]\n    return driver\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelper.get_webdriver_without_event_firing(headless)","title":"<code>headless</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelperNoProxy","title":"GuiHelperNoProxy","text":"<pre><code>GuiHelperNoProxy(\n    default_delay: int = 20, output_dir: str | None = None, headless: bool = True\n)\n</code></pre> <p>GuiHelper without proxy.</p> <p>GUI helper class without proxy.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>default delay in seconds, defaults to 20</p> <code>20</code> <code>str | None</code> <p>output directory path, defaults to None</p> <code>None</code> <code>bool</code> <p>turns on/off headless mode, defaults to True</p> <code>True</code> <p>Methods:</p> Name Description <code>get_web_driver</code> <p>Return event firing web driver.</p> <code>get_webdriver_without_event_firing</code> <p>Return webdriver without the EventFiringWebDriver.</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def __init__(\n    self,\n    default_delay: int = 20,\n    output_dir: str | None = None,\n    headless: bool = True,\n) -&gt; None:\n    \"\"\"GUI helper class without proxy.\n\n    :param default_delay: default delay in seconds, defaults to 20\n    :type default_delay: int\n    :param output_dir: output directory path, defaults to None\n    :type output_dir: str\n    :param headless: turns on/off headless mode, defaults to True\n    :type headless: bool\n    \"\"\"\n    super().__init__(None, default_delay, output_dir)\n    self._headless = headless\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelperNoProxy(default_delay)","title":"<code>default_delay</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelperNoProxy(output_dir)","title":"<code>output_dir</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelperNoProxy(headless)","title":"<code>headless</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelperNoProxy.get_web_driver","title":"get_web_driver","text":"<pre><code>get_web_driver() -&gt; EventFiringWebDriver\n</code></pre> <p>Return event firing web driver.</p> <p>Returns:</p> Type Description <code>EventFiringWebDriver</code> <p>web driver instance</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def get_web_driver(self) -&gt; EventFiringWebDriver:\n    \"\"\"Return event firing web driver.\n\n    :return: web driver instance\n    :rtype: EventFiringWebDriver\n    \"\"\"\n    webdriver = firefox_webproxy_driver(\n        http_proxy=\"\",\n        default_delay=self._default_delay,\n        headless=self._headless,\n    )\n    webdriver.maximize_window()\n    event_firing_webdriver = EventFiringWebDriver(\n        webdriver, ScreenshotListener(self._screenshot_path)\n    )\n    event_firing_webdriver.screenshot_path = self._screenshot_path\n    return event_firing_webdriver\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelperNoProxy.get_webdriver_without_event_firing","title":"get_webdriver_without_event_firing","text":"<pre><code>get_webdriver_without_event_firing(headless: bool = True) -&gt; WebDriver\n</code></pre> <p>Return webdriver without the EventFiringWebDriver.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>run in headless mode, defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>WebDriver</code> <p>web driver instance</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def get_webdriver_without_event_firing(self, headless: bool = True) -&gt; WebDriver:\n    \"\"\"Return webdriver without the EventFiringWebDriver.\n\n    :param headless: run in headless mode, defaults to True\n    :type headless: bool\n    :return: web driver instance\n    :rtype: WebDriver\n    \"\"\"\n    driver = get_web_driver(self._device, self._default_delay, headless=headless)\n    driver.screenshot_path = self._screenshot_path  # type: ignore[attr-defined]\n    return driver\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.GuiHelperNoProxy.get_webdriver_without_event_firing(headless)","title":"<code>headless</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener","title":"ScreenshotListener","text":"<pre><code>ScreenshotListener(screenshot_path: str)\n</code></pre> <p>Take a screenshot on exceptions/events.</p> <p>This allows to capture screenshot based on selenium web driver events. Capturing screenshot can be varied by setting the logging.root.level When logging.root.level set to :</p> <pre><code>1. NOTSET - takes screenshots for on_exception and before_click events\n2. INFO   - takes screenshots for on_exception, before_click and\n                    after_change_value_of events\n3. DEBUG  - takes screenshot for all the events\n</code></pre> <p>Init method.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the screenshot destination dir</p> required <p>Methods:</p> Name Description <code>after_change_value_of</code> <p>Capture screenshot after change_value_of event.</p> <code>after_click</code> <p>Capture screenshot after click event.</p> <code>after_close</code> <p>Capture screenshot after close event.</p> <code>after_execute_script</code> <p>Capture screenshot after execute_script event.</p> <code>after_navigate_to</code> <p>Capture screenshot after navigate_to event.</p> <code>before_change_value_of</code> <p>Capture screenshot before change_value_of event.</p> <code>before_click</code> <p>Capture screenshot before click event.</p> <code>before_close</code> <p>Capture screenshot before close event.</p> <code>before_execute_script</code> <p>Capture screenshot before execute_script event.</p> <code>before_navigate_to</code> <p>Capture screenshot before navigate_to event.</p> <code>before_quit</code> <p>Capture screenshot before quit event.</p> <code>capture_screenshot</code> <p>Capture screenshot and save name.ext to disk.</p> <code>on_exception</code> <p>Capture screenshot on exception.</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def __init__(self, screenshot_path: str):\n    \"\"\"Init method.\n\n    :param screenshot_path: the screenshot destination dir\n    :type screenshot_path: str\n    \"\"\"\n    super().__init__()\n    self.screenshot_path = screenshot_path\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener(screenshot_path)","title":"<code>screenshot_path</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_change_value_of","title":"after_change_value_of","text":"<pre><code>after_change_value_of(element: WebElement, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot after change_value_of event.</p> <p>Parameters:</p> Name Type Description Default <code>WebElement</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def after_change_value_of(\n    self,\n    element: WebElement,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot after change_value_of event.\n\n    :param element: unused\n    :type element: WebElement\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled or self.debug_enabled:\n        self.capture_screenshot(driver, \"after_change_value_of\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_change_value_of(element)","title":"<code>element</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_change_value_of(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_click","title":"after_click","text":"<pre><code>after_click(element: WebElement, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot after click event.</p> <p>Parameters:</p> Name Type Description Default <code>WebElement</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def after_click(\n    self,\n    element: WebElement,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot after click event.\n\n    :param element: unused\n    :type element: WebElement\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"after_click\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_click(element)","title":"<code>element</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_click(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_close","title":"after_close","text":"<pre><code>after_close(driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot after close event.</p> <p>Parameters:</p> Name Type Description Default <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def after_close(self, driver: WebDriver) -&gt; None:\n    \"\"\"Capture screenshot after close event.\n\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"after_close\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_close(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_execute_script","title":"after_execute_script","text":"<pre><code>after_execute_script(script: str, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot after execute_script event.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def after_execute_script(\n    self,\n    script: str,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot after execute_script event.\n\n    :param script: unused\n    :type script: str\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"after_execute_script\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_execute_script(script)","title":"<code>script</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_execute_script(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_navigate_to","title":"after_navigate_to","text":"<pre><code>after_navigate_to(url: str, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot after navigate_to event.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def after_navigate_to(\n    self,\n    url: str,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot after navigate_to event.\n\n    :param url: unused\n    :type url: str\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"after_navigate_to\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_navigate_to(url)","title":"<code>url</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.after_navigate_to(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_change_value_of","title":"before_change_value_of","text":"<pre><code>before_change_value_of(element: WebElement, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot before change_value_of event.</p> <p>Parameters:</p> Name Type Description Default <code>WebElement</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def before_change_value_of(\n    self,\n    element: WebElement,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot before change_value_of event.\n\n    :param element: unused\n    :type element: WebElement\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"before_change_value_of\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_change_value_of(element)","title":"<code>element</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_change_value_of(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_click","title":"before_click","text":"<pre><code>before_click(element: WebElement, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot before click event.</p> <p>Parameters:</p> Name Type Description Default <code>WebElement</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def before_click(\n    self,\n    element: WebElement,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot before click event.\n\n    :param element: unused\n    :type element: WebElement\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    self.capture_screenshot(driver, \"before_click\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_click(element)","title":"<code>element</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_click(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_close","title":"before_close","text":"<pre><code>before_close(driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot before close event.</p> <p>Parameters:</p> Name Type Description Default <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def before_close(self, driver: WebDriver) -&gt; None:\n    \"\"\"Capture screenshot before close event.\n\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"before_close\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_close(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_execute_script","title":"before_execute_script","text":"<pre><code>before_execute_script(script: str, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot before execute_script event.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def before_execute_script(\n    self,\n    script: str,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot before execute_script event.\n\n    :param script: unused\n    :type script: str\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"before_execute_script\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_execute_script(script)","title":"<code>script</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_execute_script(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_navigate_to","title":"before_navigate_to","text":"<pre><code>before_navigate_to(url: str, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot before navigate_to event.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def before_navigate_to(\n    self,\n    url: str,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot before navigate_to event.\n\n    :param url: unused\n    :type url: str\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"before_navigate_to\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_navigate_to(url)","title":"<code>url</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_navigate_to(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_quit","title":"before_quit","text":"<pre><code>before_quit(driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot before quit event.</p> <p>Parameters:</p> Name Type Description Default <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def before_quit(self, driver: WebDriver) -&gt; None:\n    \"\"\"Capture screenshot before quit event.\n\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    if self.verbose_debug_enabled:\n        self.capture_screenshot(driver, \"before_quit\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.before_quit(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.capture_screenshot","title":"capture_screenshot","text":"<pre><code>capture_screenshot(driver: WebDriver, name: str, ext: str = 'png') -&gt; None\n</code></pre> <p>Capture screenshot and save name.ext to disk.</p> <p>Parameters:</p> Name Type Description Default <code>WebDriver</code> <p>web driver</p> required <code>str</code> <p>the filename (with path if needed)</p> required <code>str</code> <p>the extension, defaults to png</p> <code>'png'</code> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def capture_screenshot(\n    self, driver: WebDriver, name: str, ext: str = \"png\"\n) -&gt; None:\n    \"\"\"Capture screenshot and save name.ext to disk.\n\n    :param driver: web driver\n    :type driver: WebDriver\n    :param name: the filename (with path if needed)\n    :type name: str\n    :param ext: the extension, defaults to png\n    :type ext: str\n    \"\"\"\n    WebDriverWait(driver, 10).until(\n        lambda drv: drv.execute_script(\n            \"return document.readyState\",\n        )\n        == \"complete\"\n    )\n    now = datetime.now(tz=UTC)\n    abs_path = (\n        \"_\".join([self.screenshot_path, now.strftime(\"%Y%m%d_%H%M%S%f\"), name])\n        + \".\"\n        + ext\n    )\n\n    def gui_page_size(dimension: str) -&gt; str:\n        return driver.execute_script(\n            \"return document.body.parentNode.scroll\" + dimension\n        )\n\n    # Setting screen size twice because one is not enough for Selenium :)\n    driver.set_window_size(gui_page_size(\"Width\"), gui_page_size(\"Height\"))\n    driver.set_window_size(gui_page_size(\"Width\"), gui_page_size(\"Height\"))\n\n    driver.get_screenshot_as_file(abs_path)\n    driver.maximize_window()  # Restore window to fit screen\n    _LOGGER.debug(\"Screenshot saved as '%s'\", abs_path)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.capture_screenshot(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.capture_screenshot(name)","title":"<code>name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.capture_screenshot(ext)","title":"<code>ext</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.on_exception","title":"on_exception","text":"<pre><code>on_exception(exception: Exception, driver: WebDriver) -&gt; None\n</code></pre> <p>Capture screenshot on exception.</p> <p>Parameters:</p> Name Type Description Default <code>Exception</code> <p>unused</p> required <code>WebDriver</code> <p>web driver</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def on_exception(\n    self,\n    exception: Exception,  # noqa: ARG002\n    driver: WebDriver,\n) -&gt; None:\n    \"\"\"Capture screenshot on exception.\n\n    :param exception: unused\n    :type exception: Exception\n    :param driver: web driver\n    :type driver: WebDriver\n    \"\"\"\n    self.capture_screenshot(driver, \"Exception\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.on_exception(exception)","title":"<code>exception</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.ScreenshotListener.on_exception(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.element_is_present_by_css","title":"element_is_present_by_css","text":"<pre><code>element_is_present_by_css(element_css: str) -&gt; Callable[[AnyDriver], WebElement | bool]\n</code></pre> <p>Determine if element is present by its css selector.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>element css selector</p> required <p>Returns:</p> Type Description <code>Callable[[EC.AnyDriver], WebDriver | EventFiringWebDriver]</code> <p>True if element is present, False otherwise</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def element_is_present_by_css(\n    element_css: str,\n) -&gt; Callable[[EC.AnyDriver], WebElement | bool]:  # type: ignore[name-defined]\n    \"\"\"Determine if element is present by its css selector.\n\n    :param element_css: element css selector\n    :type element_css: str\n    :return: True if element is present, False otherwise\n    :rtype: Callable[[EC.AnyDriver], WebDriver | EventFiringWebDriver]\n    \"\"\"\n    return EC.presence_of_element_located((By.CSS_SELECTOR, element_css))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.element_is_present_by_css(element_css)","title":"<code>element_css</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.firefox_webproxy_driver","title":"firefox_webproxy_driver","text":"<pre><code>firefox_webproxy_driver(\n    http_proxy: str, default_delay: int, headless: bool = False\n) -&gt; Firefox\n</code></pre> <p>Initialize proxy firefox webdriver.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>proxy ip and port number</p> required <code>int</code> <p>selenium default delay in seconds</p> required <code>bool</code> <p>headless state, default to False</p> <code>False</code> <p>Returns:</p> Type Description <code>Firefox</code> <p>gui selenium web driver instance</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def firefox_webproxy_driver(\n    http_proxy: str, default_delay: int, headless: bool = False\n) -&gt; Firefox:\n    \"\"\"Initialize proxy firefox webdriver.\n\n    :param http_proxy: proxy ip and port number\n    :type http_proxy: str\n    :param default_delay: selenium default delay in seconds\n    :type default_delay: int\n    :param headless: headless state, default to False\n    :type headless: bool\n    :return: gui selenium web driver instance\n    :rtype: Firefox\n    \"\"\"\n    options = Options()\n    if headless:\n        options.add_argument(\"--headless\")\n    if http_proxy:\n        gateway_ip, port = http_proxy.split(\":\")\n        options.set_preference(\"network.proxy.type\", 1)\n        options.set_preference(\"network.proxy.socks\", gateway_ip)\n        options.set_preference(\"network.proxy.socks_port\", int(port))\n        options.set_preference(\"network.proxy.socks_version\", 5)\n        options.set_preference(\"network.proxy.socks_remote_dns\", True)\n    options.set_preference(\"security.enterprise_roots.enabled\", True)\n    # number 2 is to save the file to the above current location instead of downloads\n    options.set_preference(\"browser.download.folderList\", 2)\n    # added the download dir as /tmp\n    options.set_preference(\"browser.download.dir\", \"/tmp\")  # noqa: S108\n    # open the file without asking any questions\n    options.set_preference(\n        \"browser.helperApps.neverAsk.openFile\",\n        (\n            \"text/anytext,text/comma-separated-values,\"\n            \"text/csv,application/octet-stream,text/plain\"\n        ),\n    )\n    # save the file without asking any questions\n    options.set_preference(\"browser.helperApps.neverAsk.saveToDisk\", \"text/plain\")\n    options.headless = headless  # type: ignore[attr-defined]\n    # Make DEBUG logs less polluted with selenium.webdriver.remote.remote_connection\n    # and urllib3.connectionpool messages\n    LOGGER.setLevel(logging.WARNING)\n    log.setLevel(logging.WARNING)\n    driver = Firefox(options=options)\n    driver.implicitly_wait(default_delay)\n    driver.set_page_load_timeout(default_delay)\n    return driver\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.firefox_webproxy_driver(http_proxy)","title":"<code>http_proxy</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.firefox_webproxy_driver(default_delay)","title":"<code>default_delay</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.firefox_webproxy_driver(headless)","title":"<code>headless</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.get_web_driver","title":"get_web_driver","text":"<pre><code>get_web_driver(\n    device: LAN | WAN | WLAN, default_delay: int, headless: bool = True\n) -&gt; WebDriver\n</code></pre> <p>Return proxy webdriver.</p> <p>Http proxy (dante) must be running on provided device.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>int</code> <p>default delay in seconds</p> required <code>bool</code> <p>headless state, default to True</p> <code>True</code> <p>Returns:</p> Type Description <code>WebDriver</code> <p>configured Firefox webdriver instance</p> Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def get_web_driver(\n    device: LAN | WAN | WLAN,\n    default_delay: int,\n    headless: bool = True,\n) -&gt; WebDriver:\n    \"\"\"Return proxy webdriver.\n\n    Http proxy (dante) must be running on provided device.\n\n    :param device: device instance\n    :type device: LAN | WAN | WLAN\n    :param default_delay: default delay in seconds\n    :type default_delay: int\n    :param headless: headless state, default to True\n    :type headless: bool\n    :return: configured Firefox webdriver instance\n    :rtype: WebDriver\n    \"\"\"\n    webdriver = firefox_webproxy_driver(\n        http_proxy=device.http_proxy,\n        default_delay=default_delay,\n        headless=headless,\n    )\n    webdriver.maximize_window()\n    return webdriver\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.get_web_driver(device)","title":"<code>device</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.get_web_driver(default_delay)","title":"<code>default_delay</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.get_web_driver(headless)","title":"<code>headless</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.save_screenshot","title":"save_screenshot","text":"<pre><code>save_screenshot(driver: WebDriver | EventFiringWebDriver) -&gt; None\n</code></pre> <p>Save screenshot of the driver window.</p> <p>Parameters:</p> Name Type Description Default <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required Source code in <code>boardfarm3/lib/gui/gui_helper.py</code> <pre><code>def save_screenshot(driver: WebDriver | EventFiringWebDriver) -&gt; None:\n    \"\"\"Save screenshot of the driver window.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    \"\"\"\n    total_width = driver.execute_script(\"return document.body.parentNode.scrollWidth\")\n    total_height = driver.execute_script(\"return document.body.parentNode.scrollHeight\")\n    # Setting screen size twice because one is not enough for Selenium :)\n    driver.set_window_size(total_width, total_height)\n    driver.set_window_size(total_width, total_height)\n    path = (\n        \"_\".join(\n            [\n                driver.screenshot_path,  # type: ignore[union-attr]\n                datetime.now(tz=UTC).strftime(\"%Y%m%d_%H%M%S%f\"),\n            ]\n        )\n        + \"_exception.png\"\n    )\n    driver.get_screenshot_as_file(path)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.gui_helper.save_screenshot(driver)","title":"<code>driver</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.gui.prplos","title":"prplos","text":"<p>Keep ruff happy.</p> <p>Modules:</p> Name Description <code>pages</code> <p>Keep ruff happy.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages","title":"pages","text":"<p>Keep ruff happy.</p> <p>Modules:</p> Name Description <code>home</code> <p>PrplOS GUI Home Page.</p> <code>lcm</code> <p>PrplOS GUI LCM Page.</p> <code>login</code> <p>Login Page POM.</p> <code>page_helper</code> <p>Page Helper Module.</p> <code>prplos_base_pom</code> <p>PrplOS Base Page Oobject Module (POM).</p> <code>wan</code> <p>PrplOS GUI WAN Page.</p> <code>wifi</code> <p>PrplOS GUI WiFi Page.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.home","title":"home","text":"<p>PrplOS GUI Home Page.</p> <p>Classes:</p> Name Description <code>HomePage</code> <p>Page Object for Home page.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.home.HomePage","title":"HomePage","text":"<pre><code>HomePage(\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n)\n</code></pre> <p>Page Object for Home page.</p> <p>Initialize HomePage POM.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <code>gw_ip</code> <code>str | IPv4Address</code> <p>gateway ip address</p> required <code>fluent_wait</code> <code>int</code> <p>timeout in seconds to load the page, defaults to 20</p> <code>20</code> <p>Methods:</p> Name Description <code>__getattribute__</code> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <code>click_networking_submenu</code> <p>Ckick on WAN menu option.</p> <code>is_page_loaded</code> <p>Verify the home page is completely loaded.</p> <code>logout</code> <p>Log out.</p> <code>wait_until_loaded</code> <p>Wait until the page is loaded completely.</p> <p>Attributes:</p> Name Type Description <code>cpu_info_element</code> <code>WebElement</code> <p>CPU info box.</p> <code>memory_info_element</code> <code>WebElement</code> <p>Memory info box.</p> <code>system_info_element</code> <code>WebElement</code> <p>System info box.</p> <code>wan_info_element</code> <code>WebElement</code> <p>WAN info element.</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/home.py</code> <pre><code>def __init__(\n    self,\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n) -&gt; None:\n    \"\"\"Initialize HomePage POM.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :param gw_ip: gateway ip address\n    :type gw_ip: str | IPv4Address\n    :param fluent_wait: timeout in seconds to load the page, defaults to 20\n    :type fluent_wait: int\n    \"\"\"\n    super().__init__(driver, gw_ip, fluent_wait)\n    self.wait.until(self.is_page_loaded)\n</code></pre> <code></code> cpu_info_element <code>property</code> <pre><code>cpu_info_element: WebElement\n</code></pre> <p>CPU info box.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <code></code> memory_info_element <code>property</code> <pre><code>memory_info_element: WebElement\n</code></pre> <p>Memory info box.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <code></code> system_info_element <code>property</code> <pre><code>system_info_element: WebElement\n</code></pre> <p>System info box.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <code></code> wan_info_element <code>property</code> <pre><code>wan_info_element: WebElement\n</code></pre> <p>WAN info element.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <code></code> __getattribute__ <pre><code>__getattribute__(name: str) -&gt; None\n</code></pre> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute</p> required <p>Returns:</p> Type Description <code>related to the attribute</code> <p>the attribute value</p> <p>Raises:</p> Type Description <code>TimeoutException</code> <p>if the attr was not found</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; None:\n    \"\"\"Take a screenshot and save to a folder upon TimeoutException.\n\n    :param name: the attribute\n    :type name: str\n    :return: the attribute value\n    :rtype: related to the attribute\n    :raises TimeoutException: if the attr was not found\n    \"\"\"\n    try:\n        return super().__getattribute__(name)\n    except TimeoutException:\n        now = datetime.now(UTC)\n        sc_path = (\n            \"_\".join(\n                [\n                    self.driver.screenshot_path,  # type: ignore[union-attr]\n                    now.strftime(\"%Y%m%d_%H%M%S%f\"),\n                ],\n            )\n            + \"_TimeoutException.png\"\n        )\n        self.driver.get_screenshot_as_file(sc_path)\n        _LOGGER.debug(\"Screenshot saved as '%s'\", sc_path)\n        raise\n</code></pre> <code></code> click_networking_submenu <pre><code>click_networking_submenu(element: WebElement) -&gt; None\n</code></pre> <p>Ckick on WAN menu option.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>the element to click</p> required Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def click_networking_submenu(self, element: WebElement) -&gt; None:\n    \"\"\"Ckick on WAN menu option.\n\n    :param element: the element to click\n    :type element: WebElement\n    \"\"\"\n    self.actions.move_to_element(  # type: ignore[attr-defined]\n        element,\n    ).pause(1).click().perform()\n    time.sleep(1)\n</code></pre> <code></code> is_page_loaded <pre><code>is_page_loaded(driver: WebDriver | EventFiringWebDriver) -&gt; bool\n</code></pre> <p>Verify the home page is completely loaded.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if home page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/home.py</code> <pre><code>def is_page_loaded(self, driver: WebDriver | EventFiringWebDriver) -&gt; bool:\n    \"\"\"Verify the home page is completely loaded.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :return: True if home page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return self.system_info_element.is_displayed() and driver.execute_script(\n        \"return document.readyState == 'complete'\"\n    )\n</code></pre> <code></code> logout <pre><code>logout() -&gt; None\n</code></pre> <p>Log out.</p> <p>All the pages derived from the POM have logged in!</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Log out.\n\n    All the pages derived from the POM have logged in!\n    \"\"\"\n    get_element_by_css(self, \".btn\").click()\n    get_element_by_css(self, \".logo\")\n</code></pre> <code></code> wait_until_loaded <pre><code>wait_until_loaded(timeout: int | None = None) -&gt; bool\n</code></pre> <p>Wait until the page is loaded completely.</p> <p>Generic method to wait upto fluent_wait time or upto timeout specified by the user until the page is loaded and return the status</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>timeout in seconds to load the page, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def wait_until_loaded(self, timeout: int | None = None) -&gt; bool:\n    \"\"\"Wait until the page is loaded completely.\n\n    Generic method to wait upto fluent_wait time or upto timeout specified\n    by the user until the page is loaded and return the status\n\n    :param timeout: timeout in seconds to load the page, defaults to None\n    :type timeout: int | None, default None\n    :return: True if page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return wait_until_loaded(self, timeout)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.lcm","title":"lcm","text":"<p>PrplOS GUI LCM Page.</p> <p>Classes:</p> Name Description <code>LCMPage</code> <p>Page Object for LCM page.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.lcm.LCMPage","title":"LCMPage","text":"<pre><code>LCMPage(\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n)\n</code></pre> <p>Page Object for LCM page.</p> <p>Initialize LCMPage POM.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <code>gw_ip</code> <code>str | IPv4Address</code> <p>gateway ip address</p> required <code>fluent_wait</code> <code>int</code> <p>timeout in seconds to load the page, defaults to 20</p> <code>20</code> <p>Methods:</p> Name Description <code>__getattribute__</code> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <code>click_networking_submenu</code> <p>Ckick on WAN menu option.</p> <code>is_page_loaded</code> <p>Verify the home page is completely loaded.</p> <code>logout</code> <p>Log out.</p> <code>wait_until_loaded</code> <p>Wait until the page is loaded completely.</p> <p>Attributes:</p> Name Type Description <code>networking_lcm_header</code> <code>WebElement</code> <p>The LCM header element.</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/lcm.py</code> <pre><code>def __init__(\n    self,\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n) -&gt; None:\n    \"\"\"Initialize LCMPage POM.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :param gw_ip: gateway ip address\n    :type gw_ip: str | IPv4Address\n    :param fluent_wait: timeout in seconds to load the page, defaults to 20\n    :type fluent_wait: int\n    \"\"\"\n    super().__init__(driver, gw_ip, fluent_wait)\n    try:\n        if self.networking_lcm_header.is_displayed():\n            return  # Do not click open sub-menu if it is already open\n    except NoSuchElementException:\n        pass\n    self.click_networking_submenu(get_element_by_css(self, _SUBMENU_CSS))\n    self.wait.until(self.is_page_loaded)\n</code></pre> <code></code> networking_lcm_header <code>property</code> <pre><code>networking_lcm_header: WebElement\n</code></pre> <p>The LCM header element.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <p>Raises:</p> Type Description <code>NoSuchElementException</code> <p>if not found</p> <code></code> __getattribute__ <pre><code>__getattribute__(name: str) -&gt; None\n</code></pre> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute</p> required <p>Returns:</p> Type Description <code>related to the attribute</code> <p>the attribute value</p> <p>Raises:</p> Type Description <code>TimeoutException</code> <p>if the attr was not found</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; None:\n    \"\"\"Take a screenshot and save to a folder upon TimeoutException.\n\n    :param name: the attribute\n    :type name: str\n    :return: the attribute value\n    :rtype: related to the attribute\n    :raises TimeoutException: if the attr was not found\n    \"\"\"\n    try:\n        return super().__getattribute__(name)\n    except TimeoutException:\n        now = datetime.now(UTC)\n        sc_path = (\n            \"_\".join(\n                [\n                    self.driver.screenshot_path,  # type: ignore[union-attr]\n                    now.strftime(\"%Y%m%d_%H%M%S%f\"),\n                ],\n            )\n            + \"_TimeoutException.png\"\n        )\n        self.driver.get_screenshot_as_file(sc_path)\n        _LOGGER.debug(\"Screenshot saved as '%s'\", sc_path)\n        raise\n</code></pre> <code></code> click_networking_submenu <pre><code>click_networking_submenu(element: WebElement) -&gt; None\n</code></pre> <p>Ckick on WAN menu option.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>the element to click</p> required Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def click_networking_submenu(self, element: WebElement) -&gt; None:\n    \"\"\"Ckick on WAN menu option.\n\n    :param element: the element to click\n    :type element: WebElement\n    \"\"\"\n    self.actions.move_to_element(  # type: ignore[attr-defined]\n        element,\n    ).pause(1).click().perform()\n    time.sleep(1)\n</code></pre> <code></code> is_page_loaded <pre><code>is_page_loaded(driver: WebDriver | EventFiringWebDriver) -&gt; bool\n</code></pre> <p>Verify the home page is completely loaded.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if home page is loaded</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/lcm.py</code> <pre><code>def is_page_loaded(self, driver: WebDriver | EventFiringWebDriver) -&gt; bool:\n    \"\"\"Verify the home page is completely loaded.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :return: True if home page is loaded\n    :rtype: bool\n    \"\"\"\n    return self.networking_lcm_header.is_displayed() and driver.execute_script(\n        \"return document.readyState == 'complete'\"\n    )\n</code></pre> <code></code> logout <pre><code>logout() -&gt; None\n</code></pre> <p>Log out.</p> <p>All the pages derived from the POM have logged in!</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Log out.\n\n    All the pages derived from the POM have logged in!\n    \"\"\"\n    get_element_by_css(self, \".btn\").click()\n    get_element_by_css(self, \".logo\")\n</code></pre> <code></code> wait_until_loaded <pre><code>wait_until_loaded(timeout: int | None = None) -&gt; bool\n</code></pre> <p>Wait until the page is loaded completely.</p> <p>Generic method to wait upto fluent_wait time or upto timeout specified by the user until the page is loaded and return the status</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>timeout in seconds to load the page, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def wait_until_loaded(self, timeout: int | None = None) -&gt; bool:\n    \"\"\"Wait until the page is loaded completely.\n\n    Generic method to wait upto fluent_wait time or upto timeout specified\n    by the user until the page is loaded and return the status\n\n    :param timeout: timeout in seconds to load the page, defaults to None\n    :type timeout: int | None, default None\n    :return: True if page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return wait_until_loaded(self, timeout)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.login","title":"login","text":"<p>Login Page POM.</p> <p>Classes:</p> Name Description <code>LoginPage</code> <p>Page Object for Login page.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.login.LoginPage","title":"LoginPage","text":"<pre><code>LoginPage(\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n    use_https: bool = False,\n)\n</code></pre> <p>Page Object for Login page.</p> <p>Initialize LoginPage POM.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <code>gw_ip</code> <code>str | IPv4Address</code> <p>gateway ip address</p> required <code>fluent_wait</code> <code>int</code> <p>timeout in seconds to load the page, defaults to 20</p> <code>20</code> <code>use_https</code> <code>bool</code> <p>whether to use http/s, defaults to False</p> <code>False</code> <p>Methods:</p> Name Description <code>is_page_loaded</code> <p>Verify the home page is completely loaded.</p> <code>login</code> <p>Login to the UI.</p> <p>Attributes:</p> Name Type Description <code>logo_element</code> <code>WebElement</code> <p>Logo element.</p> <code>password_box_element</code> <code>WebElement</code> <p>Password textbox element.</p> <code>username_box_element</code> <code>WebElement</code> <p>Username textbox element.</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/login.py</code> <pre><code>def __init__(\n    self,\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n    use_https: bool = False,\n) -&gt; None:\n    \"\"\"Initialize LoginPage POM.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :param gw_ip: gateway ip address\n    :type gw_ip: str | IPv4Address\n    :param fluent_wait: timeout in seconds to load the page, defaults to 20\n    :type fluent_wait: int\n    :param use_https: whether to use http/s, defaults to False\n    :type use_https: bool\n    \"\"\"\n    self.driver = driver\n    self.wait = WebDriverWait(\n        driver=self.driver,  # type: ignore[type-var]\n        timeout=fluent_wait,\n    )\n    self.actions = ActionChains(\n        driver if isinstance(driver, WebDriver) else driver.wrapped_driver\n    )\n    self.fluent_wait = fluent_wait\n    if str(gw_ip) not in self.driver.current_url:\n        self.driver.get(f\"https://{gw_ip}\" if use_https else f\"http://{gw_ip}\")\n    driver.set_page_load_timeout(fluent_wait * 4)  # type: ignore[union-attr]\n    self.wait.until(self.is_page_loaded)\n</code></pre> <code></code> logo_element <code>property</code> <pre><code>logo_element: WebElement\n</code></pre> <p>Logo element.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>The web element</p> <code></code> password_box_element <code>property</code> <pre><code>password_box_element: WebElement\n</code></pre> <p>Password textbox element.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>The web element</p> <code></code> username_box_element <code>property</code> <pre><code>username_box_element: WebElement\n</code></pre> <p>Username textbox element.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>The web element</p> <code></code> is_page_loaded <pre><code>is_page_loaded(driver: WebDriver | EventFiringWebDriver) -&gt; bool\n</code></pre> <p>Verify the home page is completely loaded.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if home page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/login.py</code> <pre><code>def is_page_loaded(self, driver: WebDriver | EventFiringWebDriver) -&gt; bool:\n    \"\"\"Verify the home page is completely loaded.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :return: True if home page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return (\n        self.logo_element.is_displayed()\n        and self.username_box_element.is_displayed()\n        and self.password_box_element.is_displayed()\n        and driver.execute_script(\"return document.readyState == 'complete'\")\n    )\n</code></pre> <code></code> login <pre><code>login(user: str, password: str) -&gt; None\n</code></pre> <p>Login to the UI.</p> <p>Login to the UI or if the UI is not at the Login page then performs first installation operation</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>login username</p> required <code>password</code> <code>str</code> <p>login password</p> required Source code in <code>boardfarm3/lib/gui/prplos/pages/login.py</code> <pre><code>def login(self, user: str, password: str) -&gt; None:\n    \"\"\"Login to the UI.\n\n    Login to the UI or if the UI is not at the Login page then performs\n    first installation operation\n\n    :param user: login username\n    :type user: str\n    :param password: login password\n    :type password: str\n    \"\"\"\n    self.username_box_element.send_keys(user)\n    self.username_box_element.send_keys(Keys.ENTER)\n    self.password_box_element.send_keys(password)\n    self.password_box_element.send_keys(Keys.ENTER)\n    self._wait_until_logged_in()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.page_helper","title":"page_helper","text":"<p>Page Helper Module.</p> <p>Functions:</p> Name Description <code>get_element_by_css</code> <p>Get an element by CSS selector (wait if needed).</p> <code>initialize</code> <p>Initialize the page obj.</p> <code>wait_until_loaded</code> <p>Wait until the page is loaded completely.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.page_helper.get_element_by_css","title":"get_element_by_css","text":"<pre><code>get_element_by_css(page: Any, element: str) -&gt; WebElement\n</code></pre> <p>Get an element by CSS selector (wait if needed).</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Any</code> <p>the webpage</p> required <code>element</code> <code>str</code> <p>the element</p> required <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <p>Raises:</p> Type Description <code>NoSuchElementException</code> <p>if the element is not found</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/page_helper.py</code> <pre><code>def get_element_by_css(page: Any, element: str) -&gt; WebElement:  # noqa: ANN401\n    \"\"\"Get an element by CSS selector (wait if needed).\n\n    :param page: the webpage\n    :type page: Any\n    :param element: the element\n    :type element: str\n    :raises NoSuchElementException: if the element is not found\n    :return: the web element\n    :rtype: WebElement\n    \"\"\"\n    if page.wait.until(element_is_present_by_css(element)):\n        return page.driver.find_element(by=By.CSS_SELECTOR, value=element)\n    msg = f\"{element} not found in {page.driver.current_url}\"\n    raise NoSuchElementException(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.page_helper.initialize","title":"initialize","text":"<pre><code>initialize(\n    page: Any,\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n    use_https: bool = False,\n    user: str = PRPLOS_USER,\n    password: str = PRPLOS_PASSWORD,\n) -&gt; None\n</code></pre> <p>Initialize the page obj.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Any</code> <p>the page</p> required <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>the web driver</p> required <code>gw_ip</code> <code>str | IPv4Address</code> <p>the gateway ip</p> required <code>fluent_wait</code> <code>int</code> <p>browser fluent wait, defaults to 20</p> <code>20</code> <code>use_https</code> <code>bool</code> <p>use htpp/s, defaults to False</p> <code>False</code> <code>user</code> <code>str</code> <p>username, defaults to admin</p> <code>PRPLOS_USER</code> <code>password</code> <code>str</code> <p>login password, defaults to admin</p> <code>PRPLOS_PASSWORD</code> Source code in <code>boardfarm3/lib/gui/prplos/pages/page_helper.py</code> <pre><code>def initialize(  # noqa: PLR0913\n    page: Any,  # noqa: ANN401\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n    use_https: bool = False,\n    user: str = PRPLOS_USER,\n    password: str = PRPLOS_PASSWORD,\n) -&gt; None:\n    \"\"\"Initialize the page obj.\n\n    :param page: the page\n    :type page: Any\n    :param driver: the web driver\n    :type driver: WebDriver | EventFiringWebDriver\n    :param gw_ip: the gateway ip\n    :type gw_ip: str | IPv4Address\n    :param fluent_wait: browser fluent wait, defaults to 20\n    :type fluent_wait: int\n    :param use_https: use htpp/s, defaults to False\n    :type use_https: bool\n    :param user: username, defaults to admin\n    :type user: str\n    :param password: login password, defaults to admin\n    :type password: str\n    \"\"\"\n    page.driver = driver\n    page.wait = WebDriverWait(\n        driver=page.driver,  # type: ignore[type-var]\n        timeout=fluent_wait,\n    )\n    page.actions = ActionChains(\n        driver if isinstance(driver, WebDriver) else driver.wrapped_driver\n    )\n    page.fluent_wait = fluent_wait\n    if str(gw_ip) not in page.driver.current_url:\n        page.driver.get(f\"https://{gw_ip}\" if use_https else f\"http://{gw_ip}\")\n    driver.set_page_load_timeout(fluent_wait * 4)\n    if not isinstance(page, LoginPage):\n        loginpage = LoginPage(page.driver, gw_ip)\n        wait_until_loaded(loginpage)\n        loginpage.login(user, password)\n        return\n\n    page.wait.until(page.is_page_loaded)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.page_helper.wait_until_loaded","title":"wait_until_loaded","text":"<pre><code>wait_until_loaded(page: Any, timeout: int | None = None) -&gt; bool\n</code></pre> <p>Wait until the page is loaded completely.</p> <p>Generic method to wait upto fluent_wait time or upto timeout specified by the user until the page is loaded and return the status</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Any</code> <p>the page obj</p> required <code>timeout</code> <code>int | None</code> <p>timeout in seconds to load the page, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if page is loaded</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/page_helper.py</code> <pre><code>def wait_until_loaded(page: Any, timeout: int | None = None) -&gt; bool:  # noqa: ANN401\n    \"\"\"Wait until the page is loaded completely.\n\n    Generic method to wait upto fluent_wait time or upto timeout specified\n    by the user until the page is loaded and return the status\n\n    :param page: the page obj\n    :type page: Any\n    :param timeout: timeout in seconds to load the page, defaults to None\n    :type timeout: int | None\n    :return: True if page is loaded\n    :rtype: bool\n    \"\"\"\n    if not timeout:\n        timeout = page.fluent_wait\n    timeout = int(time.time()) + timeout\n    output = False\n    while int(time.time()) &lt;= timeout and not output:\n        try:\n            output = page.is_page_loaded(page.driver)  # pylint: disable=E1111\n        except (  # noqa: PERF203\n            NoSuchElementException,\n            TimeoutException,\n            StaleElementReferenceException,\n        ):\n            output = False\n    if not output:\n        save_screenshot(page.driver)\n    return output\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.prplos_base_pom","title":"prplos_base_pom","text":"<p>PrplOS Base Page Oobject Module (POM).</p> <p>Classes:</p> Name Description <code>PrplOSBasePOM</code> <p>Contains objects that are common to all the pages of the PrplOS GUI.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.prplos_base_pom.PrplOSBasePOM","title":"PrplOSBasePOM","text":"<pre><code>PrplOSBasePOM(\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n    use_https: bool = False,\n)\n</code></pre> <p>Contains objects that are common to all the pages of the PrplOS GUI.</p> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <code>gw_ip</code> <code>str | IPv4Address</code> <p>gateway ip address</p> required <code>fluent_wait</code> <code>int</code> <p>timeout in seconds to load the page, defaults to 20</p> <code>20</code> <code>use_https</code> <code>bool</code> <p>flag to specify whether http or https, defaults to false</p> <code>False</code> <p>Methods:</p> Name Description <code>__getattribute__</code> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <code>click_networking_submenu</code> <p>Ckick on WAN menu option.</p> <code>is_page_loaded</code> <p>Verify the page is completely loaded.</p> <code>logout</code> <p>Log out.</p> <code>wait_until_loaded</code> <p>Wait until the page is loaded completely.</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def __init__(\n    self,\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n    use_https: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the class.\n\n    :param driver: webdriver instance\n    :type driver: Union[WebDriver, EventFiringWebDriver]\n    :param gw_ip: gateway ip address\n    :type gw_ip: Union[str, IPv4Address]\n    :param fluent_wait: timeout in seconds to load the page, defaults to 20\n    :type fluent_wait: int\n    :param use_https: flag to specify whether http or https, defaults to false\n    :type use_https: bool\n    \"\"\"\n    initialize(\n        page=self,\n        driver=driver,\n        gw_ip=gw_ip,\n        fluent_wait=fluent_wait,\n        use_https=use_https,\n    )\n</code></pre> <code></code> __getattribute__ <pre><code>__getattribute__(name: str) -&gt; None\n</code></pre> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute</p> required <p>Returns:</p> Type Description <code>related to the attribute</code> <p>the attribute value</p> <p>Raises:</p> Type Description <code>TimeoutException</code> <p>if the attr was not found</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; None:\n    \"\"\"Take a screenshot and save to a folder upon TimeoutException.\n\n    :param name: the attribute\n    :type name: str\n    :return: the attribute value\n    :rtype: related to the attribute\n    :raises TimeoutException: if the attr was not found\n    \"\"\"\n    try:\n        return super().__getattribute__(name)\n    except TimeoutException:\n        now = datetime.now(UTC)\n        sc_path = (\n            \"_\".join(\n                [\n                    self.driver.screenshot_path,  # type: ignore[union-attr]\n                    now.strftime(\"%Y%m%d_%H%M%S%f\"),\n                ],\n            )\n            + \"_TimeoutException.png\"\n        )\n        self.driver.get_screenshot_as_file(sc_path)\n        _LOGGER.debug(\"Screenshot saved as '%s'\", sc_path)\n        raise\n</code></pre> <code></code> click_networking_submenu <pre><code>click_networking_submenu(element: WebElement) -&gt; None\n</code></pre> <p>Ckick on WAN menu option.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>the element to click</p> required Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def click_networking_submenu(self, element: WebElement) -&gt; None:\n    \"\"\"Ckick on WAN menu option.\n\n    :param element: the element to click\n    :type element: WebElement\n    \"\"\"\n    self.actions.move_to_element(  # type: ignore[attr-defined]\n        element,\n    ).pause(1).click().perform()\n    time.sleep(1)\n</code></pre> <code></code> is_page_loaded <pre><code>is_page_loaded(_driver: WebDriver | EventFiringWebDriver) -&gt; bool\n</code></pre> <p>Verify the page is completely loaded.</p> <p>Must be overridden  in the derived class!</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if not overriden</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def is_page_loaded(\n    self,\n    _driver: WebDriver | EventFiringWebDriver,\n) -&gt; bool:\n    \"\"\"Verify the page is completely loaded.\n\n    Must be overridden  in the derived class!\n\n    :raises AttributeError: if not overriden\n    \"\"\"\n    msg = \"is_page_loaded must be defined in derived class\"\n    raise AttributeError(msg)\n</code></pre> <code></code> logout <pre><code>logout() -&gt; None\n</code></pre> <p>Log out.</p> <p>All the pages derived from the POM have logged in!</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Log out.\n\n    All the pages derived from the POM have logged in!\n    \"\"\"\n    get_element_by_css(self, \".btn\").click()\n    get_element_by_css(self, \".logo\")\n</code></pre> <code></code> wait_until_loaded <pre><code>wait_until_loaded(timeout: int | None = None) -&gt; bool\n</code></pre> <p>Wait until the page is loaded completely.</p> <p>Generic method to wait upto fluent_wait time or upto timeout specified by the user until the page is loaded and return the status</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>timeout in seconds to load the page, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def wait_until_loaded(self, timeout: int | None = None) -&gt; bool:\n    \"\"\"Wait until the page is loaded completely.\n\n    Generic method to wait upto fluent_wait time or upto timeout specified\n    by the user until the page is loaded and return the status\n\n    :param timeout: timeout in seconds to load the page, defaults to None\n    :type timeout: int | None, default None\n    :return: True if page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return wait_until_loaded(self, timeout)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.wan","title":"wan","text":"<p>PrplOS GUI WAN Page.</p> <p>Classes:</p> Name Description <code>WANPage</code> <p>Page Object for WAN page.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.wan.WANPage","title":"WANPage","text":"<pre><code>WANPage(\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n)\n</code></pre> <p>Page Object for WAN page.</p> <p>Initialize WANPage POM.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <code>gw_ip</code> <code>str | IPv4Address</code> <p>gateway ip address</p> required <code>fluent_wait</code> <code>int</code> <p>timeout in seconds to load the page, defaults to 20</p> <code>20</code> <p>Methods:</p> Name Description <code>__getattribute__</code> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <code>click_networking_submenu</code> <p>Ckick on WAN menu option.</p> <code>is_page_loaded</code> <p>Verify the home page is completely loaded.</p> <code>logout</code> <p>Log out.</p> <code>wait_until_loaded</code> <p>Wait until the page is loaded completely.</p> <p>Attributes:</p> Name Type Description <code>networking_wan_header</code> <code>WebElement</code> <p>The WAN header element.</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/wan.py</code> <pre><code>def __init__(\n    self,\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n) -&gt; None:\n    \"\"\"Initialize WANPage POM.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :param gw_ip: gateway ip address\n    :type gw_ip: str | IPv4Address\n    :param fluent_wait: timeout in seconds to load the page, defaults to 20\n    :type fluent_wait: int\n    \"\"\"\n    super().__init__(driver, gw_ip, fluent_wait)\n    try:\n        if self.networking_wan_header.is_displayed():\n            return  # Do not click open sub-menu if it is already open\n    except NoSuchElementException:\n        pass\n    self.click_networking_submenu(get_element_by_css(self, _SUBMENU_CSS))\n    self.wait.until(self.is_page_loaded)\n</code></pre> <code></code> networking_wan_header <code>property</code> <pre><code>networking_wan_header: WebElement\n</code></pre> <p>The WAN header element.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <p>Raises:</p> Type Description <code>NoSuchElementException</code> <p>if the correct header is not found</p> <code></code> __getattribute__ <pre><code>__getattribute__(name: str) -&gt; None\n</code></pre> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute</p> required <p>Returns:</p> Type Description <code>related to the attribute</code> <p>the attribute value</p> <p>Raises:</p> Type Description <code>TimeoutException</code> <p>if the attr was not found</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; None:\n    \"\"\"Take a screenshot and save to a folder upon TimeoutException.\n\n    :param name: the attribute\n    :type name: str\n    :return: the attribute value\n    :rtype: related to the attribute\n    :raises TimeoutException: if the attr was not found\n    \"\"\"\n    try:\n        return super().__getattribute__(name)\n    except TimeoutException:\n        now = datetime.now(UTC)\n        sc_path = (\n            \"_\".join(\n                [\n                    self.driver.screenshot_path,  # type: ignore[union-attr]\n                    now.strftime(\"%Y%m%d_%H%M%S%f\"),\n                ],\n            )\n            + \"_TimeoutException.png\"\n        )\n        self.driver.get_screenshot_as_file(sc_path)\n        _LOGGER.debug(\"Screenshot saved as '%s'\", sc_path)\n        raise\n</code></pre> <code></code> click_networking_submenu <pre><code>click_networking_submenu(element: WebElement) -&gt; None\n</code></pre> <p>Ckick on WAN menu option.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>the element to click</p> required Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def click_networking_submenu(self, element: WebElement) -&gt; None:\n    \"\"\"Ckick on WAN menu option.\n\n    :param element: the element to click\n    :type element: WebElement\n    \"\"\"\n    self.actions.move_to_element(  # type: ignore[attr-defined]\n        element,\n    ).pause(1).click().perform()\n    time.sleep(1)\n</code></pre> <code></code> is_page_loaded <pre><code>is_page_loaded(driver: WebDriver | EventFiringWebDriver) -&gt; bool\n</code></pre> <p>Verify the home page is completely loaded.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if home page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/wan.py</code> <pre><code>def is_page_loaded(self, driver: WebDriver | EventFiringWebDriver) -&gt; bool:\n    \"\"\"Verify the home page is completely loaded.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :return: True if home page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return self.networking_wan_header.is_displayed() and driver.execute_script(\n        \"return document.readyState == 'complete'\"\n    )\n</code></pre> <code></code> logout <pre><code>logout() -&gt; None\n</code></pre> <p>Log out.</p> <p>All the pages derived from the POM have logged in!</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Log out.\n\n    All the pages derived from the POM have logged in!\n    \"\"\"\n    get_element_by_css(self, \".btn\").click()\n    get_element_by_css(self, \".logo\")\n</code></pre> <code></code> wait_until_loaded <pre><code>wait_until_loaded(timeout: int | None = None) -&gt; bool\n</code></pre> <p>Wait until the page is loaded completely.</p> <p>Generic method to wait upto fluent_wait time or upto timeout specified by the user until the page is loaded and return the status</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>timeout in seconds to load the page, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def wait_until_loaded(self, timeout: int | None = None) -&gt; bool:\n    \"\"\"Wait until the page is loaded completely.\n\n    Generic method to wait upto fluent_wait time or upto timeout specified\n    by the user until the page is loaded and return the status\n\n    :param timeout: timeout in seconds to load the page, defaults to None\n    :type timeout: int | None, default None\n    :return: True if page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return wait_until_loaded(self, timeout)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.wifi","title":"wifi","text":"<p>PrplOS GUI WiFi Page.</p> <p>Classes:</p> Name Description <code>WiFiPage</code> <p>Page Object for WiFi page.</p>"},{"location":"reference/libs/#boardfarm3.lib.gui.prplos.pages.wifi.WiFiPage","title":"WiFiPage","text":"<pre><code>WiFiPage(\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n)\n</code></pre> <p>Page Object for WiFi page.</p> <p>Initialize WiFiPage POM.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <code>gw_ip</code> <code>str | IPv4Address</code> <p>gateway ip address</p> required <code>fluent_wait</code> <code>int</code> <p>timeout in seconds to load the page, defaults to 20</p> <code>20</code> <p>Methods:</p> Name Description <code>__getattribute__</code> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <code>click_networking_submenu</code> <p>Ckick on WAN menu option.</p> <code>is_page_loaded</code> <p>Verify the home page is completely loaded.</p> <code>logout</code> <p>Log out.</p> <code>wait_until_loaded</code> <p>Wait until the page is loaded completely.</p> <p>Attributes:</p> Name Type Description <code>networking_wifi_header</code> <code>WebElement</code> <p>The WiFi header element.</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/wifi.py</code> <pre><code>def __init__(\n    self,\n    driver: WebDriver | EventFiringWebDriver,\n    gw_ip: str | IPv4Address,\n    fluent_wait: int = 20,\n) -&gt; None:\n    \"\"\"Initialize WiFiPage POM.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :param gw_ip: gateway ip address\n    :type gw_ip: str | IPv4Address\n    :param fluent_wait: timeout in seconds to load the page, defaults to 20\n    :type fluent_wait: int\n    \"\"\"\n    super().__init__(driver, gw_ip, fluent_wait)\n    try:\n        if self.networking_wifi_header.is_displayed():\n            return  # Do not click open sub-menu if it is already open\n    except NoSuchElementException:\n        pass\n    self.click_networking_submenu(get_element_by_css(self, _SUBMENU_CSS))\n    self.wait.until(self.is_page_loaded)\n</code></pre> <code></code> networking_wifi_header <code>property</code> <pre><code>networking_wifi_header: WebElement\n</code></pre> <p>The WiFi header element.</p> <p>Returns:</p> Type Description <code>WebElement</code> <p>the web element</p> <p>Raises:</p> Type Description <code>NoSuchElementException</code> <p>if not found</p> <code></code> __getattribute__ <pre><code>__getattribute__(name: str) -&gt; None\n</code></pre> <p>Take a screenshot and save to a folder upon TimeoutException.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute</p> required <p>Returns:</p> Type Description <code>related to the attribute</code> <p>the attribute value</p> <p>Raises:</p> Type Description <code>TimeoutException</code> <p>if the attr was not found</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; None:\n    \"\"\"Take a screenshot and save to a folder upon TimeoutException.\n\n    :param name: the attribute\n    :type name: str\n    :return: the attribute value\n    :rtype: related to the attribute\n    :raises TimeoutException: if the attr was not found\n    \"\"\"\n    try:\n        return super().__getattribute__(name)\n    except TimeoutException:\n        now = datetime.now(UTC)\n        sc_path = (\n            \"_\".join(\n                [\n                    self.driver.screenshot_path,  # type: ignore[union-attr]\n                    now.strftime(\"%Y%m%d_%H%M%S%f\"),\n                ],\n            )\n            + \"_TimeoutException.png\"\n        )\n        self.driver.get_screenshot_as_file(sc_path)\n        _LOGGER.debug(\"Screenshot saved as '%s'\", sc_path)\n        raise\n</code></pre> <code></code> click_networking_submenu <pre><code>click_networking_submenu(element: WebElement) -&gt; None\n</code></pre> <p>Ckick on WAN menu option.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>WebElement</code> <p>the element to click</p> required Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def click_networking_submenu(self, element: WebElement) -&gt; None:\n    \"\"\"Ckick on WAN menu option.\n\n    :param element: the element to click\n    :type element: WebElement\n    \"\"\"\n    self.actions.move_to_element(  # type: ignore[attr-defined]\n        element,\n    ).pause(1).click().perform()\n    time.sleep(1)\n</code></pre> <code></code> is_page_loaded <pre><code>is_page_loaded(driver: WebDriver | EventFiringWebDriver) -&gt; bool\n</code></pre> <p>Verify the home page is completely loaded.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver | EventFiringWebDriver</code> <p>webdriver instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if home page is loaded</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/wifi.py</code> <pre><code>def is_page_loaded(self, driver: WebDriver | EventFiringWebDriver) -&gt; bool:\n    \"\"\"Verify the home page is completely loaded.\n\n    :param driver: webdriver instance\n    :type driver: WebDriver | EventFiringWebDriver\n    :return: True if home page is loaded\n    :rtype: bool\n    \"\"\"\n    return self.networking_wifi_header.is_displayed() and driver.execute_script(\n        \"return document.readyState == 'complete'\"\n    )\n</code></pre> <code></code> logout <pre><code>logout() -&gt; None\n</code></pre> <p>Log out.</p> <p>All the pages derived from the POM have logged in!</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Log out.\n\n    All the pages derived from the POM have logged in!\n    \"\"\"\n    get_element_by_css(self, \".btn\").click()\n    get_element_by_css(self, \".logo\")\n</code></pre> <code></code> wait_until_loaded <pre><code>wait_until_loaded(timeout: int | None = None) -&gt; bool\n</code></pre> <p>Wait until the page is loaded completely.</p> <p>Generic method to wait upto fluent_wait time or upto timeout specified by the user until the page is loaded and return the status</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>timeout in seconds to load the page, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if page is loaded, Otherwise False</p> Source code in <code>boardfarm3/lib/gui/prplos/pages/prplos_base_pom.py</code> <pre><code>def wait_until_loaded(self, timeout: int | None = None) -&gt; bool:\n    \"\"\"Wait until the page is loaded completely.\n\n    Generic method to wait upto fluent_wait time or upto timeout specified\n    by the user until the page is loaded and return the status\n\n    :param timeout: timeout in seconds to load the page, defaults to None\n    :type timeout: int | None, default None\n    :return: True if page is loaded, Otherwise False\n    :rtype: bool\n    \"\"\"\n    return wait_until_loaded(self, timeout)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.hal","title":"hal","text":"<p>Hardware abstraction layers for different CPE components.</p> <p>Modules:</p> Name Description <code>cpe_wifi</code> <p>CPE WiFi HAL class.</p>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi","title":"cpe_wifi","text":"<p>CPE WiFi HAL class.</p> <p>Classes:</p> Name Description <code>WiFiHal</code> <p>Contain CPE Wi-Fi software methods.</p>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal","title":"WiFiHal","text":"<p>Contain CPE Wi-Fi software methods.</p> <p>Methods:</p> Name Description <code>enable_wifi</code> <p>Use Wifi Hal API to enable the wifi if not already enabled.</p> <code>get_bssid</code> <p>Get the wifi Basic Service Set Identifier.</p> <code>get_passphrase</code> <p>Get the passphrase for a network on an interface.</p> <code>get_ssid</code> <p>Get the wifi ssid for the wlan client with specific network and band.</p> <code>is_wifi_enabled</code> <p>Check if specific wifi is enabled.</p> <p>Attributes:</p> Name Type Description <code>wlan_ifaces</code> <code>dict[str, dict[str, str]]</code> <p>Get all the wlan interfaces on board.</p>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.wlan_ifaces","title":"wlan_ifaces  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>wlan_ifaces: dict[str, dict[str, str]]\n</code></pre> <p>Get all the wlan interfaces on board.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>interfaces e.g. private/guest/community</p>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.enable_wifi","title":"enable_wifi  <code>abstractmethod</code>","text":"<pre><code>enable_wifi(network: str, band: str) -&gt; tuple[str, str, str]\n</code></pre> <p>Use Wifi Hal API to enable the wifi if not already enabled.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type(private/guest/community)</p> required <code>str</code> <p>wifi band(5/2.4 GHz)</p> required <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>tuple of ssid,bssid,passphrase</p> Source code in <code>boardfarm3/lib/hal/cpe_wifi.py</code> <pre><code>@abstractmethod\ndef enable_wifi(self, network: str, band: str) -&gt; tuple[str, str, str]:\n    \"\"\"Use Wifi Hal API to enable the wifi if not already enabled.\n\n    :param network: network type(private/guest/community)\n    :type network: str\n    :param band: wifi band(5/2.4 GHz)\n    :type band: str\n    :return: tuple of ssid,bssid,passphrase\n    :rtype: tuple[str, str, str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.enable_wifi(network)","title":"<code>network</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.enable_wifi(band)","title":"<code>band</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_bssid","title":"get_bssid  <code>abstractmethod</code>","text":"<pre><code>get_bssid(network: str, band: str) -&gt; str | None\n</code></pre> <p>Get the wifi Basic Service Set Identifier.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type(private/guest/community)</p> required <code>str</code> <p>wifi band(5/2.4 GHz)</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>MAC physical address of the access point</p> Source code in <code>boardfarm3/lib/hal/cpe_wifi.py</code> <pre><code>@abstractmethod\ndef get_bssid(self, network: str, band: str) -&gt; str | None:\n    \"\"\"Get the wifi Basic Service Set Identifier.\n\n    :param network: network type(private/guest/community)\n    :type network: str\n    :param band: wifi band(5/2.4 GHz)\n    :type band: str\n    :return: MAC physical address of the access point\n    :rtype: Optional[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_bssid(network)","title":"<code>network</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_bssid(band)","title":"<code>band</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_passphrase","title":"get_passphrase  <code>abstractmethod</code>","text":"<pre><code>get_passphrase(iface: str) -&gt; str\n</code></pre> <p>Get the passphrase for a network on an interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>str</code> <p>encrypted password for a network</p> Source code in <code>boardfarm3/lib/hal/cpe_wifi.py</code> <pre><code>@abstractmethod\ndef get_passphrase(self, iface: str) -&gt; str:\n    \"\"\"Get the passphrase for a network on an interface.\n\n    :param iface: name of the interface\n    :type iface: str\n    :return: encrypted password for a network\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_passphrase(iface)","title":"<code>iface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_ssid","title":"get_ssid  <code>abstractmethod</code>","text":"<pre><code>get_ssid(network: str, band: str) -&gt; str | None\n</code></pre> <p>Get the wifi ssid for the wlan client with specific network and band.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type(private/guest/community)</p> required <code>str</code> <p>wifi band(5/2.4 GHz)</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>SSID of the WiFi for a given network type and band</p> Source code in <code>boardfarm3/lib/hal/cpe_wifi.py</code> <pre><code>@abstractmethod\ndef get_ssid(self, network: str, band: str) -&gt; str | None:\n    \"\"\"Get the wifi ssid for the wlan client with specific network and band.\n\n    :param network: network type(private/guest/community)\n    :type network: str\n    :param band: wifi band(5/2.4 GHz)\n    :type band: str\n    :return: SSID of the WiFi for a given network type and band\n    :rtype: Optional[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_ssid(network)","title":"<code>network</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.get_ssid(band)","title":"<code>band</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.is_wifi_enabled","title":"is_wifi_enabled  <code>abstractmethod</code>","text":"<pre><code>is_wifi_enabled(network_type: str, band: str) -&gt; bool\n</code></pre> <p>Check if specific wifi is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type(private/guest/community)</p> required <code>str</code> <p>wifi band(5/2.4 GHz)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if enabled, False otherwise</p> Source code in <code>boardfarm3/lib/hal/cpe_wifi.py</code> <pre><code>@abstractmethod\ndef is_wifi_enabled(self, network_type: str, band: str) -&gt; bool:\n    \"\"\"Check if specific wifi is enabled.\n\n    :param network_type: network type(private/guest/community)\n    :type network_type: str\n    :param band: wifi band(5/2.4 GHz)\n    :type band: str\n    :return: True if enabled, False otherwise\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.is_wifi_enabled(network_type)","title":"<code>network_type</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.hal.cpe_wifi.WiFiHal.is_wifi_enabled(band)","title":"<code>band</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell","title":"interactive_shell","text":"<p>Boardfarm interactive shell module.</p> <p>Classes:</p> Name Description <code>OptionsTable</code> <p>Boardfarm interactive console options table.</p> <p>Functions:</p> Name Description <code>get_interactive_console_options</code> <p>Return options table with all boardfarm interactive shell options.</p>"},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable","title":"OptionsTable","text":"<pre><code>OptionsTable(title: str | None = None)\n</code></pre> <p>Boardfarm interactive console options table.</p> <p>Initialize the OptionsTable.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>title of the table, defaults to None</p> <code>None</code> <p>Methods:</p> Name Description <code>add_column</code> <p>Add a table column.</p> <code>add_option</code> <p>Add an action item to the table.</p> <code>show_table</code> <p>Show table and perform actions based on user input.</p> Source code in <code>boardfarm3/lib/interactive_shell.py</code> <pre><code>def __init__(self, title: str | None = None) -&gt; None:\n    \"\"\"Initialize the OptionsTable.\n\n    :param title: title of the table, defaults to None\n    :type title: Optional[str], optional\n    \"\"\"\n    self._table = Table(\n        title=title,\n        title_justify=\"center\",\n        box=HORIZONTALS,\n        show_lines=True,\n    )\n    self._actions: dict[str, tuple[Callable, tuple[Any, ...], dict[str, Any]]] = {}\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable(title)","title":"<code>title</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_column","title":"add_column","text":"<pre><code>add_column(\n    name: str,\n    justify: JustifyMethod | None = None,\n    style: str | None = None,\n    width: int | None = None,\n) -&gt; None\n</code></pre> <p>Add a table column.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the column</p> required <code>JustifyMethod | None</code> <p>column content position, defaults to None</p> <code>None</code> <code>str | None</code> <p>table content style, defaults to None</p> <code>None</code> <code>int | None</code> <p>column width, defaults to None</p> <code>None</code> Source code in <code>boardfarm3/lib/interactive_shell.py</code> <pre><code>def add_column(\n    self,\n    name: str,\n    justify: JustifyMethod | None = None,\n    style: str | None = None,\n    width: int | None = None,\n) -&gt; None:\n    \"\"\"Add a table column.\n\n    :param name: name of the column\n    :type name: str\n    :param justify: column content position, defaults to None\n    :type justify: JustifyMethod, optional\n    :param style: table content style, defaults to None\n    :type style: str, optional\n    :param width: column width, defaults to None\n    :type width: Optional[int], optional\n    \"\"\"\n    self._table.add_column(name, justify=justify, style=style, width=width)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_column(name)","title":"<code>name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_column(justify)","title":"<code>justify</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_column(style)","title":"<code>style</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_column(width)","title":"<code>width</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_option","title":"add_option","text":"<pre><code>add_option(\n    column_data: tuple[str, ...],\n    function: Callable,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n) -&gt; None\n</code></pre> <p>Add an action item to the table.</p> <p>Parameters:</p> Name Type Description Default <code>tuple[str, ...]</code> <p>table column data</p> required <code>Callable</code> <p>function to be called for this option</p> required <code>tuple[Any, ...]</code> <p>positional arguments to the function</p> required <code>dict[str, Any]</code> <p>keyword arguments to the function</p> required Source code in <code>boardfarm3/lib/interactive_shell.py</code> <pre><code>def add_option(\n    self,\n    column_data: tuple[str, ...],\n    function: Callable,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Add an action item to the table.\n\n    :param column_data: table column data\n    :type column_data: tuple[str, ...]\n    :param function: function to be called for this option\n    :type function: Callable\n    :param args: positional arguments to the function\n    :type args: Tuple[Any, ...]\n    :param kwargs: keyword arguments to the function\n    :type kwargs: Dict[str, Any]\n    \"\"\"\n    self._table.add_row(*column_data)\n    self._actions[column_data[0]] = (function, args, kwargs)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_option(column_data)","title":"<code>column_data</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_option(function)","title":"<code>function</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_option(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.add_option(kwargs)","title":"<code>kwargs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.show_table","title":"show_table","text":"<pre><code>show_table(exit_option: str, exit_option_description: str) -&gt; None\n</code></pre> <p>Show table and perform actions based on user input.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>exit option name</p> required <code>str</code> <p>exit option description</p> required Source code in <code>boardfarm3/lib/interactive_shell.py</code> <pre><code>def show_table(self, exit_option: str, exit_option_description: str) -&gt; None:\n    \"\"\"Show table and perform actions based on user input.\n\n    :param exit_option: exit option name\n    :type exit_option: str\n    :param exit_option_description: exit option description\n    :type exit_option_description: str\n    \"\"\"\n    self._table.add_row(exit_option, exit_option_description)\n    rich_print(self._table)\n    while (\n        option := Prompt.ask(\n            \"Enter your choice:\",\n            choices=[*list(self._actions.keys()), exit_option],\n        )\n    ) != exit_option:\n        self._actions[option][0](\n            *self._actions[option][1],\n            **self._actions[option][2],\n        )\n        rich_print(self._table)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.show_table(exit_option)","title":"<code>exit_option</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.OptionsTable.show_table(exit_option_description)","title":"<code>exit_option_description</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.get_interactive_console_options","title":"get_interactive_console_options","text":"<pre><code>get_interactive_console_options(\n    device_manager: DeviceManager, cmdline_args: Namespace\n) -&gt; OptionsTable\n</code></pre> <p>Return options table with all boardfarm interactive shell options.</p> <p>Parameters:</p> Name Type Description Default <code>DeviceManager</code> <p>device manager instance</p> required <code>Namespace</code> <p>command line arguments</p> required <p>Returns:</p> Type Description <code>OptionsTable</code> <p>option table with boardfarm interactive shell options</p> Source code in <code>boardfarm3/lib/interactive_shell.py</code> <pre><code>def get_interactive_console_options(\n    device_manager: DeviceManager,\n    cmdline_args: Namespace,\n) -&gt; OptionsTable:\n    \"\"\"Return options table with all boardfarm interactive shell options.\n\n    :param device_manager: device manager instance\n    :type device_manager: DeviceManager\n    :param cmdline_args: command line arguments\n    :type cmdline_args: Namespace\n    :return: option table with boardfarm interactive shell options\n    :rtype: OptionsTable\n    \"\"\"\n    table = OptionsTable(\"BOARDFARM INTERACTIVE SHELL\")\n    table.add_column(\"Choice\", justify=\"center\", style=\"cyan\")\n    table.add_column(\"Description\", style=\"magenta\")\n    table.add_column(\"Consoles\", justify=\"center\")\n    for option in _get_device_console_options(device_manager):\n        table.add_option(*option)\n    table.add_option(\n        (\"p\", \"python interactive shell (ptpython)\"),\n        _interactive_ptpython_shell,\n        (cmdline_args, device_manager),\n        {},\n    )\n    if entry_points(group=\"pytest11\", name=\"pytest_boardfarm\"):\n        table.add_option(\n            (\"e\", \"execute boardfarm automated test(s)\"),\n            _run_boardfarm_tests,\n            (),\n            {},\n        )\n    if cmdline_args.save_console_logs:\n        table.add_option(\n            (\"m\", \"add custom marker in console logs\"),\n            _add_session_marker_in_console_logs,\n            (),\n            {},\n        )\n    return table\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.get_interactive_console_options(device_manager)","title":"<code>device_manager</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.interactive_shell.get_interactive_console_options(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.mibs_compiler","title":"mibs_compiler","text":"<p>MIBs to JSON compiler module.</p> <p>Classes:</p> Name Description <code>MibsCompiler</code> <p>MIBs to JSON compiler class.</p>"},{"location":"reference/libs/#boardfarm3.lib.mibs_compiler.MibsCompiler","title":"MibsCompiler","text":"<pre><code>MibsCompiler(mibs_dirs: list[str])\n</code></pre> <p>MIBs to JSON compiler class.</p> <p>Initialize MIBs to JSON compiler.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>mibs directories</p> required <p>Methods:</p> Name Description <code>get_mib_oid</code> <p>Get OID of given MIB.</p> Source code in <code>boardfarm3/lib/mibs_compiler.py</code> <pre><code>def __init__(self, mibs_dirs: list[str]):\n    \"\"\"Initialize MIBs to JSON compiler.\n\n    :param mibs_dirs: mibs directories\n    \"\"\"\n    self._mibs_dict: dict[str, dict] = {}\n    self._compile_mibs(mibs_dirs)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.mibs_compiler.MibsCompiler(mibs_dirs)","title":"<code>mibs_dirs</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.mibs_compiler.MibsCompiler.get_mib_oid","title":"get_mib_oid","text":"<pre><code>get_mib_oid(mib_name: str) -&gt; str\n</code></pre> <p>Get OID of given MIB.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>MIB name</p> required <p>Returns:</p> Type Description <code>str</code> <p>OID of the given MIB</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when unable to find given mib</p> Source code in <code>boardfarm3/lib/mibs_compiler.py</code> <pre><code>def get_mib_oid(self, mib_name: str) -&gt; str:\n    \"\"\"Get OID of given MIB.\n\n    :param mib_name: MIB name\n    :returns: OID of the given MIB\n    :raises ValueError: when unable to find given mib\n    \"\"\"\n    if (\n        mib_name in self._mibs_dict\n        and self._mibs_dict.get(mib_name, None)\n        and \"oid\" in self._mibs_dict[mib_name]\n    ):\n        return self._mibs_dict[mib_name][\"oid\"]\n    msg = f\"Unable to find OID of {mib_name!r} MIB\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.mibs_compiler.MibsCompiler.get_mib_oid(mib_name)","title":"<code>mib_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast","title":"multicast","text":"<p>Multicast library.</p> <p>Classes:</p> Name Description <code>IPerfResult</code> <p>Store results of IPerf server session.</p> <code>IPerfSession</code> <p>Store details of IPerf session.</p> <code>IPerfStream</code> <p>Store details of IPerf stream.</p> <code>Multicast</code> <p>Multicast device component.</p> <code>MulticastGroupRecordType</code> <p>IGMPv3 Record Types.</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.IPerfResult","title":"IPerfResult  <code>dataclass</code>","text":"<pre><code>IPerfResult(_data: DataFrame | None)\n</code></pre> <p>Store results of IPerf server session.</p> <p>Attributes:</p> Name Type Description <code>bandwidth</code> <code>str | None</code> <p>Return resultant bandwidth in Mbps.</p> <code>result</code> <code>DataFrame | None</code> <p>Return the entire result as a dataframe.</p> <code>total_loss</code> <code>str | None</code> <p>Return no. of datagrams lost.</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.IPerfResult.bandwidth","title":"bandwidth  <code>property</code>","text":"<pre><code>bandwidth: str | None\n</code></pre> <p>Return resultant bandwidth in Mbps.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>resultant bandwidth, None if iperf failed</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.IPerfResult.result","title":"result  <code>property</code>","text":"<pre><code>result: DataFrame | None\n</code></pre> <p>Return the entire result as a dataframe.</p> <p>Returns:</p> Type Description <code>Optional[pandas.DataFrame]</code> <p>iperf result in tablular format, None if iperf failed</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.IPerfResult.total_loss","title":"total_loss  <code>property</code>","text":"<pre><code>total_loss: str | None\n</code></pre> <p>Return no. of datagrams lost.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>resultant total loss, None if iperf failed</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.IPerfSession","title":"IPerfSession  <code>dataclass</code>","text":"<pre><code>IPerfSession(device: IperfDevice, pid: str, address: str, port: int, output_file: str)\n</code></pre> <p>Store details of IPerf session.</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.IPerfStream","title":"IPerfStream  <code>dataclass</code>","text":"<pre><code>IPerfStream(\n    device: IperfDevice,\n    pid: str,\n    address: str,\n    port: int,\n    output_file: str,\n    time: int = 0,\n)\n</code></pre> <p>Store details of IPerf stream.</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast","title":"Multicast","text":"<pre><code>Multicast(\n    device_name: str, iface_dut: str, console: BoardfarmPexpect, shell_prompt: list[str]\n)\n</code></pre> <p>Multicast device component.</p> <p>Initialize multicast component.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>device name</p> required <code>str</code> <p>DUT interface name</p> required <code>BoardfarmPexpect</code> <p>console instance of the device</p> required <code>list[str]</code> <p>shell prompt patterns</p> required <p>Methods:</p> Name Description <code>join_iperf_multicast_asm_group</code> <p>Start an iperf server binding to a multicast address in background.</p> <code>join_iperf_multicast_ssm_group</code> <p>Start an iperf server binding to a multicast address in background.</p> <code>kill_all_iperf_sessions</code> <p>Kill all iperf sessions.</p> <code>leave_iperf_multicast_group</code> <p>Send IGMP leave to stop receiving multicast traffic.</p> <code>parse_mcast_trace</code> <p>Compare captured PCAP file against an expected sequence of packets.</p> <code>send_igmpv3_report</code> <p>Send an IGMPv3 report with desired multicast record.</p> <code>send_mldv2_report</code> <p>Send an MLDv2 report with desired multicast record.</p> <code>start_iperf_multicast_stream</code> <p>Start an iperf client sending data on multicast address in background.</p> <code>wait_for_multicast_stream_to_end</code> <p>Wait for all multicast streams to end.</p> <p>Attributes:</p> Name Type Description <code>gateway_mac_addr</code> <code>str</code> <p>Return the L2 address of DUT gateway from ARP table.</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def __init__(\n    self,\n    device_name: str,\n    iface_dut: str,\n    console: BoardfarmPexpect,\n    shell_prompt: list[str],\n) -&gt; None:\n    \"\"\"Initialize multicast component.\n\n    :param device_name: device name\n    :type device_name: str\n    :param iface_dut: DUT interface name\n    :type iface_dut: str\n    :param console: console instance of the device\n    :type console: BoardfarmPexpect\n    :param shell_prompt: shell prompt patterns\n    :type shell_prompt: list[str]\n    \"\"\"\n    self._console = console\n    self._iface_dut = iface_dut\n    self._shell_prompt = shell_prompt\n    self._device_name = device_name\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast(device_name)","title":"<code>device_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast(iface_dut)","title":"<code>iface_dut</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast(shell_prompt)","title":"<code>shell_prompt</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.gateway_mac_addr","title":"gateway_mac_addr  <code>property</code>","text":"<pre><code>gateway_mac_addr: str\n</code></pre> <p>Return the L2 address of DUT gateway from ARP table.</p> <p>Returns:</p> Type Description <code>str</code> <p>MAC address in string format.</p>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.join_iperf_multicast_asm_group","title":"join_iperf_multicast_asm_group","text":"<pre><code>join_iperf_multicast_asm_group(multicast_group_addr: str, port: int) -&gt; IPerfSession\n</code></pre> <p>Start an iperf server binding to a multicast address in background.</p> <p>This use case is applicable for ASM (any-source multicast) channels (*,G)  # noqa: RST213 - false positive</p> <p>Session will have the following parameters by default:     - 1s interval between periodic bandwidth, jitter,       and loss reports.</p> <p>The Use Case will return an Iperf Session object holding following info: - Target device class object on which iperf command is executed - PID of the iperf session - Multicast group address - Multicast port - CSV output file of the iperf session</p> <p>.. note::</p> <pre><code>- CSV output file can only be accessed once you leave the multicast group.\n</code></pre> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an Ethernet LAN client to request CPE for\n  IPv4 ASM traffic from WAN multicast server\n- Start client to join/subscribe any source multicast channel (S,G)\n  by sending IGMPv3 report\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>multicast stream's group IP address to join</p> required <code>int</code> <p>multicast stream's port number</p> required <p>Returns:</p> Type Description <code>IPerfSession</code> <p>object holding data on the IPerf Session</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def join_iperf_multicast_asm_group(\n    self,\n    multicast_group_addr: str,\n    port: int,\n) -&gt; IPerfSession:\n    \"\"\"Start an iperf server binding to a multicast address in background.\n\n    This use case is applicable for ASM (any-source multicast)\n    channels (*,G)  # noqa: RST213 - false positive\n\n    Session will have the following parameters by default:\n        - 1s interval between periodic bandwidth, jitter,\n          and loss reports.\n\n    The Use Case will return an Iperf Session object holding\n    following info:\n    - Target device class object on which iperf command is executed\n    - PID of the iperf session\n    - Multicast group address\n    - Multicast port\n    - CSV output file of the iperf session\n\n    .. note::\n\n        - CSV output file can only be accessed once you leave the multicast group.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an Ethernet LAN client to request CPE for\n          IPv4 ASM traffic from WAN multicast server\n        - Start client to join/subscribe any source multicast channel (S,G)\n          by sending IGMPv3 report\n\n    :param multicast_group_addr: multicast stream's group IP address to join\n    :type multicast_group_addr: str\n    :param port: multicast stream's port number\n    :type port: int\n    :return: object holding data on the IPerf Session\n    :rtype: IPerfSession\n    \"\"\"\n    ipv6_flag = (\n        \"-V\" if isinstance(ip_address(multicast_group_addr), IPv6Address) else \"\"\n    )\n    # Cannot have any iperf session running for the same mul\n    self._iperf_session_check(multicast_group_addr, port)\n    fname = f\"mclient_{port}.txt\"\n    # run iperf, format result as CSV\n    self._console.execute_command(\n        f\"iperf {ipv6_flag} -s -f m -u -U -p {port} \"\n        f\"-B {multicast_group_addr} \"\n        f\"-i 1 -y C &gt; {fname} &amp;\",\n    )\n    pid = self._console.execute_command(\n        f\"pgrep iperf -a | grep {port} | awk '{{print$1}}'\",\n    )\n    return IPerfSession(None, pid, multicast_group_addr, port, fname)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.join_iperf_multicast_asm_group(multicast_group_addr)","title":"<code>multicast_group_addr</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.join_iperf_multicast_asm_group(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.join_iperf_multicast_ssm_group","title":"join_iperf_multicast_ssm_group","text":"<pre><code>join_iperf_multicast_ssm_group(\n    multicast_source_addr: str, multicast_group_addr: str, port: int\n) -&gt; IPerfSession\n</code></pre> <p>Start an iperf server binding to a multicast address in background.</p> <p>This use case is applicable for SSM (source-specific multicast) channels (S,G)</p> <p>Session will have the following parameters by default:     - 1s interval between periodic bandwidth, jitter,       and loss reports.</p> <p>The Use Case will return an Iperf Session object holding following info: - Target device class object on which iperf command is executed - PID of the iperf session - Multicast group address - Multicast port - CSV output file of the iperf session</p> <p>.. note::</p> <pre><code>- The multicast source will always be a WAN device.\n- CSV output file can only be accessed once you leave the multicast group.\n</code></pre> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an Ethernet LAN client to request CPE for\n  IPv4 SSM traffic from WAN multicast server\n- Start client to join/subscribe a specific source and Group (S,G)\n  channel by sending IGMPv3 report\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>WAN IP address used to run the mcast stream</p> required <code>str</code> <p>multicast stream's group IP address to join</p> required <code>int</code> <p>multicast stream's port number</p> required <p>Returns:</p> Type Description <code>IPerfSession</code> <p>object holding data on the IPerf Session</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def join_iperf_multicast_ssm_group(\n    self,\n    multicast_source_addr: str,\n    multicast_group_addr: str,\n    port: int,\n) -&gt; IPerfSession:\n    \"\"\"Start an iperf server binding to a multicast address in background.\n\n    This use case is applicable for SSM (source-specific multicast) channels (S,G)\n\n    Session will have the following parameters by default:\n        - 1s interval between periodic bandwidth, jitter,\n          and loss reports.\n\n    The Use Case will return an Iperf Session object holding\n    following info:\n    - Target device class object on which iperf command is executed\n    - PID of the iperf session\n    - Multicast group address\n    - Multicast port\n    - CSV output file of the iperf session\n\n    .. note::\n\n        - The multicast source will always be a WAN device.\n        - CSV output file can only be accessed once you leave the multicast group.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an Ethernet LAN client to request CPE for\n          IPv4 SSM traffic from WAN multicast server\n        - Start client to join/subscribe a specific source and Group (S,G)\n          channel by sending IGMPv3 report\n\n    :param multicast_source_addr: WAN IP address used to run the mcast stream\n    :type multicast_source_addr: str\n    :param multicast_group_addr: multicast stream's group IP address to join\n    :type multicast_group_addr: str\n    :param port: multicast stream's port number\n    :type port: int\n    :return: object holding data on the IPerf Session\n    :rtype: IPerfSession\n    \"\"\"\n    ipv6_flag = (\n        \"-V\"\n        if isinstance(ip_address(multicast_source_addr), IPv6Address)\n        and isinstance(ip_address(multicast_group_addr), IPv6Address)\n        else \"\"\n    )\n    # Cannot have any iperf session running for the same mul\n    self._iperf_session_check(multicast_group_addr, port)\n    fname = f\"mclient_{port}.txt\"\n    # run iperf, format result as CSV\n    self._console.execute_command(\n        f\"iperf {ipv6_flag} -s -f m -u -U -p {port} \"\n        f\"-B {multicast_group_addr} --ssm-host {multicast_source_addr} \"\n        f\"-i 1 -y C &gt; {fname} &amp;\",\n    )\n    pid = self._console.execute_command(\n        f\"pgrep iperf -a | grep {port} | awk '{{print$1}}'\",\n    )\n    return IPerfSession(None, pid, multicast_group_addr, port, fname)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.join_iperf_multicast_ssm_group(multicast_source_addr)","title":"<code>multicast_source_addr</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.join_iperf_multicast_ssm_group(multicast_group_addr)","title":"<code>multicast_group_addr</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.join_iperf_multicast_ssm_group(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.kill_all_iperf_sessions","title":"kill_all_iperf_sessions","text":"<pre><code>kill_all_iperf_sessions() -&gt; None\n</code></pre> <p>Kill all iperf sessions.</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def kill_all_iperf_sessions(self) -&gt; None:\n    \"\"\"Kill all iperf sessions.\"\"\"\n    self._console.sendcontrol(\"c\")\n    self._console.expect(self._shell_prompt)\n    self._console.execute_command(\"for i in $(pgrep iperf); do kill -9 $i; done\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.leave_iperf_multicast_group","title":"leave_iperf_multicast_group","text":"<pre><code>leave_iperf_multicast_group(session: IPerfSession) -&gt; IPerfResult\n</code></pre> <p>Send IGMP leave to stop receiving multicast traffic.</p> <p>This is achieved by stopping the iperf server bounded to a multicast channel ASM/SSM.</p> <p>Executes a kill -15  on target device. In case of IGMPv3, will send a block old sources membership report. <p>Parameters:</p> Name Type Description Default <code>IPerfSession</code> <p>session object created during the join</p> required <p>Returns:</p> Type Description <code>IPerfResult</code> <p>IPerf results object</p> <p>Raises:</p> Type Description <code>MulticastError</code> <p>when iperf session deosn't exit</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def leave_iperf_multicast_group(self, session: IPerfSession) -&gt; IPerfResult:\n    \"\"\"Send IGMP leave to stop receiving multicast traffic.\n\n    This is achieved by stopping the iperf server bounded\n    to a multicast channel ASM/SSM.\n\n    Executes a kill -15 &lt;iperf session pid&gt; on target device.\n    In case of IGMPv3, will send a block old sources membership report.\n\n    :param session: session object created during the join\n    :type session: IPerfSession\n    :raises MulticastError: when iperf session deosn't exit\n    :return: IPerf results object\n    :rtype: IPerfResult\n    \"\"\"\n    if not self._console.execute_command(\n        f\"pgrep iperf -a | grep {session.port}| grep {session.address}\",\n    ):\n        # Something is wrong, there should be a process ID always.\n        msg = (\n            f\"iperf session with port {session.port} and {session.address} \"\n            f\"multicast group does not exist on {self._device_name}\"\n        )\n        raise MulticastError(\n            msg,\n        )\n    # kill -15 iperf session\n    self._console.execute_command(f\"kill -15 {session.pid}\")\n    output = self._console.execute_command(f\"cat {session.output_file}\")\n    # remove the file after reading results\n    self._console.execute_command(f\"rm {session.output_file}\")\n    if not output.strip():\n        return IPerfResult(None)\n\n    csv = pd.read_csv(StringIO(output.strip()))\n    cols = [\n        \"timestamp\",\n        \"source_address\",\n        \"source_port\",\n        \"destination_address\",\n        \"destination_port\",\n        \"id\",\n        \"interval\",\n        \"transferred_bytes\",\n        \"bandwidth\",\n        \"jitter\",\n        \"lost\",\n        \"total\",\n    ]\n    return IPerfResult(pd.DataFrame(csv.iloc[:, :-2].values, columns=cols))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.leave_iperf_multicast_group(session)","title":"<code>session</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.parse_mcast_trace","title":"parse_mcast_trace","text":"<pre><code>parse_mcast_trace(\n    fname: str, expected_sequence: list[tuple[str, ...]], ip_version: int = 4\n) -&gt; list[tuple[str, ...]]\n</code></pre> <p>Compare captured PCAP file against an expected sequence of packets.</p> <p>This returns a matched subset of the whole packet trace. The sequence of the matched packets must align with expected sequence. The length of the matched sequence is equal to expected sequence.</p> <p>In case a packet is missing in captured sequence, an empty value is maintained in output at the same index as that of the expected sequence.</p> <p>IP packets in expected sequence must follow the following order:</p> <pre><code>- IP source\n- IP destination\n- MAC source\n- MAC destination\n- IP protocol number (1 - ICMP, 2 - IGMP, 6 - TCP, 17 - UDP)\n- IGMP version (v3 by default)\n- IGMP Record Type number (5 - Allow new sources, 6 - Block old sources)\n- IGMP Multicast Address (if provided in group records)\n- IGMP Source Address (if provided in group records)\n</code></pre> <p>IPv6 packets will be parsed and following values are returned in a list:</p> <pre><code>- IPv6 source\n- IPv6 destination\n- MAC source\n- MAC destination\n- IPv6 Next Header (0 - ICMPv6, 6 - TCP, 17 - UDP)\n- MLDv2 version (130 - MLDv2 Query, 143 - MLDv2 Report)\n- MLDv2 Record Type number (5 - Allow new sources, 6 - Block old sources)\n- MLDv2 Multicast Address (if provided in group records)\n- MLDv2 Source Address (if provided in group records)\n</code></pre> <p>You can use * to mark a field as Any</p> <p>.. hint:: This Use Case assists in validating statements from the    test suite such as:</p> <pre><code>- Check IGMPv3 report to subscribe to (S,G) from LAN on eRouter\n  LAN interface\n- Check Multicast traffic from WAN multicast server is received\n  on eRouter WAN interface and forwarded to Ethernet LAN client\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the pcap file</p> required <code>list[tuple[str, ...]]</code> <p>expected sequence to match against captured sequence</p> required <code>int</code> <p>IP version, defaults to 4</p> <code>4</code> <p>Returns:</p> Type Description <code>list[tuple[str, ...]]</code> <p>matched captured sequence against the expected sequence</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when given ip version is invalid</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def parse_mcast_trace(\n    self,\n    fname: str,\n    expected_sequence: list[tuple[str, ...]],\n    ip_version: int = 4,\n) -&gt; list[tuple[str, ...]]:\n    \"\"\"Compare captured PCAP file against an expected sequence of packets.\n\n    This returns a matched subset of the whole packet trace.\n    The sequence of the matched packets must align with expected sequence.\n    The length of the matched sequence is equal to expected sequence.\n\n    In case a packet is missing in captured sequence, an empty value is\n    maintained in output at the same index as that of the expected sequence.\n\n    IP packets in expected sequence must follow the following order:\n\n        - IP source\n        - IP destination\n        - MAC source\n        - MAC destination\n        - IP protocol number (1 - ICMP, 2 - IGMP, 6 - TCP, 17 - UDP)\n        - IGMP version (v3 by default)\n        - IGMP Record Type number (5 - Allow new sources, 6 - Block old sources)\n        - IGMP Multicast Address (if provided in group records)\n        - IGMP Source Address (if provided in group records)\n\n    IPv6 packets will be parsed and following values are returned in a list:\n\n        - IPv6 source\n        - IPv6 destination\n        - MAC source\n        - MAC destination\n        - IPv6 Next Header (0 - ICMPv6, 6 - TCP, 17 - UDP)\n        - MLDv2 version (130 - MLDv2 Query, 143 - MLDv2 Report)\n        - MLDv2 Record Type number (5 - Allow new sources, 6 - Block old sources)\n        - MLDv2 Multicast Address (if provided in group records)\n        - MLDv2 Source Address (if provided in group records)\n\n    You can use * to mark a field as Any\n\n    .. hint:: This Use Case assists in validating statements from the\n       test suite such as:\n\n        - Check IGMPv3 report to subscribe to (S,G) from LAN on eRouter\n          LAN interface\n        - Check Multicast traffic from WAN multicast server is received\n          on eRouter WAN interface and forwarded to Ethernet LAN client\n\n    :param fname: name of the pcap file\n    :type fname: str\n    :param expected_sequence: expected sequence to match against captured sequence\n    :type expected_sequence: list[tuple[str, ...]]\n    :param ip_version: IP version, defaults to 4\n    :type ip_version: int\n    :raises ValueError: when given ip version is invalid\n    :return: matched captured sequence against the expected sequence\n    :rtype: list[tuple[str, ...]]\n    \"\"\"\n    if ip_version == 4:  # noqa: PLR2004\n        captured_sequence = self._read_mcast_ipv4_trace(fname)\n    elif ip_version == 6:  # noqa: PLR2004\n        captured_sequence = self._read_mcast_ipv6_trace(fname)\n    else:\n        msg = f\"Invalid IP version: {ip_version}\"\n        raise ValueError(msg)\n    last_check = 0\n    final_result = []\n    for packet in expected_sequence:\n        for i in range(last_check, len(captured_sequence)):\n            if all(\n                expected == actual\n                for expected, actual in zip(packet, captured_sequence[i])\n                if expected != \"*\"\n            ):\n                last_check = i\n                _LOGGER.debug(\n                    \"Verified IP Multicast: %s---&gt;%s, MAC: %s---&gt;%s\",\n                    packet[0],\n                    packet[1],\n                    packet[2],\n                    packet[3],\n                )\n                final_result.append(captured_sequence[i])\n                break\n        else:\n            _LOGGER.debug(\n                \"Failed IP Multicast verification: %s---&gt;%s, MAC: %s---&gt;%s\",\n                packet[0],\n                packet[1],\n                packet[2],\n                packet[3],\n            )\n            final_result.append(())\n    return final_result\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.parse_mcast_trace(fname)","title":"<code>fname</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.parse_mcast_trace(expected_sequence)","title":"<code>expected_sequence</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.parse_mcast_trace(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.send_igmpv3_report","title":"send_igmpv3_report","text":"<pre><code>send_igmpv3_report(mcast_group_record: MulticastGroupRecord, count: int) -&gt; None\n</code></pre> <p>Send an IGMPv3 report with desired multicast record.</p> <p>Multicast source and group must be IPv4 addresses. Multicast sources need to be non-multicast addresses and group address needs to be a multicast address.</p> <p>Implementation relies on a custom send_igmp_report script based on scapy.</p> <p>Parameters:</p> Name Type Description Default <code>MulticastGroupRecord</code> <p>IGMPv3 multicast group record</p> required <code>int</code> <p>num of packets to send in 1s interval</p> required <p>Raises:</p> Type Description <code>MulticastError</code> <p>when failed to execute send_mld_report command</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def send_igmpv3_report(\n    self,\n    mcast_group_record: MulticastGroupRecord,\n    count: int,\n) -&gt; None:\n    \"\"\"Send an IGMPv3 report with desired multicast record.\n\n    Multicast source and group must be IPv4 addresses.\n    Multicast sources need to be non-multicast addresses and\n    group address needs to be a multicast address.\n\n    Implementation relies on a custom send_igmp_report\n    script based on scapy.\n\n    :param mcast_group_record: IGMPv3 multicast group record\n    :type mcast_group_record: MulticastGroupRecord\n    :param count: num of packets to send in 1s interval\n    :type count: int\n    :raises MulticastError: when failed to execute send_mld_report command\n    \"\"\"\n    command = f\"send_igmp_report -i {self._iface_dut} -c {count}\"\n    output = self._send_multicast_report(command, mcast_group_record)\n    if f\"Sent {count} packets\" not in output:\n        msg = f\"Failed to execute send_mld_report command:\\n{output}\"\n        raise MulticastError(\n            msg,\n        )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.send_igmpv3_report(mcast_group_record)","title":"<code>mcast_group_record</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.send_igmpv3_report(count)","title":"<code>count</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.send_mldv2_report","title":"send_mldv2_report","text":"<pre><code>send_mldv2_report(mcast_group_record: MulticastGroupRecord, count: int) -&gt; None\n</code></pre> <p>Send an MLDv2 report with desired multicast record.</p> <p>Multicast source and group must be IPv6 addresses. Multicast sources need to be non-multicast addresses and group address needs to be a multicast address.</p> <p>Implementation relies on a custom send_mld_report script based on scapy.</p> <p>Parameters:</p> Name Type Description Default <code>MulticastGroupRecord</code> <p>MLDv2 multicast group record</p> required <code>int</code> <p>num of packets to send in 1s interval</p> required <p>Raises:</p> Type Description <code>MulticastError</code> <p>when failed to execute send_mld_report command</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def send_mldv2_report(\n    self,\n    mcast_group_record: MulticastGroupRecord,\n    count: int,\n) -&gt; None:\n    \"\"\"Send an MLDv2 report with desired multicast record.\n\n    Multicast source and group must be IPv6 addresses.\n    Multicast sources need to be non-multicast addresses and\n    group address needs to be a multicast address.\n\n    Implementation relies on a custom send_mld_report\n    script based on scapy.\n\n    :param mcast_group_record: MLDv2 multicast group record\n    :type mcast_group_record: MulticastGroupRecord\n    :param count: num of packets to send in 1s interval\n    :type count: int\n    :raises MulticastError: when failed to execute send_mld_report command\n    \"\"\"\n    command = f\"send_mld_report -i {self._iface_dut} -c {count}\"\n    output = self._send_multicast_report(command, mcast_group_record)\n    if f\"Sent {count} packets\" not in output:\n        msg = f\"Failed to execute send_mld_report command:\\n{output}\"\n        raise MulticastError(\n            msg,\n        )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.send_mldv2_report(mcast_group_record)","title":"<code>mcast_group_record</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.send_mldv2_report(count)","title":"<code>count</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.start_iperf_multicast_stream","title":"start_iperf_multicast_stream","text":"<pre><code>start_iperf_multicast_stream(\n    multicast_group_addr: str, port: int, time: int, bit_rate: float\n) -&gt; IPerfStream\n</code></pre> <p>Start an iperf client sending data on multicast address in background.</p> <p>Session will have the following parameters by default:     - TTL value set to 5</p> <p>.. hint:: This Use Case implements statements from the    test suite such as:</p> <pre><code>- Start multicast server on WAN network to provide\n  the multicast traffic in unreserved multicast group IP\n  range 232.0.0.0/8\n- Start multicast server on WAN network to provide\n  the multicast traffic in unreserved multicast group IP\n  range FF38::8000:0/96\n- Start multicast stream on a specific Group channel\n  by sending IGMPv3 report\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>multicast stream's group IP address</p> required <code>int</code> <p>multicast stream's port number</p> required <code>int</code> <p>total time the session should run for</p> required <code>float</code> <p>bit_rate of data to be sent (in Mbps)</p> required <p>Returns:</p> Type Description <code>IPerfStream</code> <p>object holding data on the IPerf stream.</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def start_iperf_multicast_stream(\n    self,\n    multicast_group_addr: str,\n    port: int,\n    time: int,\n    bit_rate: float,\n) -&gt; IPerfStream:\n    \"\"\"Start an iperf client sending data on multicast address in background.\n\n    Session will have the following parameters by default:\n        - TTL value set to 5\n\n    .. hint:: This Use Case implements statements from the\n       test suite such as:\n\n        - Start multicast server on WAN network to provide\n          the multicast traffic in unreserved multicast group IP\n          range 232.0.0.0/8\n        - Start multicast server on WAN network to provide\n          the multicast traffic in unreserved multicast group IP\n          range FF38::8000:0/96\n        - Start multicast stream on a specific Group channel\n          by sending IGMPv3 report\n\n    :param multicast_group_addr: multicast stream's group IP address\n    :type multicast_group_addr: str\n    :param port: multicast stream's port number\n    :type port: int\n    :param time: total time the session should run for\n    :type time: int\n    :param bit_rate: bit_rate of data to be sent (in Mbps)\n    :type bit_rate: float\n    :return: object holding data on the IPerf stream.\n    :rtype: IPerfStream\n    \"\"\"\n    # Ensure there is no exisiting stream with same IP and port.\n    self._iperf_session_check(multicast_group_addr, port)\n    ipv6_flag = (\n        \"-V\" if isinstance(ip_address(multicast_group_addr), IPv6Address) else \"\"\n    )\n    fname = f\"mserver_{port}.txt\"\n    self._console.execute_command(\n        f\"iperf {ipv6_flag} -u -f m -c {multicast_group_addr} \"\n        f\"-p {port} --ttl 5 \"\n        f\"-t {time} -b {bit_rate}m &gt; {fname} &amp;\",\n    )\n    pid = self._console.execute_command(\n        f\"pgrep iperf -a | grep {port} | awk '{{print$1}}'\",\n    )\n    return IPerfStream(None, pid, multicast_group_addr, port, fname, time)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.start_iperf_multicast_stream(multicast_group_addr)","title":"<code>multicast_group_addr</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.start_iperf_multicast_stream(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.start_iperf_multicast_stream(time)","title":"<code>time</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.start_iperf_multicast_stream(bit_rate)","title":"<code>bit_rate</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.wait_for_multicast_stream_to_end","title":"wait_for_multicast_stream_to_end","text":"<pre><code>wait_for_multicast_stream_to_end(iperf_stream: IPerfStream) -&gt; None\n</code></pre> <p>Wait for all multicast streams to end.</p> <p>The Use Case will wait for a time equal to the stream with the highest wait time.</p> <p>If a stream from the list does not exit within the max wait time, then throw an error.</p> <p>.. hint:: To be used along with the Use Case start_iperf_multicast_stream</p> <p>Parameters:</p> Name Type Description Default <code>IPerfStream</code> <p>iperf stream instance</p> required <p>Raises:</p> Type Description <code>MulticastError</code> <p>when multicast stream doesn't exit within given time</p> Source code in <code>boardfarm3/lib/multicast.py</code> <pre><code>def wait_for_multicast_stream_to_end(self, iperf_stream: IPerfStream) -&gt; None:\n    \"\"\"Wait for all multicast streams to end.\n\n    The Use Case will wait for a time equal to the stream with\n    the highest wait time.\n\n    If a stream from the list does not exit within the\n    max wait time, then throw an error.\n\n    .. hint:: To be used along with the Use Case start_iperf_multicast_stream\n\n    :param iperf_stream: iperf stream instance\n    :type iperf_stream: IPerfStream\n    :raises MulticastError: when multicast stream doesn't exit within given time\n    \"\"\"\n    is_stream_still_running = False\n    for _ in range(2):\n        if not self._console.execute_command(\n            f\"pgrep iperf -a | grep {iperf_stream.port}| grep\"\n            f\" {iperf_stream.address}\",\n        ):\n            break\n        sleep(1)\n    else:\n        is_stream_still_running = True\n        self._console.execute_command(f\"kill -9 {iperf_stream.pid}\")\n    self._console.execute_command(f\"rm {iperf_stream.output_file}\")\n    if is_stream_still_running:\n        msg = (\n            f\"{iperf_stream.address}:{iperf_stream.port} did not exit \"\n            \"within {iperf_stream.time}s\"\n        )\n        raise MulticastError(\n            msg,\n        )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.multicast.Multicast.wait_for_multicast_stream_to_end(iperf_stream)","title":"<code>iperf_stream</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.multicast.MulticastGroupRecordType","title":"MulticastGroupRecordType","text":"<p>IGMPv3 Record Types.</p>"},{"location":"reference/libs/#boardfarm3.lib.network_utils","title":"network_utils","text":"<p>Network utilities module.</p> <p>Classes:</p> Name Description <code>NetworkUtility</code> <p>Network utilities.</p>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility","title":"NetworkUtility","text":"<pre><code>NetworkUtility(console: BoardfarmPexpect)\n</code></pre> <p>Network utilities.</p> <p>Initialize the network utility.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmPexpect</code> <p>console instance which has network utilities</p> required <p>Methods:</p> Name Description <code>gen_uuid</code> <p>Generate unique identifier.</p> <code>netstat</code> <p>Perform netstat with given options.</p> <code>read_tcpdump</code> <p>Read tcpdump packets and delete the pcap file afterwards.</p> <code>scp</code> <p>Copy file between this device and the remote host.</p> <code>start_tcpdump</code> <p>Start tcpdump capture on given interface.</p> <code>stop_tcpdump</code> <p>Stop tcpdump process with given process id.</p> <code>tftp</code> <p>Transfer file via tftp.</p> <code>traceroute_host</code> <p>Run traceroute to given host ip and return result.</p> Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def __init__(self, console: BoardfarmPexpect) -&gt; None:\n    \"\"\"Initialize the network utility.\n\n    :param console: console instance which has network utilities\n    :type console: BoardfarmPexpect\n    \"\"\"\n    self._console = console\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.gen_uuid","title":"gen_uuid","text":"<pre><code>gen_uuid() -&gt; str\n</code></pre> <p>Generate unique identifier.</p> <p>Returns:</p> Type Description <code>str</code> <p>uuid</p> Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def gen_uuid(self) -&gt; str:\n    \"\"\"Generate unique identifier.\n\n    :return: uuid\n    :rtype: str\n    \"\"\"\n    return self._console.execute_command(\"uuidgen\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.netstat","title":"netstat","text":"<pre><code>netstat(opts: str = '', extra_opts: str = '') -&gt; DataFrame\n</code></pre> <p>Perform netstat with given options.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command line options</p> <code>''</code> <code>str</code> <p>extra command line options</p> <code>''</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>parsed netstat output</p> Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def netstat(self, opts: str = \"\", extra_opts: str = \"\") -&gt; DataFrame:\n    \"\"\"Perform netstat with given options.\n\n    :param opts: command line options\n    :type opts: str\n    :param extra_opts: extra command line options\n    :type extra_opts: str\n    :return: parsed netstat output\n    :rtype: DataFrame\n    \"\"\"\n    return NetstatParser().parse_netstat_output(\n        self._console.execute_command(f\"netstat {opts} {extra_opts}\")\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.netstat(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.netstat(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.read_tcpdump","title":"read_tcpdump","text":"<pre><code>read_tcpdump(\n    capture_file: str,\n    protocol: str = \"\",\n    opts: str = \"\",\n    timeout: int = 30,\n    rm_pcap: bool = True,\n) -&gt; str\n</code></pre> <p>Read tcpdump packets and delete the pcap file afterwards.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump pcap file path</p> required <code>str</code> <p>protocol to the filter</p> <code>''</code> <code>str</code> <p>command line options to tcpdump</p> <code>''</code> <code>int</code> <p>timeout for reading the tcpdump output</p> <code>30</code> <code>bool</code> <p>remove pcap file after read</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>tcpdump output</p> Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def read_tcpdump(\n    self,\n    capture_file: str,\n    protocol: str = \"\",\n    opts: str = \"\",\n    timeout: int = 30,\n    rm_pcap: bool = True,\n) -&gt; str:\n    \"\"\"Read tcpdump packets and delete the pcap file afterwards.\n\n    :param capture_file: tcpdump pcap file path\n    :type capture_file: str\n    :param protocol: protocol to the filter\n    :type protocol: str\n    :param opts: command line options to tcpdump\n    :type opts: str\n    :param timeout: timeout for reading the tcpdump output\n    :type timeout: int\n    :param rm_pcap: remove pcap file after read\n    :type rm_pcap: bool\n    :return: tcpdump output\n    :rtype: str\n    \"\"\"\n    return tcpdump_read(\n        self._console,\n        capture_file,\n        protocol=protocol,\n        opts=opts,\n        timeout=timeout,\n        rm_pcap=rm_pcap,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.read_tcpdump(capture_file)","title":"<code>capture_file</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.read_tcpdump(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.read_tcpdump(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.read_tcpdump(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.read_tcpdump(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp","title":"scp","text":"<pre><code>scp(\n    ip: str,\n    port: int | str,\n    user: str,\n    pwd: str,\n    source_path: str,\n    dest_path: str,\n    action: Literal[\"download\", \"upload\"],\n) -&gt; None\n</code></pre> <p>Copy file between this device and the remote host.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address of the remote host</p> required <code>int | str</code> <p>port number of the remote host</p> required <code>str</code> <p>username of the host</p> required <code>str</code> <p>password of the host</p> required <code>str</code> <p>source file path</p> required <code>str</code> <p>destination path</p> required <code>Literal['download', 'upload']</code> <p>scp action(download/upload)</p> required Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def scp(  # noqa: PLR0913\n    self,\n    ip: str,\n    port: int | str,\n    user: str,\n    pwd: str,\n    source_path: str,\n    dest_path: str,\n    action: Literal[\"download\", \"upload\"],\n) -&gt; None:\n    \"\"\"Copy file between this device and the remote host.\n\n    :param ip: ip address of the remote host\n    :type ip: str\n    :param port: port number of the remote host\n    :type port: int | str\n    :param user: username of the host\n    :type user: str\n    :param pwd: password of the host\n    :type pwd: str\n    :param source_path: source file path\n    :type source_path: str\n    :param dest_path: destination path\n    :type dest_path: str\n    :param action: scp action(download/upload)\n    :type action: Literal[\"download\", \"upload\"]\n    \"\"\"\n    scp(\n        self._console,\n        host=ip,\n        port=port,\n        username=user,\n        password=pwd,\n        src_path=source_path,\n        dst_path=dest_path,\n        action=action,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp(ip)","title":"<code>ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp(user)","title":"<code>user</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp(pwd)","title":"<code>pwd</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp(source_path)","title":"<code>source_path</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp(dest_path)","title":"<code>dest_path</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.scp(action)","title":"<code>action</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.start_tcpdump","title":"start_tcpdump","text":"<pre><code>start_tcpdump(fname: str, interface: str, filters: dict | None = None) -&gt; str\n</code></pre> <p>Start tcpdump capture on given interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump output file name</p> required <code>str</code> <p>interface name to be captured</p> required <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"}) default to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>return the process id of the tcpdump capture</p> Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def start_tcpdump(\n    self, fname: str, interface: str, filters: dict | None = None\n) -&gt; str:\n    \"\"\"Start tcpdump capture on given interface.\n\n    :param fname: tcpdump output file name\n    :type fname: str\n    :param interface: interface name to be captured\n    :type interface: str\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n                    default to None\n    :type filters: dict | None\n    :return: return the process id of the tcpdump capture\n    :rtype: str\n    \"\"\"\n    return start_tcpdump(self._console, interface, None, fname, filters)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.start_tcpdump(fname)","title":"<code>fname</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.start_tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.start_tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.stop_tcpdump","title":"stop_tcpdump","text":"<pre><code>stop_tcpdump(pid: str) -&gt; None\n</code></pre> <p>Stop tcpdump process with given process id.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump process id</p> required Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def stop_tcpdump(self, pid: str) -&gt; None:\n    \"\"\"Stop tcpdump process with given process id.\n\n    :param pid: tcpdump process id\n    :type pid: str\n    \"\"\"\n    stop_tcpdump(self._console, pid)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.stop_tcpdump(pid)","title":"<code>pid</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.tftp","title":"tftp","text":"<pre><code>tftp(tftp_server_ip: str, source_file: str, dest_file: str, timeout: int = 60) -&gt; None\n</code></pre> <p>Transfer file via tftp.</p> <p>Parameters:</p> Name Type Description Default <code>tftp_server_ip</code> <p>tftp server ip</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Unable to find the source file</p> Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def tftp(\n    self, tftp_server_ip: str, source_file: str, dest_file: str, timeout: int = 60\n) -&gt; None:\n    \"\"\"Transfer file via tftp.\n\n    :param tftp_server_ip : tftp server ip\n    :type tftp_server_ip : str\n    :param source_file : source file name on device\n    :type source_file : str\n    :param dest_file : dest_file file name on device\n    :type dest_file : str\n    :param timeout : timeout for the tftp\n    :type timeout : int\n    :raises FileNotFoundError: Unable to find the source file\n    \"\"\"\n    tftp_cmd = f\"tftp -pl {source_file} {tftp_server_ip} -r {dest_file}\"\n    output = self._console.execute_command(tftp_cmd, timeout=timeout)\n\n    if \"can't open\" in output or \"No such file or directory\" in output:\n        msg = f\"Unable to perform tftp {output}\"\n        raise FileNotFoundError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.tftp()","title":"","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.traceroute_host","title":"traceroute_host","text":"<pre><code>traceroute_host(host_ip: str, version: str = '', options: str = '') -&gt; str\n</code></pre> <p>Run traceroute to given host ip and return result.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address of the host</p> required <code>str</code> <p>ip address version</p> <code>''</code> <code>str</code> <p>command line options to traceroute</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>output of traceroute</p> Source code in <code>boardfarm3/lib/network_utils.py</code> <pre><code>def traceroute_host(\n    self, host_ip: str, version: str = \"\", options: str = \"\"\n) -&gt; str:\n    \"\"\"Run traceroute to given host ip and return result.\n\n    :param host_ip: ip address of the host\n    :type host_ip: str\n    :param version: ip address version\n    :type version: str\n    :param options: command line options to traceroute\n    :type options: str\n    :return: output of traceroute\n    :rtype: str\n    \"\"\"\n    return traceroute_host(self._console, host_ip, version=version, options=options)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.traceroute_host(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.traceroute_host(version)","title":"<code>version</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.network_utils.NetworkUtility.traceroute_host(options)","title":"<code>options</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking","title":"networking","text":"<p>Boardfarm networking module.</p> <p>Classes:</p> Name Description <code>DNS</code> <p>Holds DNS names and their addresses.</p> <code>HTTPResult</code> <p>Class to save the object of parsed HTTP response.</p> <code>IptablesFirewall</code> <p>Linux iptables firewall.</p> <code>NSLookup</code> <p>NSLookup command line utility.</p> <p>Functions:</p> Name Description <code>dns_lookup</code> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <code>http_get</code> <p>Peform http get (via curl) and return parsed result.</p> <code>is_link_up</code> <p>Check given interface is up or not.</p> <code>nmap</code> <p>Run an nmap scan from source to destination device.</p> <code>scp</code> <p>SCP file.</p> <code>start_tcpdump</code> <p>Start tcpdump capture on given interface.</p> <code>stop_tcpdump</code> <p>Stop tcpdump capture.</p> <code>tcpdump_read</code> <p>Read the given tcpdump and delete the file afterwards.</p> <code>traceroute_host</code> <p>Traceroute given host ip and return the details.</p>"},{"location":"reference/libs/#boardfarm3.lib.networking.DNS","title":"DNS","text":"<pre><code>DNS(\n    console: _LinuxConsole,\n    device_name: str,\n    ipv4_address: str | None = None,\n    ipv6_address: str | None = None,\n    ipv4_aux_address: IPv4Address | None = None,\n    ipv6_aux_address: IPv6Address | None = None,\n    aux_url: str | None = None,\n)\n</code></pre> <p>Holds DNS names and their addresses.</p> <p>Initialize DNS.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>console or device instance</p> required <code>str</code> <p>device name</p> required <code>str | None</code> <p>ipv4 address of the device</p> <code>None</code> <code>str | None</code> <p>ipv6 address of the device</p> <code>None</code> <code>IPv4Address | None</code> <p>ipv4 aux address</p> <code>None</code> <code>IPv6Address | None</code> <p>ipv6 aux address</p> <code>None</code> <code>str | None</code> <p>aux url</p> <code>None</code> <p>Methods:</p> Name Description <code>configure_hosts</code> <p>Create the given number of reachable and unreachable ACS domain IP's.</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    console: _LinuxConsole,\n    device_name: str,\n    ipv4_address: str | None = None,\n    ipv6_address: str | None = None,\n    ipv4_aux_address: IPv4Address | None = None,\n    ipv6_aux_address: IPv6Address | None = None,\n    aux_url: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize DNS.\n\n    :param console: console or device instance\n    :type console: _LinuxConsole\n    :param device_name: device name\n    :type device_name: str\n    :param ipv4_address: ipv4 address of the device\n    :type ipv4_address: str\n    :param ipv6_address: ipv6 address of the device\n    :type ipv6_address: str\n    :param ipv4_aux_address: ipv4 aux address\n    :type ipv4_aux_address: IPv4Address\n    :param ipv6_aux_address: ipv6 aux address\n    :type ipv6_aux_address: IPv6Address\n    :param aux_url: aux url\n    :type aux_url: str\n    \"\"\"\n    self.auxv4 = ipv4_aux_address\n    self.auxv6 = ipv6_aux_address\n    self.dnsv4: defaultdict = defaultdict(list)\n    self.dnsv6: defaultdict = defaultdict(list)\n    self.hosts_v4: defaultdict = defaultdict(list)\n    self.hosts_v6: defaultdict = defaultdict(list)\n    self.fqdn = f\"{device_name}.boardfarm.com\"\n    self._add_dns_addresses(ipv4_address, ipv6_address)\n    self._add_aux_dns_addresses(aux_url)\n    self.hosts_v4.update(self.dnsv4)\n    self.hosts_v6.update(self.dnsv6)\n    self.nslookup = NSLookup(console)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.DNS(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS(device_name)","title":"<code>device_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS(ipv4_address)","title":"<code>ipv4_address</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS(ipv6_address)","title":"<code>ipv6_address</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS(ipv4_aux_address)","title":"<code>ipv4_aux_address</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS(ipv6_aux_address)","title":"<code>ipv6_aux_address</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS(aux_url)","title":"<code>aux_url</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS.configure_hosts","title":"configure_hosts","text":"<pre><code>configure_hosts(\n    reachable_ipv4: int,\n    unreachable_ipv4: int,\n    reachable_ipv6: int,\n    unreachable_ipv6: int,\n) -&gt; None\n</code></pre> <p>Create the given number of reachable and unreachable ACS domain IP's.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>no.of reachable IPv4 address for acs url</p> required <code>int</code> <p>no.of unreachable IPv4 address for acs url</p> required <code>int</code> <p>no.of reachable IPv6 address for acs url</p> required <code>int</code> <p>no.of unreachable IPv6 address for acs url</p> required Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def configure_hosts(\n    self,\n    reachable_ipv4: int,\n    unreachable_ipv4: int,\n    reachable_ipv6: int,\n    unreachable_ipv6: int,\n) -&gt; None:\n    \"\"\"Create the given number of reachable and unreachable ACS domain IP's.\n\n    :param reachable_ipv4: no.of reachable IPv4 address for acs url\n    :type reachable_ipv4: int\n    :param unreachable_ipv4: no.of unreachable IPv4 address for acs url\n    :type unreachable_ipv4: int\n    :param reachable_ipv6: no.of reachable IPv6 address for acs url\n    :type reachable_ipv6: int\n    :param unreachable_ipv6: no.of unreachable IPv6 address for acs url\n    :type unreachable_ipv6: int\n    \"\"\"\n    val_v4 = self.hosts_v4[self.fqdn][:reachable_ipv4]\n    val_v6 = self.hosts_v6[self.fqdn][:reachable_ipv6]\n    self.hosts_v4[self.fqdn] = val_v4\n    self.hosts_v6[self.fqdn] = val_v6\n    for val in range(unreachable_ipv4):\n        ipv4 = self.auxv4 + (val + 1)\n        self.hosts_v4[self.fqdn].append(str(ipv4))\n    for val in range(unreachable_ipv6):\n        ipv6 = self.auxv6 + (val + 1)\n        self.hosts_v6[self.fqdn].append(str(ipv6))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.DNS.configure_hosts(reachable_ipv4)","title":"<code>reachable_ipv4</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS.configure_hosts(unreachable_ipv4)","title":"<code>unreachable_ipv4</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS.configure_hosts(reachable_ipv6)","title":"<code>reachable_ipv6</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.DNS.configure_hosts(unreachable_ipv6)","title":"<code>unreachable_ipv6</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.HTTPResult","title":"HTTPResult","text":"<pre><code>HTTPResult(response: str)\n</code></pre> <p>Class to save the object of parsed HTTP response.</p> <p>Parse the response and save it as an instance.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>response from HTTP request</p> required Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def __init__(self, response: str) -&gt; None:\n    \"\"\"Parse the response and save it as an instance.\n\n    :param response: response from HTTP request\n    :type response: str\n    \"\"\"\n    self.response = response\n    self.raw, self.code, self.beautified_text = self._parse_response(response)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.HTTPResult(response)","title":"<code>response</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall","title":"IptablesFirewall","text":"<pre><code>IptablesFirewall(console: _LinuxConsole)\n</code></pre> <p>Linux iptables firewall.</p> <p>Initialize IptablesFirewall.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>linux console or device instance</p> required <p>Methods:</p> Name Description <code>add_drop_rule_ip6tables</code> <p>Add drop rule to ip6tables.</p> <code>add_drop_rule_iptables</code> <p>Add drop rule to iptables.</p> <code>del_drop_rule_ip6tables</code> <p>Delete drop rule from ip6tables.</p> <code>del_drop_rule_iptables</code> <p>Delete drop rule from iptables.</p> <code>get_ip6tables_list</code> <p>Return ip6tables rules as dictionary.</p> <code>get_ip6tables_policy</code> <p>Return ip6tables policies as dictionary.</p> <code>get_iptables_list</code> <p>Return iptables rules as dictionary.</p> <code>get_iptables_policy</code> <p>Return iptables policies as dictionary.</p> <code>is_ip6table_empty</code> <p>Return True if ip6tables is empty.</p> <code>is_iptable_empty</code> <p>Return True if iptables is empty.</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def __init__(self, console: _LinuxConsole) -&gt; None:\n    \"\"\"Initialize IptablesFirewall.\n\n    :param console: linux console or device instance\n    :type console: _LinuxConsole\n    \"\"\"\n    self._console = console\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.add_drop_rule_ip6tables","title":"add_drop_rule_ip6tables","text":"<pre><code>add_drop_rule_ip6tables(option: str, valid_ip: str) -&gt; None\n</code></pre> <p>Add drop rule to ip6tables.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip6tables command line options</p> required <code>str</code> <p>ip to be blocked from device</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>on given ip6tables rule can't be added</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def add_drop_rule_ip6tables(self, option: str, valid_ip: str) -&gt; None:\n    \"\"\"Add drop rule to ip6tables.\n\n    :param option: ip6tables command line options\n    :type option: str\n    :param valid_ip: ip to be blocked from device\n    :type valid_ip: str\n    :raises ValueError: on given ip6tables rule can't be added\n    \"\"\"\n    ip6tables_output = self._console.execute_command(\n        f\"ip6tables -C INPUT {option} {valid_ip} -j DROP\",\n    )\n    if \"Bad rule\" in ip6tables_output:\n        self._console.execute_command(\n            f\"ip6tables -I INPUT 1 {option} {valid_ip} -j DROP\",\n        )\n    if re.search(rf\"host\\/network.*{valid_ip}.*not found\", ip6tables_output):\n        msg = (\n            \"Firewall rule cannot be added as the ip address: \"\n            f\"{valid_ip} could not be found\"\n        )\n        raise ValueError(\n            msg,\n        )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.add_drop_rule_ip6tables(option)","title":"<code>option</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.add_drop_rule_ip6tables(valid_ip)","title":"<code>valid_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.add_drop_rule_iptables","title":"add_drop_rule_iptables","text":"<pre><code>add_drop_rule_iptables(option: str, valid_ip: str) -&gt; None\n</code></pre> <p>Add drop rule to iptables.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>iptables command line options</p> required <code>str</code> <p>ip to be blocked from device</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>on given iptables rule can't be added</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def add_drop_rule_iptables(self, option: str, valid_ip: str) -&gt; None:\n    \"\"\"Add drop rule to iptables.\n\n    :param option: iptables command line options\n    :type option: str\n    :param valid_ip: ip to be blocked from device\n    :type valid_ip: str\n    :raises ValueError: on given iptables rule can't be added\n    \"\"\"\n    iptables_output = self._console.execute_command(\n        f\"iptables -C INPUT {option} {valid_ip} -j DROP\",\n    )\n    if \"Bad rule\" in iptables_output:\n        self._console.execute_command(\n            f\"iptables -I INPUT 1 {option} {valid_ip} -j DROP\",\n        )\n    if re.search(rf\"host\\/network.*{valid_ip}.*not found\", iptables_output):\n        msg = (\n            \"Firewall rule cannot be added as the ip address: \"\n            f\"{valid_ip} could not be found\"\n        )\n        raise ValueError(\n            msg,\n        )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.add_drop_rule_iptables(option)","title":"<code>option</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.add_drop_rule_iptables(valid_ip)","title":"<code>valid_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.del_drop_rule_ip6tables","title":"del_drop_rule_ip6tables","text":"<pre><code>del_drop_rule_ip6tables(option: str, valid_ip: str) -&gt; None\n</code></pre> <p>Delete drop rule from ip6tables.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip6tables command line options</p> required <code>str</code> <p>ip to be unblocked</p> required Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def del_drop_rule_ip6tables(self, option: str, valid_ip: str) -&gt; None:\n    \"\"\"Delete drop rule from ip6tables.\n\n    :param option: ip6tables command line options\n    :type option: str\n    :param valid_ip: ip to be unblocked\n    :type valid_ip: str\n    \"\"\"\n    self._console.execute_command(f\"ip6tables -D INPUT {option} {valid_ip} -j DROP\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.del_drop_rule_ip6tables(option)","title":"<code>option</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.del_drop_rule_ip6tables(valid_ip)","title":"<code>valid_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.del_drop_rule_iptables","title":"del_drop_rule_iptables","text":"<pre><code>del_drop_rule_iptables(option: str, valid_ip: str) -&gt; None\n</code></pre> <p>Delete drop rule from iptables.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>iptables command line options</p> required <code>str</code> <p>ip to be unblocked</p> required Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def del_drop_rule_iptables(self, option: str, valid_ip: str) -&gt; None:\n    \"\"\"Delete drop rule from iptables.\n\n    :param option: iptables command line options\n    :type option: str\n    :param valid_ip: ip to be unblocked\n    :type valid_ip: str\n    \"\"\"\n    self._console.execute_command(f\"iptables -D INPUT {option} {valid_ip} -j DROP\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.del_drop_rule_iptables(option)","title":"<code>option</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.del_drop_rule_iptables(valid_ip)","title":"<code>valid_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_ip6tables_list","title":"get_ip6tables_list","text":"<pre><code>get_ip6tables_list(opts: str = '', extra_opts: str = '') -&gt; dict[str, list[dict]]\n</code></pre> <p>Return ip6tables rules as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command line arguments for ip6tables command</p> <code>''</code> <code>str</code> <p>extra command line arguments for ip6tables command</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>ip6tables rules dictionary</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def get_ip6tables_list(\n    self,\n    opts: str = \"\",\n    extra_opts: str = \"\",\n) -&gt; dict[str, list[dict]]:\n    \"\"\"Return ip6tables rules as dictionary.\n\n    :param opts: command line arguments for ip6tables command\n    :type opts: str\n    :param extra_opts: extra command line arguments for ip6tables command\n    :type extra_opts: str\n    :return: ip6tables rules dictionary\n    :rtype: Dict[str, List[Dict]]\n    \"\"\"\n    return IptablesParser().ip6tables(\n        self._console.execute_command(f\"ip6tables {opts} {extra_opts}\"),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_ip6tables_list(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_ip6tables_list(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_ip6tables_policy","title":"get_ip6tables_policy","text":"<pre><code>get_ip6tables_policy(\n    opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; dict[str, str]\n</code></pre> <p>Return ip6tables policies as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command line arguments for iptables command</p> <code>''</code> <code>str</code> <p>options for iptables command, defaults to -nvL --line-number</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>iptables policies dictionary</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def get_ip6tables_policy(\n    self,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; dict[str, str]:\n    \"\"\"Return ip6tables policies as dictionary.\n\n    :param opts: command line arguments for iptables command\n    :type opts: str\n    :param extra_opts: options for iptables command, defaults to -nvL --line-number\n    :type extra_opts: str\n    :return: iptables policies dictionary\n    :rtype: dict[str, str]\n    \"\"\"\n    return IptablesParser().iptables_policy(\n        self._console.execute_command(f\"ip6tables {opts} {extra_opts}\"),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_ip6tables_policy(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_ip6tables_policy(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_iptables_list","title":"get_iptables_list","text":"<pre><code>get_iptables_list(opts: str = '', extra_opts: str = '') -&gt; dict[str, list[dict]]\n</code></pre> <p>Return iptables rules as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command line arguments for iptables command</p> <code>''</code> <code>str</code> <p>extra command line arguments for iptables command</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>iptables rules dictionary</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def get_iptables_list(\n    self,\n    opts: str = \"\",\n    extra_opts: str = \"\",\n) -&gt; dict[str, list[dict]]:\n    \"\"\"Return iptables rules as dictionary.\n\n    :param opts: command line arguments for iptables command\n    :type opts: str\n    :param extra_opts: extra command line arguments for iptables command\n    :type extra_opts: str\n    :return: iptables rules dictionary\n    :rtype: Dict[str, List[Dict]]\n    \"\"\"\n    return IptablesParser().iptables(\n        self._console.execute_command(f\"iptables {opts} {extra_opts}\"),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_iptables_list(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_iptables_list(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_iptables_policy","title":"get_iptables_policy","text":"<pre><code>get_iptables_policy(\n    opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; dict[str, str]\n</code></pre> <p>Return iptables policies as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command line arguments for iptables command</p> <code>''</code> <code>str</code> <p>options for iptables command, defaults to -nvL --line-number</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>iptables policies dictionary</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def get_iptables_policy(\n    self,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; dict[str, str]:\n    \"\"\"Return iptables policies as dictionary.\n\n    :param opts: command line arguments for iptables command\n    :type opts: str\n    :param extra_opts: options for iptables command, defaults to -nvL --line-number\n    :type extra_opts: str\n    :return: iptables policies dictionary\n    :rtype: dict[str, str]\n    \"\"\"\n    return IptablesParser().iptables_policy(\n        self._console.execute_command(f\"iptables {opts} {extra_opts}\"),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_iptables_policy(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.get_iptables_policy(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.is_ip6table_empty","title":"is_ip6table_empty","text":"<pre><code>is_ip6table_empty(opts: str = '', extra_opts: str = '') -&gt; bool\n</code></pre> <p>Return True if ip6tables is empty.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command line arguments for ip6tables command</p> <code>''</code> <code>str</code> <p>extra command line arguments for ip6tables command</p> <code>''</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if ip6tables is empty, False otherwise</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def is_ip6table_empty(self, opts: str = \"\", extra_opts: str = \"\") -&gt; bool:\n    \"\"\"Return True if ip6tables is empty.\n\n    :param opts: command line arguments for ip6tables command\n    :type opts: str\n    :param extra_opts: extra command line arguments for ip6tables command\n    :type extra_opts: str\n    :return: True if ip6tables is empty, False otherwise\n    :rtype: bool\n    \"\"\"\n    return not any(self.get_ip6tables_list(opts, extra_opts).values())\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.is_ip6table_empty(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.is_ip6table_empty(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.is_iptable_empty","title":"is_iptable_empty","text":"<pre><code>is_iptable_empty(opts: str = '', extra_opts: str = '') -&gt; bool\n</code></pre> <p>Return True if iptables is empty.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>command line arguments for iptables command</p> <code>''</code> <code>str</code> <p>extra command line arguments for iptables command</p> <code>''</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if iptables is empty, False otherwise</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def is_iptable_empty(self, opts: str = \"\", extra_opts: str = \"\") -&gt; bool:\n    \"\"\"Return True if iptables is empty.\n\n    :param opts: command line arguments for iptables command\n    :type opts: str\n    :param extra_opts: extra command line arguments for iptables command\n    :type extra_opts: str\n    :return: True if iptables is empty, False otherwise\n    :rtype: bool\n    \"\"\"\n    return not any(self.get_iptables_list(opts, extra_opts).values())\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.is_iptable_empty(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.IptablesFirewall.is_iptable_empty(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup","title":"NSLookup","text":"<pre><code>NSLookup(console: _LinuxConsole)\n</code></pre> <p>NSLookup command line utility.</p> <p>Initialize NSLookup.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>console or device instance</p> required <p>Methods:</p> Name Description <code>__call__</code> <p>Run nslookup with given arguments and return the parsed results.</p> <code>nslookup</code> <p>Run nslookup with given arguments and return the parsed results.</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def __init__(self, console: _LinuxConsole) -&gt; None:\n    \"\"\"Initialize NSLookup.\n\n    :param console: console or device instance\n    :type console: _LinuxConsole\n    \"\"\"\n    self._hw = console\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.__call__","title":"__call__","text":"<pre><code>__call__(domain_name: str, opts: str = '', extra_opts: str = '') -&gt; dict[str, Any]\n</code></pre> <p>Run nslookup with given arguments and return the parsed results.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>domain name to perform nslookup on</p> required <code>str</code> <p>nslookup command line options</p> <code>''</code> <code>str</code> <p>nslookup additional command line options</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>parsed nslookup results as dictionary</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def __call__(\n    self,\n    domain_name: str,\n    opts: str = \"\",\n    extra_opts: str = \"\",\n) -&gt; dict[str, Any]:\n    \"\"\"Run nslookup with given arguments and return the parsed results.\n\n    :param domain_name: domain name to perform nslookup on\n    :type domain_name: str\n    :param opts: nslookup command line options\n    :type opts: str\n    :param extra_opts: nslookup additional command line options\n    :type extra_opts: str\n    :return: parsed nslookup results as dictionary\n    :rtype: Dict[str, Any]\n    \"\"\"\n    return self.nslookup(domain_name, opts, extra_opts)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.__call__(domain_name)","title":"<code>domain_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.__call__(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.__call__(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.nslookup","title":"nslookup","text":"<pre><code>nslookup(domain_name: str, opts: str = '', extra_opts: str = '') -&gt; dict[str, Any]\n</code></pre> <p>Run nslookup with given arguments and return the parsed results.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>domain name to perform nslookup on</p> required <code>str</code> <p>nslookup command line options</p> <code>''</code> <code>str</code> <p>nslookup additional command line options</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>parsed nslookup results as dictionary</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def nslookup(\n    self,\n    domain_name: str,\n    opts: str = \"\",\n    extra_opts: str = \"\",\n) -&gt; dict[str, Any]:\n    \"\"\"Run nslookup with given arguments and return the parsed results.\n\n    :param domain_name: domain name to perform nslookup on\n    :type domain_name: str\n    :param opts: nslookup command line options\n    :type opts: str\n    :param extra_opts: nslookup additional command line options\n    :type extra_opts: str\n    :return: parsed nslookup results as dictionary\n    :rtype: Dict[str, Any]\n    \"\"\"\n    return NslookupParser().parse_nslookup_output(\n        self._hw.execute_command(f\"nslookup {opts} {domain_name} {extra_opts}\"),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.nslookup(domain_name)","title":"<code>domain_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.nslookup(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.NSLookup.nslookup(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.dns_lookup","title":"dns_lookup","text":"<pre><code>dns_lookup(\n    console: _LinuxConsole, domain_name: str, record_type: str, opts: str = \"\"\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>console or device instance</p> required <code>str</code> <p>domain name which needs lookup</p> required <code>str</code> <p>AAAA for ipv6 else A</p> required <code>str</code> <p>options to be provided to dig command, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>parsed dig command ouput</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def dns_lookup(\n    console: _LinuxConsole, domain_name: str, record_type: str, opts: str = \"\"\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Perform ``dig`` command in the devices to resolve DNS.\n\n    :param console: console or device instance\n    :type console: _LinuxConsole\n    :param domain_name: domain name which needs lookup\n    :type domain_name: str\n    :param record_type: AAAA for ipv6 else A\n    :type record_type: str\n    :param opts: options to be provided to dig command, defaults to \"\"\n    :type opts: str\n    :return: parsed dig command ouput\n    :rtype: List[Dict[str, Any]]\n    \"\"\"\n    return dig.parse(\n        console.execute_command(f\"dig {opts} {record_type} {domain_name}\").split(\n            \";\", 1\n        )[-1]\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.dns_lookup(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.dns_lookup(domain_name)","title":"<code>domain_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.dns_lookup(record_type)","title":"<code>record_type</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.dns_lookup(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.http_get","title":"http_get","text":"<pre><code>http_get(\n    console: _LinuxConsole, url: str, timeout: int = 20, options: str = \"\"\n) -&gt; HTTPResult\n</code></pre> <p>Peform http get (via curl) and return parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>console or device instance</p> required <code>str</code> <p>url to get the response</p> required <code>int</code> <p>connection timeout for the curl command in seconds</p> <code>20</code> <code>str</code> <p>additional curl command line options, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>HTTPResult</code> <p>parsed http response</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def http_get(\n    console: _LinuxConsole, url: str, timeout: int = 20, options: str = \"\"\n) -&gt; HTTPResult:\n    \"\"\"Peform http get (via curl) and return parsed result.\n\n    :param console: console or device instance\n    :type console: _LinuxConsole\n    :param url: url to get the response\n    :type url: str\n    :param timeout: connection timeout for the curl command in seconds\n    :type timeout: int\n    :param options: additional curl command line options, defaults to \"\"\n    :type options: str\n    :return: parsed http response\n    :rtype: HTTPResult\n    \"\"\"\n    return HTTPResult(\n        console.execute_command(f\"curl -v {options} --connect-timeout {timeout} {url}\"),\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.http_get(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.http_get(url)","title":"<code>url</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.http_get(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.http_get(options)","title":"<code>options</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.is_link_up","title":"is_link_up","text":"<pre><code>is_link_up(\n    console: _LinuxConsole, interface: str, pattern: str = \"BROADCAST,MULTICAST,UP\"\n) -&gt; bool\n</code></pre> <p>Check given interface is up or not.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>console or device instance</p> required <code>str</code> <p>interface name, defaults to \"BROADCAST,MULTICAST,UP\"</p> required <code>str</code> <p>interface state</p> <code>'BROADCAST,MULTICAST,UP'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the link is up</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def is_link_up(\n    console: _LinuxConsole,\n    interface: str,\n    pattern: str = \"BROADCAST,MULTICAST,UP\",\n) -&gt; bool:\n    \"\"\"Check given interface is up or not.\n\n    :param console: console or device instance\n    :type console: _LinuxConsole\n    :param interface: interface name, defaults to \"BROADCAST,MULTICAST,UP\"\n    :type interface: str\n    :param pattern: interface state\n    :type pattern: str\n    :return: True if the link is up\n    :rtype: bool\n    \"\"\"\n    return pattern in console.execute_command(f\"ip link show {interface}\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.is_link_up(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.is_link_up(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.is_link_up(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap","title":"nmap","text":"<pre><code>nmap(\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict[str, str]\n</code></pre> <p>Run an nmap scan from source to destination device.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN | WAN</code> <p>device initiating the scan</p> required <code>LAN | WLAN | WAN | CPE</code> <p>device to be scanned</p> required <code>str</code> <p>IP version to use in scan, must be \"ipv4\" or \"ipv6\"</p> required <code>str | int | None</code> <p>port or port range to scan, optional</p> <code>None</code> <code>str | None</code> <p>protocol to scan (e.g., tcp, udp), optional</p> <code>None</code> <code>int | None</code> <p>maximum number of retransmissions, optional</p> <code>None</code> <code>int | None</code> <p>minimum number of packets per second to send, optional</p> <code>None</code> <code>str | None</code> <p>additional nmap command-line options, optional</p> <code>None</code> <code>int</code> <p>timeout value for the scan (in seconds), defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>parsed nmap scan result as a dictionary</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def nmap(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict[str, str]:\n    \"\"\"Run an nmap scan from source to destination device.\n\n    :param source_device: device initiating the scan\n    :type source_device: LAN | WLAN | WAN\n    :param destination_device: device to be scanned\n    :type destination_device: LAN | WLAN | WAN | CPE\n    :param ip_type: IP version to use in scan, must be \"ipv4\" or \"ipv6\"\n    :type ip_type: str\n    :param port: port or port range to scan, optional\n    :type port: str | int | None\n    :param protocol: protocol to scan (e.g., tcp, udp), optional\n    :type protocol: str | None\n    :param max_retries: maximum number of retransmissions, optional\n    :type max_retries: int | None\n    :param min_rate: minimum number of packets per second to send, optional\n    :type min_rate: int | None\n    :param opts: additional nmap command-line options, optional\n    :type opts: str | None\n    :param timeout: timeout value for the scan (in seconds), defaults to 30\n    :type timeout: int\n    :return: parsed nmap scan result as a dictionary\n    :rtype: dict[str, str]\n    \"\"\"\n    iface: str = (\n        destination_device.sw.erouter_iface\n        if isinstance(destination_device, CPE)\n        else destination_device.iface_dut\n    )\n    dest_device: LAN | WLAN | WAN | CPESW = (\n        destination_device.sw\n        if isinstance(destination_device, CPE)\n        else destination_device\n    )\n    ipaddr: str = (\n        dest_device.get_interface_ipv4addr(iface)\n        if ip_type == \"ipv4\"\n        else f\"-6 {dest_device.get_interface_ipv6addr(iface)}\"\n    )\n    return source_device.nmap(\n        ipaddr, ip_type, port, protocol, max_retries, min_rate, opts, timeout=timeout\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(min_rate)","title":"<code>min_rate</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.nmap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp","title":"scp","text":"<pre><code>scp(\n    console: _LinuxConsole,\n    host: str,\n    port: int | str,\n    username: str,\n    password: str,\n    src_path: str,\n    dst_path: str,\n    action: Literal[\"download\", \"upload\"] = \"download\",\n    timeout: int = 30,\n) -&gt; None\n</code></pre> <p>SCP file.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>linux device or console instance</p> required <code>str</code> <p>remote ssh host ip address</p> required <code>int | str</code> <p>remove ssh host port number</p> required <code>str</code> <p>ssh username</p> required <code>str</code> <p>ssh password</p> required <code>str</code> <p>source file path</p> required <code>str</code> <p>destination path</p> required <code>Literal['download', 'upload']</code> <p>scp action(download/upload), defaults to \"download\"</p> <code>'download'</code> <code>int</code> <p>scp timeout in seconds, defaults to 30</p> <code>30</code> <p>Raises:</p> Type Description <code>SCPConnectionError</code> <p>on failed to scp file</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def scp(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    console: _LinuxConsole,\n    host: str,\n    port: int | str,\n    username: str,\n    password: str,\n    src_path: str,\n    dst_path: str,\n    action: Literal[\"download\", \"upload\"] = \"download\",\n    timeout: int = 30,\n) -&gt; None:\n    \"\"\"SCP file.\n\n    :param console: linux device or console instance\n    :type console: _LinuxConsole\n    :param host: remote ssh host ip address\n    :type host: str\n    :param port: remove ssh host port number\n    :type port: Union[int, str]\n    :param username: ssh username\n    :type username: str\n    :param password: ssh password\n    :type password: str\n    :param src_path: source file path\n    :type src_path: str\n    :param dst_path: destination path\n    :type dst_path: str\n    :param action: scp action(download/upload), defaults to \"download\"\n    :type action: Literal[\"download\", \"upload\"], optional\n    :param timeout: scp timeout in seconds, defaults to 30\n    :type timeout: int\n    :raises SCPConnectionError: on failed to scp file\n    \"\"\"\n    host = host if isinstance(ip_address(host), IPv4Address) else f\"[{host}]\"\n    if action == \"download\":\n        command = (\n            \"scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null\"\n            f\" -P {port} {username}@{host}:{src_path} {dst_path}\"\n        )\n    else:\n        command = (\n            \"scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null\"\n            f\" -P {port} {src_path} {username}@{host}:{dst_path}\"\n        )\n    console.sendline(command)\n    if console.expect([pexpect.TIMEOUT, \"continue connecting?\"], timeout=10):\n        console.sendline(\"y\")\n    if console.expect([pexpect.TIMEOUT, \"assword:\"], timeout=10):\n        console.sendline(password)\n    if console.expect_exact([\"100%\", pexpect.TIMEOUT], timeout=timeout):\n        msg = f\"Failed to scp from {src_path} to {dst_path}\"\n        raise SCPConnectionError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.scp(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(host)","title":"<code>host</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(username)","title":"<code>username</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(password)","title":"<code>password</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(src_path)","title":"<code>src_path</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(dst_path)","title":"<code>dst_path</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(action)","title":"<code>action</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.scp(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.start_tcpdump","title":"start_tcpdump","text":"<pre><code>start_tcpdump(\n    console: _LinuxConsole,\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str\n</code></pre> <p>Start tcpdump capture on given interface.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>console or device instance</p> required <code>str</code> <p>inteface name where packets to be captured</p> required <code>str | None</code> <p>port number, can be a range of ports(eg: 443 or 433-443)</p> required <code>str</code> <p>pcap file name, Defaults: pkt_capture.pcap</p> <code>'pkt_capture.pcap'</code> <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})</p> <code>None</code> <code>str | None</code> <p>additional filters</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>console ouput and tcpdump process id</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on failed to start tcpdump</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def start_tcpdump(  # noqa: PLR0913\n    console: _LinuxConsole,\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str:\n    \"\"\"Start tcpdump capture on given interface.\n\n    :param console: console or device instance\n    :type console: _LinuxConsole\n    :param interface: inteface name where packets to be captured\n    :type interface: str\n    :param port: port number, can be a range of ports(eg: 443 or 433-443)\n    :type port: str\n    :param output_file: pcap file name, Defaults: pkt_capture.pcap\n    :type output_file: str\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n    :type filters: Optional[Dict]\n    :param additional_filters: additional filters\n    :type additional_filters: Optional[str]\n    :raises ValueError: on failed to start tcpdump\n    :return: console ouput and tcpdump process id\n    :rtype: str\n    \"\"\"\n    command = f\"tcpdump -U -i {interface} -n -w {output_file} \"\n    filter_str = (\n        \" \".join([\" \".join(i) for i in filters.items()]) if filters is not None else \"\"\n    )\n    filter_str += additional_filters\n    if port:\n        output = console.execute_command(f\"{command} 'portrange {port}' {filter_str} &amp;\")\n    else:\n        output = console.execute_command(f\"{command} {filter_str} &amp;\")\n    if console.expect_exact([f\"tcpdump: listening on {interface}\", pexpect.TIMEOUT]):\n        msg = f\"Failed to start tcpdump on {interface}\"\n        raise ValueError(msg)\n    return re.search(r\"(\\[\\d+\\]\\s(\\d+))\", output)[2]\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.start_tcpdump(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.start_tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.start_tcpdump(port)","title":"<code>port</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.start_tcpdump(output_file)","title":"<code>output_file</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.start_tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.start_tcpdump(additional_filters)","title":"<code>additional_filters</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.stop_tcpdump","title":"stop_tcpdump","text":"<pre><code>stop_tcpdump(console: _LinuxConsole, process_id: str) -&gt; None\n</code></pre> <p>Stop tcpdump capture.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>linux console or device instance</p> required <code>str</code> <p>tcpdump process id</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>on failed to stop tcpdump process</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def stop_tcpdump(console: _LinuxConsole, process_id: str) -&gt; None:\n    \"\"\"Stop tcpdump capture.\n\n    :param console: linux console or device instance\n    :type console: _LinuxConsole\n    :param process_id: tcpdump process id\n    :type process_id: str\n    :raises ValueError: on failed to stop tcpdump process\n    \"\"\"\n    output = console.execute_command(f\"kill {process_id}\")\n    if \"packets captured\" not in output:\n        idx = console.expect_exact([\"captured\", pexpect.TIMEOUT])\n        if idx:\n            msg = f\"Failed to stop tcpdump process with PID {process_id}\"\n            raise ValueError(msg)\n    console.execute_command(\"sync\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.stop_tcpdump(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.stop_tcpdump(process_id)","title":"<code>process_id</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.tcpdump_read","title":"tcpdump_read","text":"<pre><code>tcpdump_read(\n    console: _LinuxConsole,\n    capture_file: str,\n    protocol: str = \"\",\n    opts: str = \"\",\n    timeout: int = 30,\n    rm_pcap: bool = True,\n) -&gt; str\n</code></pre> <p>Read the given tcpdump and delete the file afterwards.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>linux device or console instance</p> required <code>str</code> <p>pcap file path</p> required <code>str</code> <p>protocol to the filter</p> <code>''</code> <code>str</code> <p>command line options for reading pcap</p> <code>''</code> <code>int</code> <p>timeout in seconds for reading pcap</p> <code>30</code> <code>bool</code> <p>romove pcap file afterwards</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>tcpdump output</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def tcpdump_read(  # noqa: PLR0913\n    console: _LinuxConsole,\n    capture_file: str,\n    protocol: str = \"\",\n    opts: str = \"\",\n    timeout: int = 30,\n    rm_pcap: bool = True,\n) -&gt; str:\n    \"\"\"Read the given tcpdump and delete the file afterwards.\n\n    :param console: linux device or console instance\n    :type console: _LinuxConsole\n    :param capture_file: pcap file path\n    :type capture_file: str\n    :param protocol: protocol to the filter\n    :type protocol: str\n    :param opts: command line options for reading pcap\n    :type opts: str\n    :param timeout: timeout in seconds for reading pcap\n    :type timeout: int\n    :param rm_pcap: romove pcap file afterwards\n    :type rm_pcap: bool\n    :return: tcpdump output\n    :rtype: str\n    \"\"\"\n    if opts:\n        protocol = f\"{protocol} and {opts}\"\n    tcpdump_output = console.execute_command(\n        f\"tcpdump -n -r {capture_file} {protocol}\",\n        timeout=timeout,\n    )\n    if rm_pcap:\n        console.execute_command(f\"rm {capture_file}\")\n    return tcpdump_output\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.tcpdump_read(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.tcpdump_read(capture_file)","title":"<code>capture_file</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.tcpdump_read(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.tcpdump_read(opts)","title":"<code>opts</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.tcpdump_read(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.tcpdump_read(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.traceroute_host","title":"traceroute_host","text":"<pre><code>traceroute_host(\n    console: _LinuxConsole, host_ip: str, version: str = \"\", options: str = \"\"\n) -&gt; str\n</code></pre> <p>Traceroute given host ip and return the details.</p> <p>Parameters:</p> Name Type Description Default <code>_LinuxConsole</code> <p>linux device or console instance</p> required <code>str</code> <p>host ip address</p> required <code>str</code> <p>ip version</p> <code>''</code> <code>str</code> <p>additional command line options</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>traceroute command output</p> Source code in <code>boardfarm3/lib/networking.py</code> <pre><code>def traceroute_host(\n    console: _LinuxConsole,\n    host_ip: str,\n    version: str = \"\",\n    options: str = \"\",\n) -&gt; str:\n    \"\"\"Traceroute given host ip and return the details.\n\n    :param console: linux device or console instance\n    :type console: _LinuxConsole\n    :param host_ip: host ip address\n    :type host_ip: str\n    :param version: ip version\n    :type version: str\n    :param options: additional command line options\n    :type options: str\n    :return: traceroute command output\n    :rtype: str\n    \"\"\"\n    return console.execute_command(\n        f\"traceroute{version} {options} {host_ip}\",\n        timeout=90,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.networking.traceroute_host(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.traceroute_host(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.traceroute_host(version)","title":"<code>version</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.networking.traceroute_host(options)","title":"<code>options</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.odh","title":"odh","text":"<p>Boardfarm ODH client Package.</p> <p>Modules:</p> Name Description <code>kafka_client</code> <p>Kafka client implementation.</p>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client","title":"kafka_client","text":"<p>Kafka client implementation.</p> <p>Classes:</p> Name Description <code>KafkaClient</code> <p>Kafka client implementation.</p>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient","title":"KafkaClient","text":"<pre><code>KafkaClient(bootstrap_server: str, topic_name: str)\n</code></pre> <p>Kafka client implementation.</p> <p>Initialize the kafka client.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Kafka server url</p> required <code>str</code> <p>the topic to subscribe to</p> required <p>Methods:</p> Name Description <code>close_connection_to_kafka</code> <p>Gracefully close the connection to the kafka server.</p> <code>consume_logs</code> <p>Consume logs from the kafka queue for a particular duration.</p> <code>consume_sw_update_logs</code> <p>Consume logs from the kafka queue for given time using offsets.</p> <code>read_kafka_messages</code> <p>Read a given number of messages from the kafka queue.</p> <code>subscribe_to_topic</code> <p>Subscribe to a list topics.</p> Source code in <code>boardfarm3/lib/odh/kafka_client.py</code> <pre><code>def __init__(self, bootstrap_server: str, topic_name: str) -&gt; None:\n    \"\"\"Initialize the kafka client.\n\n    :param bootstrap_server: Kafka server url\n    :type bootstrap_server: str\n    :param topic_name: the topic to subscribe to\n    :type topic_name: str\n    \"\"\"\n    self.topic = topic_name\n    self._disable_log_messages_from_libraries()\n    self._consumer = KafkaConsumer(\n        topic_name,\n        bootstrap_servers=bootstrap_server,\n        auto_offset_reset=\"latest\",\n        enable_auto_commit=True,\n        value_deserializer=self._deserialize_json,\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient(bootstrap_server)","title":"<code>bootstrap_server</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient(topic_name)","title":"<code>topic_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.close_connection_to_kafka","title":"close_connection_to_kafka","text":"<pre><code>close_connection_to_kafka() -&gt; None\n</code></pre> <p>Gracefully close the connection to the kafka server.</p> Source code in <code>boardfarm3/lib/odh/kafka_client.py</code> <pre><code>def close_connection_to_kafka(self) -&gt; None:\n    \"\"\"Gracefully close the connection to the kafka server.\"\"\"\n    self._consumer.close()\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.consume_logs","title":"consume_logs","text":"<pre><code>consume_logs(time_period: int) -&gt; list[Any]\n</code></pre> <p>Consume logs from the kafka queue for a particular duration.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>time (in s) for which to consume logs from the queue.</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>kafka logs</p> Source code in <code>boardfarm3/lib/odh/kafka_client.py</code> <pre><code>def consume_logs(self, time_period: int) -&gt; list[Any]:\n    \"\"\"Consume logs from the kafka queue for a particular duration.\n\n    :param time_period: time (in s) for which to consume logs from the queue.\n    :type time_period: int\n    :return: kafka logs\n    :rtype: list[Any]\n    \"\"\"\n    logs = []\n    start_time = monotonic()\n    while monotonic() &lt; time_period + start_time:\n        for _, log in self._consumer.poll(timeout_ms=1000).items():  # noqa: PERF102\n            logs.extend(log)\n    return logs\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.consume_logs(time_period)","title":"<code>time_period</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.consume_sw_update_logs","title":"consume_sw_update_logs","text":"<pre><code>consume_sw_update_logs(start_time: float, end_time: float) -&gt; list[Any]\n</code></pre> <p>Consume logs from the kafka queue for given time using offsets.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>start time to fetch logs</p> required <code>float</code> <p>end time to fetch logs</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>kafka logs</p> <p>Raises:</p> Type Description <code>OffsetOutOfRangeError</code> <p>if offset does not exist</p> Source code in <code>boardfarm3/lib/odh/kafka_client.py</code> <pre><code>def consume_sw_update_logs(self, start_time: float, end_time: float) -&gt; list[Any]:\n    \"\"\"Consume logs from the kafka queue for given time using offsets.\n\n    :param start_time: start time to fetch logs\n    :type start_time: float\n    :param end_time: end time to fetch logs\n    :type end_time: float\n    :return: kafka logs\n    :rtype: list[Any]\n    :raises OffsetOutOfRangeError: if offset does not exist\n    \"\"\"\n    logs = []\n    time_duration = (end_time - start_time) + (\n        60 * 1000  # a minute of extra buffer time\n    )\n    partitions = self._consumer.partitions_for_topic(topic=self.topic)\n    for partition in partitions:\n        topic_partition = TopicPartition(topic=self.topic, partition=partition)\n        start_offset = self._consumer.offsets_for_times(\n            {topic_partition: start_time}\n        )\n        self._consumer.seek(topic_partition, start_offset[topic_partition].offset)\n        for _ in range(5):\n            log_data = self._consumer.poll(timeout_ms=time_duration)\n            if start_offset[topic_partition].offset in [\n                record.offset for _, val in log_data.items() for record in val\n            ]:\n                break\n        else:\n            msg = \"Given offset does not exist in records\"\n            raise OffsetOutOfRangeError(msg)\n        for log in log_data.values():\n            logs.extend(log)\n    return logs\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.consume_sw_update_logs(start_time)","title":"<code>start_time</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.consume_sw_update_logs(end_time)","title":"<code>end_time</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.read_kafka_messages","title":"read_kafka_messages","text":"<pre><code>read_kafka_messages(num_messages: int) -&gt; list[Any]\n</code></pre> <p>Read a given number of messages from the kafka queue.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The number of messages to be read from the kafka queue</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>list of telemetry logs</p> Source code in <code>boardfarm3/lib/odh/kafka_client.py</code> <pre><code>def read_kafka_messages(self, num_messages: int) -&gt; list[Any]:\n    \"\"\"Read a given number of messages from the kafka queue.\n\n    :param num_messages: The number of messages to be read from the kafka queue\n    :type num_messages: int\n    :return: list of telemetry logs\n    :rtype: list[Any]\n    \"\"\"\n    messages = []\n    for _ in range(num_messages):\n        message = next(self._consumer)\n        if message.value is not None:\n            messages.append(message.value)\n    return messages\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.read_kafka_messages(num_messages)","title":"<code>num_messages</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.subscribe_to_topic","title":"subscribe_to_topic","text":"<pre><code>subscribe_to_topic(topics: list[str]) -&gt; None\n</code></pre> <p>Subscribe to a list topics.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>the list of topics to subscribe to</p> required <p>Raises:</p> Type Description <code>UnknownTopicOrPartitionError</code> <p>if a topic does not exist</p> Source code in <code>boardfarm3/lib/odh/kafka_client.py</code> <pre><code>def subscribe_to_topic(self, topics: list[str]) -&gt; None:\n    \"\"\"Subscribe to a list topics.\n\n    :param topics: the list of topics to subscribe to\n    :type topics: list[str]\n    :raises UnknownTopicOrPartitionError: if a topic does not exist\n    \"\"\"\n    for topic in topics:\n        if topic not in self._consumer.topics():\n            msg = f\"The topic {topic} does not exist\"\n            raise UnknownTopicOrPartitionError(msg)\n        self._consumer.subscribe([topic])\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.odh.kafka_client.KafkaClient.subscribe_to_topic(topics)","title":"<code>topics</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.parsers","title":"parsers","text":"<p>Linux command output parsers.</p> <p>Modules:</p> Name Description <code>iptables_parser</code> <p>Parser module for iptables command output.</p> <code>netstat_parser</code> <p>Parse netstat command lines output into dataframes.</p> <code>nslookup_parser</code> <p>nslookup command line utility output parser module.</p>"},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser","title":"iptables_parser","text":"<p>Parser module for iptables command output.</p> <p>Classes:</p> Name Description <code>IptablesParser</code> <p>Parse the iptables from table format to dict.</p>"},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser.IptablesParser","title":"IptablesParser","text":"<p>Parse the iptables from table format to dict.</p> <p>Methods:</p> Name Description <code>ip6tables</code> <p>Return parsed given ip6tables output.</p> <code>iptables</code> <p>Return parsed given iptables output.</p> <code>iptables_policy</code> <p>Return the iptables policy.</p>"},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser.IptablesParser.ip6tables","title":"ip6tables","text":"<pre><code>ip6tables(ip6_tables: str) -&gt; dict[str, list[dict]]\n</code></pre> <p>Return parsed given ip6tables output.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip6tables command output</p> required <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>parsed ip6tables output in dictionary</p> Source code in <code>boardfarm3/lib/parsers/iptables_parser.py</code> <pre><code>def ip6tables(self, ip6_tables: str) -&gt; dict[str, list[dict]]:\n    \"\"\"Return parsed given ip6tables output.\n\n    :param ip6_tables: ip6tables command output\n    :type ip6_tables: str\n    :return: parsed ip6tables output in dictionary\n    :rtype: Dict[str, List[Dict]]\n    \"\"\"\n    header = self._get_headers(ip6_tables)\n    header.remove(\"opt\")\n    split_chain = re.split(\"Chain\", ip6_tables)\n    key = None\n    table_rule: dict[str, list[dict]] = {}\n    # pylint: disable=too-many-nested-blocks, consider-using-enumerate\n    for i in range(len(split_chain)):\n        rule_data: list[dict[str, str]] = []\n        for rule in split_chain[i].splitlines():\n            rule_details: dict[str, str] = {}\n            if re.match(r\"\\s[A-Za-z]\", rule) is not None:\n                key = rule.split(\" \")[1]\n            elif rule[:1].isdigit():\n                values = list(rule.split())\n                for cnt, val in enumerate(header[1:], 1):\n                    rule_details[val] = values[cnt]\n                if len(values) &gt; 9:\n                    dest = \" \".join(map(str, values[9:]))\n                    rule_details[\"to-target\"] = dest\n                rule_data.append(rule_details)\n        if key:\n            table_rule[key] = rule_data\n    assert table_rule, \"Invalid table name or Table doesn't exist\"\n    return table_rule\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser.IptablesParser.ip6tables(ip6_tables)","title":"<code>ip6_tables</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser.IptablesParser.iptables","title":"iptables","text":"<pre><code>iptables(ip_tables: str) -&gt; dict[str, list[dict]]\n</code></pre> <p>Return parsed given iptables output.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>iptables command output</p> required <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>parsed iptables output in dictionary</p> Source code in <code>boardfarm3/lib/parsers/iptables_parser.py</code> <pre><code>def iptables(self, ip_tables: str) -&gt; dict[str, list[dict]]:\n    \"\"\"Return parsed given iptables output.\n\n    :param ip_tables: iptables command output\n    :type ip_tables: str\n    :return: parsed iptables output in dictionary\n    :rtype: Dict[str, List[Dict]]\n    \"\"\"\n    headers = self._get_headers(ip_tables)\n    split_chain = re.split(\"Chain\", ip_tables)\n    key = None\n    table_rule: dict[str, list[dict]] = {}\n    # pylint: disable=too-many-nested-blocks, consider-using-enumerate\n    for i in range(len(split_chain)):\n        rule_data: list[dict] = []\n        for rule in split_chain[i].splitlines():\n            rule_details: dict[str, str] = {}\n            if re.match(r\"\\s[A-Za-z]\", rule):\n                key = rule.split(\" \")[1]\n            if rule[:1].isdigit():\n                values = list(rule.split())\n                for cnt, val in enumerate(headers[1:], 1):\n                    if val not in \"opt\":\n                        rule_details[val] = values[cnt]\n                if len(values) &gt; 10:\n                    dest = \" \".join(map(str, values[10:]))\n                    rule_details[\"to-target\"] = dest\n                rule_data.append(rule_details)\n        if key:\n            table_rule[key] = rule_data\n    assert table_rule, \"Invalid table name or Table doesn't exist\"\n    return table_rule\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser.IptablesParser.iptables(ip_tables)","title":"<code>ip_tables</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser.IptablesParser.iptables_policy","title":"iptables_policy","text":"<pre><code>iptables_policy(ip_tables: str) -&gt; dict[str, str]\n</code></pre> <p>Return the iptables policy.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>output of iptables command</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict of iptable policy</p> Source code in <code>boardfarm3/lib/parsers/iptables_parser.py</code> <pre><code>def iptables_policy(self, ip_tables: str) -&gt; dict[str, str]:\n    \"\"\"Return the iptables policy.\n\n    :param ip_tables: output of iptables command\n    :type ip_tables: str\n    :return: dict of iptable policy\n    :rtype: dict[str, str]\n    \"\"\"\n    policy_dict = {}\n    for policies in re.split(r\"Chain\", ip_tables):\n        if len(lines := policies.strip().split(\"\\n\")) &gt; 1:\n            policy_key = lines[0].split()[0]\n            policy_value = re.search(r\"\\((.*?)\\)\", lines[0])[1]\n            policy_dict[policy_key] = policy_value\n    return policy_dict\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.parsers.iptables_parser.IptablesParser.iptables_policy(ip_tables)","title":"<code>ip_tables</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.parsers.netstat_parser","title":"netstat_parser","text":"<p>Parse netstat command lines output into dataframes.</p> <p>Classes:</p> Name Description <code>NetstatParser</code> <p>Parse netstat command lines output into dataframes.</p>"},{"location":"reference/libs/#boardfarm3.lib.parsers.netstat_parser.NetstatParser","title":"NetstatParser","text":"<pre><code>NetstatParser()\n</code></pre> <p>Parse netstat command lines output into dataframes.</p> <p>Initialize the NetstatParser.</p> <p>Methods:</p> Name Description <code>parse_netstat_output</code> <p>Parse given netstat output.</p> Source code in <code>boardfarm3/lib/parsers/netstat_parser.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the NetstatParser.\"\"\"\n    self._inet_connections: list[str] = []\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.parsers.netstat_parser.NetstatParser.parse_netstat_output","title":"parse_netstat_output","text":"<pre><code>parse_netstat_output(output: str) -&gt; DataFrame\n</code></pre> <p>Parse given netstat output.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>netstat output</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>parsed netstat output in pandas.DataFrame</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on invalid netstat output</p> Source code in <code>boardfarm3/lib/parsers/netstat_parser.py</code> <pre><code>def parse_netstat_output(self, output: str) -&gt; DataFrame:\n    \"\"\"Parse given netstat output.\n\n    :param output: netstat output\n    :type output: str\n    :raises ValueError: on invalid netstat output\n    :return: parsed netstat output in pandas.DataFrame\n    :rtype: DataFrame\n    \"\"\"\n    sample_bytes = bytes(output, \"utf-8\")\n    file_out = BytesIO(sample_bytes)\n    value = file_out.readline()[:5].decode(\"utf-8\")\n    counter = 0\n    while \"Proto\" not in value:\n        header = file_out.readline()\n        value = header[:5].decode(\"utf-8\")\n        counter += 1\n        if counter == 20:\n            msg = \"Invalid netstat output\"\n            raise ValueError(msg)\n    val = file_out.readlines()\n    for line in val:\n        if \"Active UNIX domain sockets\" in str(line):\n            break\n        inet_header, result = self._parse_inet_connection(line, header)\n        if result:\n            self._inet_connections.append(result)\n    return DataFrame(self._inet_connections, columns=inet_header)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.parsers.netstat_parser.NetstatParser.parse_netstat_output(output)","title":"<code>output</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.parsers.nslookup_parser","title":"nslookup_parser","text":"<p>nslookup command line utility output parser module.</p> <p>Classes:</p> Name Description <code>NslookupParser</code> <p>nslookup command line utility output parser module.</p>"},{"location":"reference/libs/#boardfarm3.lib.parsers.nslookup_parser.NslookupParser","title":"NslookupParser","text":"<p>nslookup command line utility output parser module.</p> <p>Methods:</p> Name Description <code>parse_nslookup_output</code> <p>Parse the DNS query response into dict obj.</p>"},{"location":"reference/libs/#boardfarm3.lib.parsers.nslookup_parser.NslookupParser.parse_nslookup_output","title":"parse_nslookup_output","text":"<pre><code>parse_nslookup_output(response: str) -&gt; dict[str, Any]\n</code></pre> <p>Parse the DNS query response into dict obj.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>nslookup CLI output</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>parsed nslookup output</p> Source code in <code>boardfarm3/lib/parsers/nslookup_parser.py</code> <pre><code>def parse_nslookup_output(self, response: str) -&gt; dict[str, Any]:\n    \"\"\"Parse the DNS query response into dict obj.\n\n    :param response: nslookup CLI output\n    :type response: str\n    :return: parsed nslookup output\n    :rtype: Dict[str, str]\n    \"\"\"\n    dns_dict_obj: dict[str, Any] = {}\n    val = response.replace(\"\\t\\t\", \" \").replace(\"\\t\", \" \")\n    # pylint: disable-next=too-many-nested-blocks\n    for i in val.split(\"\\r\\n\\r\\n\"):\n        if \"Server\" in i:\n            for expr in [ValidIpv4AddressRegex, AllValidIpv6AddressesRegex]:\n                if re.search(expr, i):\n                    matches = re.search(expr, i)[0]\n                    break\n            dns_dict_obj[\"dns_server\"] = matches\n        elif \"Name\" in i:\n            dns_dict_obj[\"domain_name\"] = re.search(r\"(?:[\\da-z\\._]+)\\.(\\w+)\", i)[0]\n            ips: list[str] = []\n            for value in [\n                ValidIpv4AddressRegex,\n                AllValidIpv6AddressesRegex,\n            ]:\n                ips.extend(matches[0] for matches in re.finditer(value, i))\n            dns_dict_obj[\"domain_ip_addr\"] = ips\n        elif \"AAAA\" in i:\n            dns_dict_obj[\"domain_name\"] = re.search(r\"(?:[\\da-z\\.-]+)\\.(\\w+)\", i)[0]\n            dns_dict_obj[\"domain_ipv6_addr\"] = re.findall(\n                AllValidIpv6AddressesRegex,\n                i,\n            )\n    assert dns_dict_obj, f\"Error response: {response}\"\n    return dns_dict_obj\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.parsers.nslookup_parser.NslookupParser.parse_nslookup_output(response)","title":"<code>response</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.power","title":"power","text":"<p>Power module.</p> <p>Functions:</p> Name Description <code>get_pdu</code> <p>Get a PDU object to drive the power of an outlet.</p>"},{"location":"reference/libs/#boardfarm3.lib.power.get_pdu","title":"get_pdu","text":"<pre><code>get_pdu(uri: str) -&gt; PDU\n</code></pre> <p>Get a PDU object to drive the power of an outlet.</p> <p>Examples of pdu uris:     \"type://ip[:port]; outlet\"</p> <pre><code>\"netio://10.64.40.34; 2\"\n\"px2://10.71.10.53:23; 2\",\n\"px3://10.71.10.53:23; 2\",\n\"eaton://10.71.10.53:23; 2\"\nmore to come....\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>a uri with the PDU details</p> required <p>Returns:</p> Type Description <code>PDU</code> <p>a PDU templated object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the PDU URI is not recognised</p> Source code in <code>boardfarm3/lib/power.py</code> <pre><code>def get_pdu(uri: str) -&gt; PDU:\n    \"\"\"Get a PDU object to drive the power of an outlet.\n\n    Examples of pdu uris:\n        \"type://ip[:port]; outlet\"\n\n        \"netio://10.64.40.34; 2\"\n        \"px2://10.71.10.53:23; 2\",\n        \"px3://10.71.10.53:23; 2\",\n        \"eaton://10.71.10.53:23; 2\"\n        more to come....\n\n    :param uri: a uri with the PDU details\n    :type uri: str\n    :raises ValueError: if the PDU URI is not recognised\n    :return: a PDU templated object\n    :rtype: PDU\n    \"\"\"\n    for pdu_name, pdu_type in pdu_dict.items():\n        if uri.startswith(pdu_name):\n            return pdu_type(uri.replace(pdu_name, \"\"))\n    msg = f\"PDU uri: '{uri}' not recognised\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.power.get_pdu(uri)","title":"<code>uri</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.python_executor","title":"python_executor","text":"<p>Python executor module.</p> <p>Classes:</p> Name Description <code>PythonExecutor</code> <p>Helper to execute python commands over a given Linux console.</p>"},{"location":"reference/libs/#boardfarm3.lib.python_executor.PythonExecutor","title":"PythonExecutor","text":"<pre><code>PythonExecutor(console: BoardfarmPexpect, shell_prompt: list[str])\n</code></pre> <p>Helper to execute python commands over a given Linux console.</p> <p>Initialise PythonExecutor.</p> <p>Parameters:</p> Name Type Description Default <code>BoardfarmPexpect</code> <p>the console to execute the Python commands on</p> required <code>list[str]</code> <p>the console shell prompt (usually a list of regexs)</p> required <p>Methods:</p> Name Description <code>exit_python</code> <p>Exit the Python prompt.</p> <code>run</code> <p>Run the given Python command.</p> Source code in <code>boardfarm3/lib/python_executor.py</code> <pre><code>def __init__(self, console: BoardfarmPexpect, shell_prompt: list[str]) -&gt; None:\n    \"\"\"Initialise PythonExecutor.\n\n    :param console: the console to execute the Python commands on\n    :type console: BoardfarmPexpect\n    :param shell_prompt: the console shell prompt (usually a list of regexs)\n    :type shell_prompt: list[str]\n    \"\"\"\n    self._console: BoardfarmPexpect = console\n    self._shell_prompt: list[str] = shell_prompt\n    self._py_prompt = \"&gt;&gt;&gt;\"\n    self._console.execute_command(\"kill -9 $(pgrep python3)\")\n    self.run(\"python3\")\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.python_executor.PythonExecutor(console)","title":"<code>console</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.python_executor.PythonExecutor(shell_prompt)","title":"<code>shell_prompt</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.python_executor.PythonExecutor.exit_python","title":"exit_python","text":"<pre><code>exit_python() -&gt; None\n</code></pre> <p>Exit the Python prompt.</p> Source code in <code>boardfarm3/lib/python_executor.py</code> <pre><code>def exit_python(self) -&gt; None:\n    \"\"\"Exit the Python prompt.\"\"\"\n    with suppress(TIMEOUT):\n        self._console.sendcontrol(\"c\")\n        self._console.expect(self._py_prompt)\n        self._console.sendcontrol(\"d\")\n        self._console.expect(self._shell_prompt)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.python_executor.PythonExecutor.run","title":"run","text":"<pre><code>run(cmd: str, expect: str = '') -&gt; str\n</code></pre> <p>Run the given Python command.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the Python command</p> required <code>str</code> <p>what to expect as output from the command, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the output of the Python command</p> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>on execution/connectivity issues</p> Source code in <code>boardfarm3/lib/python_executor.py</code> <pre><code>def run(self, cmd: str, expect: str = \"\") -&gt; str:\n    \"\"\"Run the given Python command.\n\n    :param cmd: the Python command\n    :type cmd: str\n    :param expect: what to expect as output from the command, defaults to \"\"\n    :type expect: str\n    :raises DeviceConnectionError: on execution/connectivity issues\n    :return: the output of the Python command\n    :rtype: str\n    \"\"\"\n    out: str = \"\"\n    self._console.sendline(cmd)\n    if not expect:\n        self._console.expect(self._py_prompt)\n        out = self._console.before\n    else:\n        self._console.expect(expect)\n        out = self._console.before\n        self._console.expect(self._py_prompt)\n\n    if \"Traceback\" in out:\n        msg = f\"Failed to execute on python console command:\\n{cmd}\\nOutput:{out}\"\n        raise DeviceConnectionError(\n            msg,\n        )\n\n    return out\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.python_executor.PythonExecutor.run(cmd)","title":"<code>cmd</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.python_executor.PythonExecutor.run(expect)","title":"<code>expect</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.regexlib","title":"regexlib","text":"<p>Useful regexes library.</p>"},{"location":"reference/libs/#boardfarm3.lib.shell_prompt","title":"shell_prompt","text":"<p>Boardfarm v3 base device shell prompts.</p>"},{"location":"reference/libs/#boardfarm3.lib.utils","title":"utils","text":"<p>Boardfarm common utilities module.</p> <p>Functions:</p> Name Description <code>disable_logs</code> <p>Disable logs for the logger with given name.</p> <code>get_nth_mac_address</code> <p>Get nth mac address from base mac address.</p> <code>get_pytest_name</code> <p>Get the test name from the test filename during runtime.</p> <code>get_static_ipaddress</code> <p>Return the static ip address of the device based on given ip version.</p> <code>get_value_from_dict</code> <p>Get value of given key from the dictionary recursively.</p> <code>ip_pool_to_list</code> <p>Generate ip address list based on ip pool boundaries.</p> <code>retry</code> <p>Retry a function if the output of the function is false.</p> <code>retry_on_exception</code> <p>Retry a method if any exception occurs.</p>"},{"location":"reference/libs/#boardfarm3.lib.utils.disable_logs","title":"disable_logs","text":"<pre><code>disable_logs(logger_name: str | None = None) -&gt; Generator\n</code></pre> <p>Disable logs for the logger with given name.</p> <p>:yield: log with the given name</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>logger name, defaults to None</p> <code>None</code> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>@contextmanager\ndef disable_logs(logger_name: str | None = None) -&gt; Generator:\n    \"\"\"Disable logs for the logger with given name.\n\n    :param logger_name: logger name, defaults to None\n    :type logger_name: Optional[str], optional\n    :yield: log with the given name\n    \"\"\"\n    logger = logging.getLogger(logger_name)\n    handlers = list(logger.handlers)\n    list(map(logger.removeHandler, handlers))\n    null_handler = logging.NullHandler()\n    logger.addHandler(null_handler)\n    try:\n        yield\n    finally:\n        logger.removeHandler(null_handler)\n        list(map(logger.addHandler, handlers))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.disable_logs(logger_name)","title":"<code>logger_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.get_nth_mac_address","title":"get_nth_mac_address","text":"<pre><code>get_nth_mac_address(mac_address: str, nth_number: int) -&gt; str\n</code></pre> <p>Get nth mac address from base mac address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>base mac address</p> required <code>int</code> <p>n'th number from base mac address</p> required <p>Returns:</p> Type Description <code>str</code> <p>n'th mac address</p> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>def get_nth_mac_address(mac_address: str, nth_number: int) -&gt; str:\n    \"\"\"Get nth mac address from base mac address.\n\n    :param mac_address: base mac address\n    :param nth_number: n'th number from base mac address\n    :return: n'th mac address\n    \"\"\"\n    return str(EUI(int(EUI(mac_address)) + nth_number, dialect=mac_unix_expanded))\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.get_nth_mac_address(mac_address)","title":"<code>mac_address</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.get_nth_mac_address(nth_number)","title":"<code>nth_number</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.get_pytest_name","title":"get_pytest_name","text":"<pre><code>get_pytest_name() -&gt; str\n</code></pre> <p>Get the test name from the test filename during runtime.</p> <p>Returns:</p> Type Description <code>str</code> <p>current test name</p> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>def get_pytest_name() -&gt; str:\n    \"\"\"Get the test name from the test filename during runtime.\n\n    :return: current test name\n    \"\"\"\n    return (\n        (os.environ.get(\"PYTEST_CURRENT_TEST\", \"::interact\").split(\" (setup)\")[0])\n        .split(\"::\")[1]\n        .replace(\" \", \"_\")\n    )\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.get_static_ipaddress","title":"get_static_ipaddress","text":"<pre><code>get_static_ipaddress(config: dict[str, Any], ip_version: str = 'ipv4') -&gt; str | None\n</code></pre> <p>Return the static ip address of the device based on given ip version.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, Any]</code> <p>device config</p> required <code>str</code> <p>ip version, defaults to \"ipv4\"</p> <code>'ipv4'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>the static ip address of the device</p> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>def get_static_ipaddress(\n    config: dict[str, Any],\n    ip_version: str = \"ipv4\",\n) -&gt; str | None:\n    \"\"\"Return the static ip address of the device based on given ip version.\n\n    :param config: device config\n    :type config: dict[str, Any]\n    :param ip_version: ip version, defaults to \"ipv4\"\n    :type ip_version: str\n    :return: the static ip address of the device\n    :rtype: Optional[str]\n    \"\"\"\n    option_prefix: str = (\n        \"wan-static-ip:\" if ip_version == \"ipv4\" else \"wan-static-ipv6:\"\n    )\n    if (options := config[\"options\"].split(\",\")) and (\n        match := next(\n            (\n                option.strip().split(option_prefix)[1]\n                for option in options\n                if option_prefix in option\n            ),\n            None,\n        )\n    ):\n        return str(\n            (\n                IPv4Interface(match).ip\n                if ip_version == \"ipv4\"\n                else IPv6Interface(match).ip\n            ),\n        )\n    return None\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.get_static_ipaddress(config)","title":"<code>config</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.get_static_ipaddress(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.get_value_from_dict","title":"get_value_from_dict","text":"<pre><code>get_value_from_dict(key: str, dictionary: dict) -&gt; Any\n</code></pre> <p>Get value of given key from the dictionary recursively.</p> <p>This method is used to avoid nested checks for None to get a value from dictionary without raising KeyError.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the key</p> required <code>dict</code> <p>dictionary instance</p> required <p>Returns:</p> Type Description <code>Any</code> <p>value of given key if exists, otherwise None</p> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>def get_value_from_dict(key: str, dictionary: dict) -&gt; Any:  # noqa: ANN401\n    \"\"\"Get value of given key from the dictionary recursively.\n\n    This method is used to avoid nested checks for None to get\n    a value from dictionary without raising KeyError.\n\n    :param key: name of the key\n    :type key: str\n    :param dictionary: dictionary instance\n    :type dictionary: dict\n    :return: value of given key if exists, otherwise None\n    :rtype: Any\n    \"\"\"\n    for name, value in dictionary.items():\n        if name == key:\n            return value\n        if isinstance(value, dict):\n            return_value = get_value_from_dict(key, value)\n            if return_value is not None:\n                return return_value\n    return None\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.get_value_from_dict(key)","title":"<code>key</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.get_value_from_dict(dictionary)","title":"<code>dictionary</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.ip_pool_to_list","title":"ip_pool_to_list","text":"<pre><code>ip_pool_to_list(start_ip: IPv4Address, end_ip: IPv4Address) -&gt; list[IPv4Address]\n</code></pre> <p>Generate ip address list based on ip pool boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>IPv4Address</code> <p>first ip of the pool</p> required <code>IPv4Address</code> <p>last ip of the pool</p> required <p>Returns:</p> Type Description <code>list[IPv4Address]</code> <p>list of ip addresses based on min ip address and maximum ip address of the pool</p> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>def ip_pool_to_list(start_ip: IPv4Address, end_ip: IPv4Address) -&gt; list[IPv4Address]:\n    \"\"\"Generate ip address list based on ip pool boundaries.\n\n    :param start_ip: first ip of the pool\n    :type start_ip: IPv4Address\n    :param end_ip: last ip of the pool\n    :type end_ip: IPv4Address\n    :return: list of ip addresses based on min ip address and maximum\n             ip address of the pool\n    :rtype: list[IPv4Address]\n    \"\"\"\n    ip_list = []\n    while end_ip &gt;= start_ip and start_ip != end_ip + 1:\n        ip_list.append(start_ip)\n        start_ip += 1\n    return ip_list\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.ip_pool_to_list(start_ip)","title":"<code>start_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.ip_pool_to_list(end_ip)","title":"<code>end_ip</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.retry","title":"retry","text":"<pre><code>retry(func_name: Callable, max_retry: int, *args: Any) -&gt; Any\n</code></pre> <p>Retry a function if the output of the function is false.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>name of the function to retry</p> required <code>int</code> <p>maximum number of times to be retried</p> required <code>Any</code> <p>arguments to the function</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p>output of the function</p> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>def retry(func_name: Callable, max_retry: int, *args: Any) -&gt; Any:  # noqa: ANN401\n    \"\"\"Retry a function if the output of the function is false.\n\n    :param func_name: name of the function to retry\n    :type func_name: Callable\n    :param max_retry: maximum number of times to be retried\n    :type max_retry: int\n    :param args: arguments to the function\n    :type args: Tuple[Any, ...]\n    :return: output of the function\n    :rtype: Any\n    \"\"\"\n    for _ in range(max_retry - 1):\n        output = func_name(*args)\n        if output and output != \"False\":\n            return output\n        time.sleep(5)\n    return func_name(*args)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.retry(func_name)","title":"<code>func_name</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.retry(max_retry)","title":"<code>max_retry</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.retry(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.retry_on_exception","title":"retry_on_exception","text":"<pre><code>retry_on_exception(\n    method: Callable, args: list | tuple, retries: int = 10, tout: int = 5\n) -&gt; Any\n</code></pre> <p>Retry a method if any exception occurs.</p> <p>Eventually, at last, throw the exception. NOTE: args must be a tuple, hence a 1 arg tuple is (,) <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>name of the function to retry</p> required <code>list | tuple</code> <p>arguments to the function</p> required <code>int</code> <p>maximum number of retries when a exception occur,defaults to 10. When negative, no retries are made.</p> <code>10</code> <code>int</code> <p>sleep time after every exception occur, defaults to 5</p> <code>5</code> <p>Returns:</p> Type Description <code>Any</code> <p>output of the function</p> Source code in <code>boardfarm3/lib/utils.py</code> <pre><code>def retry_on_exception(\n    method: Callable,\n    args: list | tuple,\n    retries: int = 10,\n    tout: int = 5,\n) -&gt; Any:  # noqa: ANN401\n    \"\"\"Retry a method if any exception occurs.\n\n    Eventually, at last, throw the exception.\n    NOTE: args must be a tuple, hence a 1 arg tuple is (&lt;arg&gt;,)\n\n    :param method: name of the function to retry\n    :type method: Callable\n    :param args: arguments to the function\n    :type args: Union[List, Tuple]\n    :param retries: maximum number of retries when a exception occur,defaults\n                    to 10. When negative, no retries are made.\n    :type retries: int\n    :param tout: sleep time after every exception occur, defaults to 5\n    :type tout: int\n    :return: output of the function\n    :rtype: Any\n    \"\"\"\n    for re_try in range(1, retries):\n        try:\n            return method(*args)\n        except (  # noqa: PERF203\n            Exception  # noqa: BLE001  # pylint: disable=broad-except\n        ) as exc:\n            _LOGGER.debug(\"method failed %d time (%s)\", re_try, exc)\n            time.sleep(tout)\n    return method(*args)\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.utils.retry_on_exception(method)","title":"<code>method</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.retry_on_exception(args)","title":"<code>args</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.retry_on_exception(retries)","title":"<code>retries</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.utils.retry_on_exception(tout)","title":"<code>tout</code>","text":""},{"location":"reference/libs/#boardfarm3.lib.wrappers","title":"wrappers","text":"<p>Boardfarm decorators module.</p> <p>Functions:</p> Name Description <code>singleton</code> <p>Allow a class to become a decorator.</p>"},{"location":"reference/libs/#boardfarm3.lib.wrappers.singleton","title":"singleton","text":"<pre><code>singleton(cls: type[AnyClass]) -&gt; Callable[..., AnyClass]\n</code></pre> <p>Allow a class to become a decorator.</p> <p>Parameters:</p> Name Type Description Default <code>type[AnyClass]</code> <p>class to become a decorator</p> required <p>Returns:</p> Type Description <code>Callable[..., AnyClass]</code> <p>callable[...,AnyClass]</p> Source code in <code>boardfarm3/lib/wrappers.py</code> <pre><code>def singleton(cls: type[AnyClass]) -&gt; Callable[..., AnyClass]:\n    \"\"\"Allow a class to become a decorator.\n\n    :param cls: class to become a decorator\n    :return: callable[...,AnyClass]\n    \"\"\"\n    instances: dict[type[AnyClass], AnyClass] = {}\n\n    def getinstance(*args: tuple, **kwargs: Any) -&gt; AnyClass:  # noqa: ANN401\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n\n        return instances[cls]\n\n    return getinstance  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/libs/#boardfarm3.lib.wrappers.singleton(cls)","title":"<code>cls</code>","text":""},{"location":"reference/templates/","title":"Templates","text":""},{"location":"reference/templates/#boardfarm3.templates","title":"templates","text":"<p>Boardfarm templates package.</p> <p>Modules:</p> Name Description <code>acs</code> <p>Boardfarm ACS device template.</p> <code>aftr</code> <p>Boardfarm AFTR template.</p> <code>core_router</code> <p>Core Router Template.</p> <code>cpe</code> <p>Boardfarm LGI shared CPE templates.</p> <code>lan</code> <p>Boardfarm LAN device template.</p> <code>line_termination</code> <p>Generic Template for Line Termination Systems.</p> <code>pdu</code> <p>Define the PDU template.</p> <code>provisioner</code> <p>Provisioner device template.</p> <code>sip_phone</code> <p>SIPPhone Template module.</p> <code>sip_server</code> <p>SIPServer Template module.</p> <code>tftp</code> <p>Boardfarm TFTP device template.</p> <code>wan</code> <p>Boardfarm WAN device template.</p> <code>wlan</code> <p>Boardfarm WLAN device template.</p>"},{"location":"reference/templates/#boardfarm3.templates.acs","title":"acs","text":"<p>Boardfarm ACS device template.</p> <p>Classes:</p> Name Description <code>ACS</code> <p>Boardfarm ACS device template.</p>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS","title":"ACS","text":"<p>Boardfarm ACS device template.</p> <p>Methods:</p> Name Description <code>AddObject</code> <p>Execute AddOjbect RPC call for the specified parameter.</p> <code>DelObject</code> <p>Execute DeleteObject RPC call for the specified parameter.</p> <code>Download</code> <p>Execute Download RPC.</p> <code>FactoryReset</code> <p>Execute FactoryReset RPC.</p> <code>GPA</code> <p>Execute GetParameterAttributes RPC call for the specified parameter.</p> <code>GPN</code> <p>Execute GetParameterNames RPC call for the specified parameter.</p> <code>GPV</code> <p>Execute GetParameterValues RPC call for the specified parameter(s).</p> <code>GetRPCMethods</code> <p>Execute GetRPCMethods RPC.</p> <code>Reboot</code> <p>Execute Reboot RPC.</p> <code>SPA</code> <p>Execute SetParameterAttributes RPC call for the specified parameter.</p> <code>SPV</code> <p>Execute SetParameterValues RPC call for the specified parameter.</p> <code>ScheduleInform</code> <p>Execute ScheduleInform RPC.</p> <code>delete_file</code> <p>Delete the file from the device.</p> <code>provision_cpe_via_tr069</code> <p>Provision the cpe with tr069 parameters defined in env json.</p> <code>scp_device_file_to_local</code> <p>Copy a local file from a server using SCP.</p> <code>start_tcpdump</code> <p>Start tcpdump capture on given interface.</p> <code>stop_tcpdump</code> <p>Stop tcpdump capture.</p> <p>Attributes:</p> Name Type Description <code>console</code> <code>BoardfarmPexpect</code> <p>Returns ACS console.</p> <code>firewall</code> <code>IptablesFirewall</code> <p>Returns Firewall iptables instance.</p> <code>ipv4_addr</code> <code>str</code> <p>Return the IPv4 address on IFACE facing DUT.</p> <code>ipv6_addr</code> <code>str</code> <p>Return the IPv6 address on IFACE facing DUT.</p> <code>url</code> <code>str</code> <p>Returns the acs url used.</p>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.console","title":"console  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>console: BoardfarmPexpect\n</code></pre> <p>Returns ACS console.</p> <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console</p>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.firewall","title":"firewall  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>firewall: IptablesFirewall\n</code></pre> <p>Returns Firewall iptables instance.</p> <p>Returns:</p> Type Description <code>IptablesFirewall</code> <p>firewall iptables instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.ipv4_addr","title":"ipv4_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv4_addr: str\n</code></pre> <p>Return the IPv4 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.ipv6_addr","title":"ipv6_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv6_addr: str\n</code></pre> <p>Return the IPv6 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.url","title":"url  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>Returns the acs url used.</p> <p>Returns:</p> Type Description <code>str</code> <p>acs url component instance</p>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.AddObject","title":"AddObject  <code>abstractmethod</code>","text":"<pre><code>AddObject(param: str, param_key: str = '', cpe_id: str | None = None) -&gt; list[dict]\n</code></pre> <p>Execute AddOjbect RPC call for the specified parameter.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>parameter to be used to add</p> required <code>str</code> <p>the value to set the ParameterKey parameter, defaults to \"\"</p> <code>''</code> <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list of dictionary with key, value, type indicating the AddObject</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef AddObject(\n    self,\n    param: str,\n    param_key: str = \"\",\n    cpe_id: str | None = None,\n) -&gt; list[dict]:\n    \"\"\"Execute AddOjbect RPC call for the specified parameter.\n\n    :param param: parameter to be used to add\n    :type param: str\n    :param param_key: the value to set the ParameterKey parameter, defaults to \"\"\n    :type param_key: str\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: list of dictionary with key, value, type indicating the AddObject\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.AddObject(param)","title":"<code>param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.AddObject(param_key)","title":"<code>param_key</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.AddObject(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.DelObject","title":"DelObject  <code>abstractmethod</code>","text":"<pre><code>DelObject(param: str, param_key: str = '', cpe_id: str | None = None) -&gt; list[dict]\n</code></pre> <p>Execute DeleteObject RPC call for the specified parameter.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>parameter to be used to delete</p> required <code>str</code> <p>the value to set the ParameterKey parameter, defaults to \"\"</p> <code>''</code> <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list of dictionary with key, value, type indicating the DelObject</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef DelObject(\n    self,\n    param: str,\n    param_key: str = \"\",\n    cpe_id: str | None = None,\n) -&gt; list[dict]:\n    \"\"\"Execute DeleteObject RPC call for the specified parameter.\n\n    :param param: parameter to be used to delete\n    :type param: str\n    :param param_key: the value to set the ParameterKey parameter, defaults to \"\"\n    :type param_key: str\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: list of dictionary with key, value, type indicating the DelObject\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.DelObject(param)","title":"<code>param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.DelObject(param_key)","title":"<code>param_key</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.DelObject(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download","title":"Download  <code>abstractmethod</code>","text":"<pre><code>Download(\n    url: str,\n    filetype: str = \"1 Firmware Upgrade Image\",\n    targetfilename: str = \"\",\n    filesize: int = 200,\n    username: str = \"\",\n    password: str = \"\",\n    commandkey: str = \"\",\n    delayseconds: int = 10,\n    successurl: str = \"\",\n    failureurl: str = \"\",\n    cpe_id: str | None = None,\n) -&gt; list[dict]\n</code></pre> <p>Execute Download RPC.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>URL to download file</p> required <code>str</code> <p>the string paramenter from following 6 values only  .. code-block:: python  [ \"1 Firmware Upgrade Image\", \"2 Web Content\", \"3 Vendor Configuration File\", \"4 Tone File\", \"5 Ringer File\", \"6 Stored Firmware Image\", ]</p> <code>'1 Firmware Upgrade Image'</code> <code>str</code> <p>TargetFileName to download through RPC</p> <code>''</code> <code>int</code> <p>the size of file to download in bytes</p> <code>200</code> <code>str</code> <p>User to authenticate with file Server.  Default=\"\"</p> <code>''</code> <code>str</code> <p>Password to authenticate with file Server. Default=\"\"</p> <code>''</code> <code>str</code> <p>the string paramenter passed in Download API</p> <code>''</code> <code>int</code> <p>delay of seconds in integer</p> <code>10</code> <code>str</code> <p>URL to access in case of Download API execution succeeded</p> <code>''</code> <code>str</code> <p>URL to access in case of Download API execution Failed</p> <code>''</code> <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>returns Download response</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef Download(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    url: str,\n    filetype: str = \"1 Firmware Upgrade Image\",\n    targetfilename: str = \"\",\n    filesize: int = 200,\n    username: str = \"\",\n    password: str = \"\",\n    commandkey: str = \"\",\n    delayseconds: int = 10,\n    successurl: str = \"\",\n    failureurl: str = \"\",\n    cpe_id: str | None = None,\n) -&gt; list[dict]:\n    \"\"\"Execute Download RPC.\n\n    :param url: URL to download file\n    :type url: str\n    :param filetype: the string paramenter from following 6 values only\n\n        .. code-block:: python\n\n            [\n                \"1 Firmware Upgrade Image\",\n                \"2 Web Content\",\n                \"3 Vendor Configuration File\",\n                \"4 Tone File\",\n                \"5 Ringer File\",\n                \"6 Stored Firmware Image\",\n            ]\n\n    :type filetype: str\n    :param targetfilename: TargetFileName to download through RPC\n    :type targetfilename: str\n    :param filesize: the size of file to download in bytes\n    :type filesize: int\n    :param username: User to authenticate with file Server.  Default=\"\"\n    :type username: str\n    :param password: Password to authenticate with file Server. Default=\"\"\n    :type password: str\n    :param commandkey: the string paramenter passed in Download API\n    :type commandkey: str\n    :param delayseconds: delay of seconds in integer\n    :type delayseconds: int\n    :param successurl: URL to access in case of Download API execution succeeded\n    :type successurl: str\n    :param failureurl: URL to access in case of Download API execution Failed\n    :type failureurl: str\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: returns Download response\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(url)","title":"<code>url</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(filetype)","title":"<code>filetype</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(targetfilename)","title":"<code>targetfilename</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(filesize)","title":"<code>filesize</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(username)","title":"<code>username</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(password)","title":"<code>password</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(commandkey)","title":"<code>commandkey</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(delayseconds)","title":"<code>delayseconds</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(successurl)","title":"<code>successurl</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(failureurl)","title":"<code>failureurl</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Download(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.FactoryReset","title":"FactoryReset  <code>abstractmethod</code>","text":"<pre><code>FactoryReset(cpe_id: str | None = None) -&gt; list[dict]\n</code></pre> <p>Execute FactoryReset RPC.</p> <p>Note: This method only informs if the FactoryReset request initiated or not. The wait for the reboot of the device has to be handled in the test.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>factory reset response</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef FactoryReset(self, cpe_id: str | None = None) -&gt; list[dict]:\n    \"\"\"Execute FactoryReset RPC.\n\n    Note: This method only informs if the FactoryReset request initiated or not.\n    The wait for the reboot of the device has to be handled in the test.\n\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: factory reset response\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.FactoryReset(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPA","title":"GPA  <code>abstractmethod</code>","text":"<pre><code>GPA(param: str, cpe_id: str | None = None) -&gt; list[dict]\n</code></pre> <p>Execute GetParameterAttributes RPC call for the specified parameter.</p> <p>Example usage:</p> <p>acs_server.GPA(\"Device.WiFi.SSID.1.SSID\")</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>parameter to be used in get</p> required <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>dictionary with keys Name, AccessList, Notification indicating the GPA</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef GPA(self, param: str, cpe_id: str | None = None) -&gt; list[dict]:\n    \"\"\"Execute GetParameterAttributes RPC call for the specified parameter.\n\n    Example usage:\n\n    &gt;&gt;&gt; acs_server.GPA(\"Device.WiFi.SSID.1.SSID\")\n\n    :param param: parameter to be used in get\n    :type param: str\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: dictionary with keys Name, AccessList, Notification indicating the GPA\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPA(param)","title":"<code>param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPA(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPN","title":"GPN  <code>abstractmethod</code>","text":"<pre><code>GPN(\n    param: str, next_level: bool, timeout: int | None = None, cpe_id: str | None = None\n) -&gt; list[dict]\n</code></pre> <p>Execute GetParameterNames RPC call for the specified parameter.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>parameter to be discovered</p> required <code>bool</code> <p>displays the next level children of the object if marked true</p> required <code>int | None</code> <p>Lifetime Expiry time</p> <code>None</code> <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>value as a list of dictionary</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef GPN(\n    self,\n    param: str,\n    next_level: bool,\n    timeout: int | None = None,\n    cpe_id: str | None = None,\n) -&gt; list[dict]:\n    \"\"\"Execute GetParameterNames RPC call for the specified parameter.\n\n    :param param: parameter to be discovered\n    :type param: str\n    :param next_level: displays the next level children of the object if marked true\n    :type next_level: bool\n    :param timeout: Lifetime Expiry time\n    :type timeout: Optional[int]\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: value as a list of dictionary\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPN(param)","title":"<code>param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPN(next_level)","title":"<code>next_level</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPN(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPN(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPV","title":"GPV  <code>abstractmethod</code>","text":"<pre><code>GPV(\n    param: GpvInput, timeout: int | None = None, cpe_id: str | None = None\n) -&gt; GpvResponse\n</code></pre> <p>Execute GetParameterValues RPC call for the specified parameter(s).</p> <p>Parameters:</p> Name Type Description Default <code>GpvInput</code> <p>name of the parameter(s) to perform RPC</p> required <code>int | None</code> <p>to set the Lifetime Expiry time, defaults to None</p> <code>None</code> <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>GpvResponse</code> <p>GPV response with keys, value and datatype Example:  .. code-block:: python  [ { \"key\": \"Device.WiFi.AccessPoint.1.AC.1.Alias\", \"value\": \"mok_1\", \"type\": \"string\", } ]</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef GPV(\n    self,\n    param: GpvInput,\n    timeout: int | None = None,\n    cpe_id: str | None = None,\n) -&gt; GpvResponse:\n    \"\"\"Execute GetParameterValues RPC call for the specified parameter(s).\n\n    :param param: name of the parameter(s) to perform RPC\n    :type param: GpvInput\n    :param timeout: to set the Lifetime Expiry time, defaults to None\n    :type timeout: Optional[int]\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: GPV response with keys, value and datatype\n        Example:\n\n        .. code-block:: python\n\n            [\n                {\n                    \"key\": \"Device.WiFi.AccessPoint.1.AC.1.Alias\",\n                    \"value\": \"mok_1\",\n                    \"type\": \"string\",\n                }\n            ]\n\n    :rtype: GpvResponse\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPV(param)","title":"<code>param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPV(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GPV(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GetRPCMethods","title":"GetRPCMethods  <code>abstractmethod</code>","text":"<pre><code>GetRPCMethods(cpe_id: str | None = None) -&gt; list[dict]\n</code></pre> <p>Execute GetRPCMethods RPC.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>GetRPCMethods response of supported functions</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef GetRPCMethods(self, cpe_id: str | None = None) -&gt; list[dict]:\n    \"\"\"Execute GetRPCMethods RPC.\n\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: GetRPCMethods response of supported functions\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.GetRPCMethods(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Reboot","title":"Reboot  <code>abstractmethod</code>","text":"<pre><code>Reboot(CommandKey: str, cpe_id: str | None = None) -&gt; list[dict]\n</code></pre> <p>Execute Reboot RPC.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>reboot command key</p> required <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>reboot RPC response</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef Reboot(self, CommandKey: str, cpe_id: str | None = None) -&gt; list[dict]:\n    \"\"\"Execute Reboot RPC.\n\n    :param CommandKey: reboot command key\n    :type CommandKey: str\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: reboot RPC response\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Reboot(CommandKey)","title":"<code>CommandKey</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.Reboot(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPA","title":"SPA  <code>abstractmethod</code>","text":"<pre><code>SPA(\n    param: list[dict] | dict,\n    notification_param: bool = True,\n    access_param: bool = False,\n    access_list: list | None = None,\n    cpe_id: str | None = None,\n) -&gt; list[dict]\n</code></pre> <p>Execute SetParameterAttributes RPC call for the specified parameter.</p> <p>Example usage:</p> <p>(acs_server.SPA({\"Device.WiFi.SSID.1.SSID\": \"1\"}),)</p> <p>could be parameter list of dicts/dict containing param name and notifications</p> <p>Parameters:</p> Name Type Description Default <code>list[dict] | dict</code> <p>parameter as key of dictionary and notification as its value</p> required <code>bool</code> <p>If True, the value of Notification replaces the current notification setting for this Parameter or group of Parameters. If False, no change is made to the notification setting</p> <code>True</code> <code>bool</code> <p>If True, the value of AccessList replaces the current access list for this Parameter or group of Parameters. If False, no change is made to the access list</p> <code>False</code> <code>list | None</code> <p>Array of zero or more entities for which write access to the specified Parameter(s) is granted</p> <code>None</code> <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>SPA response</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef SPA(\n    self,\n    param: list[dict] | dict,\n    notification_param: bool = True,\n    access_param: bool = False,\n    access_list: list | None = None,\n    cpe_id: str | None = None,\n) -&gt; list[dict]:\n    \"\"\"Execute SetParameterAttributes RPC call for the specified parameter.\n\n    Example usage:\n\n    &gt;&gt;&gt; (acs_server.SPA({\"Device.WiFi.SSID.1.SSID\": \"1\"}),)\n\n    could be parameter list of dicts/dict containing param name and notifications\n\n    :param param: parameter as key of dictionary and notification as its value\n    :type param: Union[list[dict], dict]\n    :param notification_param: If True, the value of Notification replaces the\n        current notification setting for this Parameter or group of Parameters.\n        If False, no change is made to the notification setting\n    :type notification_param: bool\n    :param access_param: If True, the value of AccessList replaces the current\n        access list for this Parameter or group of Parameters.\n        If False, no change is made to the access list\n    :type access_param: bool\n    :param access_list: Array of zero or more entities for which write access to\n        the specified Parameter(s) is granted\n    :type access_list: list, optional\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: SPA response\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPA(param)","title":"<code>param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPA(notification_param)","title":"<code>notification_param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPA(access_param)","title":"<code>access_param</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPA(access_list)","title":"<code>access_list</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPA(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPV","title":"SPV  <code>abstractmethod</code>","text":"<pre><code>SPV(\n    param_value: SpvInput, timeout: int | None = None, cpe_id: str | None = None\n) -&gt; int\n</code></pre> <p>Execute SetParameterValues RPC call for the specified parameter.</p> <p>Parameters:</p> Name Type Description Default <code>SpvInput</code> <p>dictionary that contains the path to the key and the value to be set. Example: .. code-block:: python  {\"Device.WiFi.AccessPoint.1.AC.1.Alias\": \"mok_1\"}</p> required <code>int | None</code> <p>wait time for the RPC to complete, defaults to None</p> <code>None</code> <code>str | None</code> <p>CPE identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>status of the SPV, either 0 or 1</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef SPV(\n    self,\n    param_value: SpvInput,\n    timeout: int | None = None,\n    cpe_id: str | None = None,\n) -&gt; int:\n    \"\"\"Execute SetParameterValues RPC call for the specified parameter.\n\n    :param param_value: dictionary that contains the path to the key and\n        the value to be set. Example:\n        .. code-block:: python\n\n            {\"Device.WiFi.AccessPoint.1.AC.1.Alias\": \"mok_1\"}\n\n    :type param_value: SpvInput\n    :param timeout: wait time for the RPC to complete, defaults to None\n    :type timeout: Optional[int]\n    :param cpe_id: CPE identifier, defaults to None\n    :type cpe_id: Optional[str]\n    :return: status of the SPV, either 0 or 1\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPV(param_value)","title":"<code>param_value</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPV(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.SPV(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.ScheduleInform","title":"ScheduleInform  <code>abstractmethod</code>","text":"<pre><code>ScheduleInform(\n    CommandKey: str = \"Test\", DelaySeconds: int = 20, cpe_id: str | None = None\n) -&gt; list[dict]\n</code></pre> <p>Execute ScheduleInform RPC.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>string to return in the CommandKey element of the InformStruct when the CPE calls the Inform method, defaults to \"Test\"</p> <code>'Test'</code> <code>int</code> <p>number of seconds from the time this method is called to the time the CPE is requested to initiate a one-time Inform method call, defaults to 20</p> <code>20</code> <code>str | None</code> <p>cpe identifier, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>returns ScheduleInform response</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef ScheduleInform(\n    self,\n    CommandKey: str = \"Test\",\n    DelaySeconds: int = 20,\n    cpe_id: str | None = None,\n) -&gt; list[dict]:\n    \"\"\"Execute ScheduleInform RPC.\n\n    :param CommandKey: string to return in the CommandKey element of the\n        InformStruct when the CPE calls the Inform method, defaults to \"Test\"\n    :type CommandKey: str\n    :param DelaySeconds: number of seconds from the time this method is\n        called to the time the CPE is requested to initiate a one-time Inform\n        method call, defaults to 20\n    :type DelaySeconds: int\n    :param cpe_id: cpe identifier, defaults to None\n    :type cpe_id: Optional[str], optional\n    :return: returns ScheduleInform response\n    :rtype: list[dict]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.ScheduleInform(CommandKey)","title":"<code>CommandKey</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.ScheduleInform(DelaySeconds)","title":"<code>DelaySeconds</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.ScheduleInform(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.delete_file","title":"delete_file  <code>abstractmethod</code>","text":"<pre><code>delete_file(filename: str) -&gt; None\n</code></pre> <p>Delete the file from the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef delete_file(self, filename: str) -&gt; None:\n    \"\"\"Delete the file from the device.\n\n    :param filename: name of the file with absolute path\n    :type filename: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.delete_file(filename)","title":"<code>filename</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.provision_cpe_via_tr069","title":"provision_cpe_via_tr069  <code>abstractmethod</code>","text":"<pre><code>provision_cpe_via_tr069(\n    tr069provision_api_list: list[dict[str, list[dict[str, str]]]], cpe_id: str\n) -&gt; None\n</code></pre> <p>Provision the cpe with tr069 parameters defined in env json.</p> <p>Parameters:</p> Name Type Description Default <code>list[dict[str, list[dict[str, str]]]]</code> <p>List of tr069 operations and their values</p> required <code>str</code> <p>cpe identifier</p> required Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef provision_cpe_via_tr069(\n    self,\n    tr069provision_api_list: list[dict[str, list[dict[str, str]]]],\n    cpe_id: str,\n) -&gt; None:\n    \"\"\"Provision the cpe with tr069 parameters defined in env json.\n\n    :param tr069provision_api_list: List of tr069 operations and their values\n    :type tr069provision_api_list: list[dict[str, list[dict[str, str]]]]\n    :param cpe_id: cpe identifier\n    :type cpe_id: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.provision_cpe_via_tr069(tr069provision_api_list)","title":"<code>tr069provision_api_list</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.provision_cpe_via_tr069(cpe_id)","title":"<code>cpe_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.scp_device_file_to_local","title":"scp_device_file_to_local  <code>abstractmethod</code>","text":"<pre><code>scp_device_file_to_local(local_path: str, source_path: str) -&gt; None\n</code></pre> <p>Copy a local file from a server using SCP.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local file path</p> required <code>str</code> <p>source path</p> required Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef scp_device_file_to_local(self, local_path: str, source_path: str) -&gt; None:\n    \"\"\"Copy a local file from a server using SCP.\n\n    :param local_path: local file path\n    :param source_path: source path\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.scp_device_file_to_local(local_path)","title":"<code>local_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.scp_device_file_to_local(source_path)","title":"<code>source_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.start_tcpdump","title":"start_tcpdump  <code>abstractmethod</code>","text":"<pre><code>start_tcpdump(\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str\n</code></pre> <p>Start tcpdump capture on given interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>inteface name where packets to be captured</p> required <code>str | None</code> <p>port number, can be a range of ports(eg: 443 or 433-443)</p> required <code>str</code> <p>pcap file name, Defaults: pkt_capture.pcap</p> <code>'pkt_capture.pcap'</code> <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})</p> <code>None</code> <code>str | None</code> <p>additional filters</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>console ouput and tcpdump process id</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on failed to start tcpdump</p> Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef start_tcpdump(\n    self,\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str:\n    \"\"\"Start tcpdump capture on given interface.\n\n    :param interface: inteface name where packets to be captured\n    :type interface: str\n    :param port: port number, can be a range of ports(eg: 443 or 433-443)\n    :type port: str\n    :param output_file: pcap file name, Defaults: pkt_capture.pcap\n    :type output_file: str\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n    :type filters: Optional[Dict]\n    :param additional_filters: additional filters\n    :type additional_filters: Optional[str]\n    :raises ValueError: on failed to start tcpdump\n    :return: console ouput and tcpdump process id\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.start_tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.start_tcpdump(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.start_tcpdump(output_file)","title":"<code>output_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.start_tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.start_tcpdump(additional_filters)","title":"<code>additional_filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.stop_tcpdump","title":"stop_tcpdump  <code>abstractmethod</code>","text":"<pre><code>stop_tcpdump(process_id: str) -&gt; None\n</code></pre> <p>Stop tcpdump capture.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump process id</p> required Source code in <code>boardfarm3/templates/acs.py</code> <pre><code>@abstractmethod\ndef stop_tcpdump(self, process_id: str) -&gt; None:\n    \"\"\"Stop tcpdump capture.\n\n    :param process_id: tcpdump process id\n    :type process_id: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.acs.ACS.stop_tcpdump(process_id)","title":"<code>process_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.aftr","title":"aftr","text":"<p>Boardfarm AFTR template.</p> <p>Classes:</p> Name Description <code>AFTR</code> <p>Boardfarm AFTR template.</p>"},{"location":"reference/templates/#boardfarm3.templates.aftr.AFTR","title":"AFTR","text":"<p>Boardfarm AFTR template.</p> <p>Methods:</p> Name Description <code>configure_aftr</code> <p>Configure aftr.</p> <code>restart_aftr_process</code> <p>Restart aftr proess.</p>"},{"location":"reference/templates/#boardfarm3.templates.aftr.AFTR.configure_aftr","title":"configure_aftr  <code>abstractmethod</code>","text":"<pre><code>configure_aftr(wan: WAN) -&gt; None\n</code></pre> <p>Configure aftr.</p> <p>Parameters:</p> Name Type Description Default <code>WAN</code> <p>WAN Device</p> required Source code in <code>boardfarm3/templates/aftr.py</code> <pre><code>@abstractmethod\ndef configure_aftr(self, wan: WAN) -&gt; None:\n    \"\"\"Configure aftr.\n\n    :param wan: WAN Device\n    :type wan: WAN\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.aftr.AFTR.configure_aftr(wan)","title":"<code>wan</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.aftr.AFTR.restart_aftr_process","title":"restart_aftr_process  <code>abstractmethod</code>","text":"<pre><code>restart_aftr_process(wan: WAN) -&gt; None\n</code></pre> <p>Restart aftr proess.</p> <p>This is to ensure the ipv4 connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>WAN</code> <p>WAN Device</p> required Source code in <code>boardfarm3/templates/aftr.py</code> <pre><code>@abstractmethod\ndef restart_aftr_process(self, wan: WAN) -&gt; None:\n    \"\"\"Restart aftr proess.\n\n    This is to ensure the ipv4 connectivity.\n\n    :param wan: WAN Device\n    :type wan: WAN\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.aftr.AFTR.restart_aftr_process(wan)","title":"<code>wan</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router","title":"core_router","text":"<p>Core Router Template.</p> <p>Classes:</p> Name Description <code>CoreRouter</code> <p>Core Router Template.</p>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter","title":"CoreRouter","text":"<p>Core Router Template.</p> <p>Methods:</p> Name Description <code>add_route</code> <p>Add a route to a destination via a specific gateway interface.</p> <code>delete_route</code> <p>Delete a route to a destination.</p> <code>get_interface_ipv4addr</code> <p>Return ipv4 address of the interface.</p> <code>get_interface_ipv6addr</code> <p>Return ipv4 address of the interface.</p> <code>is_link_up</code> <p>Return the link status.</p> <code>nmap</code> <p>Perform nmap operation on linux device.</p> <code>ping</code> <p>Ping remote host.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>Device configuration.</p> <code>console</code> <code>BoardfarmPexpect</code> <p>Returns WAN console.</p>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.config","title":"config  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>config: dict\n</code></pre> <p>Device configuration.</p>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.console","title":"console  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>console: BoardfarmPexpect\n</code></pre> <p>Returns WAN console.</p> <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console</p>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.add_route","title":"add_route  <code>abstractmethod</code>","text":"<pre><code>add_route(destination: str, hop: str, gw_interface: str | None) -&gt; None\n</code></pre> <p>Add a route to a destination via a specific gateway interface.</p> <p>The method will internally calculate the exit interface's ip address before adding the route. The gw_interface must be an interface name that exists on the host. Alternatively, you can provide a hop value.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address of the destination</p> required <code>str</code> <p>ip address of the hop</p> required <code>str | None</code> <p>name of the interface</p> required Source code in <code>boardfarm3/templates/core_router.py</code> <pre><code>@abstractmethod\ndef add_route(self, destination: str, hop: str, gw_interface: str | None) -&gt; None:\n    \"\"\"Add a route to a destination via a specific gateway interface.\n\n    The method will internally calculate the exit interface's ip address\n    before adding the route.\n    The gw_interface must be an interface name that exists on the host.\n    Alternatively, you can provide a hop value.\n\n    :param destination: ip address of the destination\n    :type destination: str\n    :param hop: ip address of the hop\n    :type hop: str\n    :param gw_interface: name of the interface\n    :type gw_interface: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.add_route(destination)","title":"<code>destination</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.add_route(hop)","title":"<code>hop</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.add_route(gw_interface)","title":"<code>gw_interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.delete_route","title":"delete_route  <code>abstractmethod</code>","text":"<pre><code>delete_route(destination: str) -&gt; None\n</code></pre> <p>Delete a route to a destination.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address of the destination</p> required Source code in <code>boardfarm3/templates/core_router.py</code> <pre><code>@abstractmethod\ndef delete_route(self, destination: str) -&gt; None:\n    \"\"\"Delete a route to a destination.\n\n    :param destination: ip address of the destination\n    :type destination: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.delete_route(destination)","title":"<code>destination</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.get_interface_ipv4addr","title":"get_interface_ipv4addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv4addr(interface: str) -&gt; str\n</code></pre> <p>Return ipv4 address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv4 of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv4 is not found</p> Source code in <code>boardfarm3/templates/core_router.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv4addr(self, interface: str) -&gt; str:\n    \"\"\"Return ipv4 address of the interface.\n\n    :param interface: interface name\n    :return: IPv4 of the interface\n    :raises BoardfarmException: in case IPv4 is not found\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.get_interface_ipv4addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.get_interface_ipv6addr","title":"get_interface_ipv6addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Return ipv4 address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv6 of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv6 is not found</p> Source code in <code>boardfarm3/templates/core_router.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Return ipv4 address of the interface.\n\n    :param interface: interface name\n    :return: IPv6 of the interface\n    :raises BoardfarmException: in case IPv6 is not found\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.get_interface_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.is_link_up","title":"is_link_up  <code>abstractmethod</code>","text":"<pre><code>is_link_up(interface: str, pattern: str = 'BROADCAST,MULTICAST,UP') -&gt; bool\n</code></pre> <p>Return the link status.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name, defaults to \"BROADCAST,MULTICAST,UP\"</p> required <code>str</code> <p>interface state</p> <code>'BROADCAST,MULTICAST,UP'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the link is up</p> Source code in <code>boardfarm3/templates/core_router.py</code> <pre><code>@abstractmethod\ndef is_link_up(\n    self,\n    interface: str,\n    pattern: str = \"BROADCAST,MULTICAST,UP\",\n) -&gt; bool:\n    \"\"\"Return the link status.\n\n    :param interface: interface name, defaults to \"BROADCAST,MULTICAST,UP\"\n    :type interface: str\n    :param pattern: interface state\n    :type pattern: str\n    :return: True if the link is up\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.is_link_up(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.is_link_up(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap","title":"nmap  <code>abstractmethod</code>","text":"<pre><code>nmap(\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n) -&gt; dict\n</code></pre> <p>Perform nmap operation on linux device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address on which nmap is performed</p> required <code>str</code> <p>type of ip eg: ipv4/ipv6</p> required <code>str | int | None</code> <p>destination port on ip, defaults to None</p> <code>None</code> <code>str | None</code> <p>specific protocol to follow eg: tcp(-sT)/udp(-sU), defaults to None</p> <code>None</code> <code>int | None</code> <p>number of port scan probe retransmissions, defaults to None</p> <code>None</code> <code>int | None</code> <p>Send packets no slower than per second, defaults to None</p> <code>None</code> <code>str | None</code> <p>other options for a nmap command, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>response of nmap command in xml/dict format</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>Raises exception if ip type is invalid</p> Source code in <code>boardfarm3/templates/core_router.py</code> <pre><code>@abstractmethod\ndef nmap(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n) -&gt; dict:\n    \"\"\"Perform nmap operation on linux device.\n\n    :param ipaddr: ip address on which nmap is performed\n    :type ipaddr: str\n    :param ip_type: type of ip eg: ipv4/ipv6\n    :type ip_type: str\n    :param port: destination port on ip, defaults to None\n    :type port: Optional[Union[str, int]], optional\n    :param protocol: specific protocol to follow eg: tcp(-sT)/udp(-sU),\n        defaults to None\n    :type protocol: Optional[str], optional\n    :param max_retries: number of port scan probe retransmissions, defaults to None\n    :type max_retries: Optional[int], optional\n    :param min_rate: Send packets no slower than per second, defaults to None\n    :type min_rate: Optional[int], optional\n    :param opts: other options for a nmap command, defaults to None\n    :type opts: str, optional\n    :raises BoardfarmException: Raises exception if ip type is invalid\n    :return: response of nmap command in xml/dict format\n    :rtype: dict\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap(ipaddr)","title":"<code>ipaddr</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap(min_rate)","title":"<code>min_rate</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.nmap(opts)","title":"<code>opts</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.ping","title":"ping  <code>abstractmethod</code>","text":"<pre><code>ping(\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict\n</code></pre> <p>Ping remote host.</p> <p>Return True if ping has 0% loss or parsed output in JSON if json_output=True flag is provided.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ping ip</p> required <code>int</code> <p>number of ping, defaults to 4</p> <code>4</code> <code>str | None</code> <p>ping via interface, defaults to None</p> <code>None</code> <code>str</code> <p>extra ping options, defaults to \"\"</p> <code>''</code> <code>int</code> <p>timeout, defaults to 50</p> <code>50</code> <code>bool</code> <p>return ping output in dictionary format, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>bool | dict</code> <p>ping output</p> Source code in <code>boardfarm3/templates/core_router.py</code> <pre><code>@abstractmethod\ndef ping(  # noqa: PLR0913\n    self,\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict:\n    \"\"\"Ping remote host.\n\n    Return True if ping has 0% loss\n    or parsed output in JSON if json_output=True flag is provided.\n\n    :param ping_ip: ping ip\n    :param ping_count: number of ping, defaults to 4\n    :param ping_interface: ping via interface, defaults to None\n    :param options: extra ping options, defaults to \"\"\n    :param timeout: timeout, defaults to 50\n    :param json_output: return ping output in dictionary format, defaults to False\n    :return: ping output\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.ping(ping_ip)","title":"<code>ping_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.ping(ping_count)","title":"<code>ping_count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.ping(ping_interface)","title":"<code>ping_interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.ping(options)","title":"<code>options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.ping(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.core_router.CoreRouter.ping(json_output)","title":"<code>json_output</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe","title":"cpe","text":"<p>Boardfarm LGI shared CPE templates.</p> <p>Modules:</p> Name Description <code>cpe</code> <p>CPE template.</p> <code>cpe_hw</code> <p>CPE HW Template.</p> <code>cpe_sw</code> <p>CPE SW Template.</p> <p>Classes:</p> Name Description <code>CPE</code> <p>CPE Template.</p> <code>CPEHW</code> <p>CPE hardware template.</p> <code>CPESW</code> <p>CPE Software Template.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPE","title":"CPE","text":"<p>CPE Template.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>Device configuration.</p> <code>hw</code> <code>CPEHW</code> <p>CPE Hardware.</p> <code>sw</code> <code>CPESW</code> <p>CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPE.config","title":"config  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>config: dict\n</code></pre> <p>Device configuration.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPE.hw","title":"hw  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>hw: CPEHW\n</code></pre> <p>CPE Hardware.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPE.sw","title":"sw  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>sw: CPESW\n</code></pre> <p>CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW","title":"CPEHW","text":"<p>CPE hardware template.</p> <p>Methods:</p> Name Description <code>connect_to_consoles</code> <p>Connect to the consoles.</p> <code>disconnect_from_consoles</code> <p>Disconnect/Close the console connections.</p> <code>flash_via_bootloader</code> <p>Flash cable modem via the bootloader.</p> <code>get_console</code> <p>Return console instance with the given name.</p> <code>get_interactive_consoles</code> <p>Get interactive consoles of the device.</p> <code>power_cycle</code> <p>Power cycle the board via HW (usually via a PDU device).</p> <code>wait_for_hw_boot</code> <p>Wait for the HW boot messages(bootloader).</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict[str, Any]</code> <p>Device config.</p> <code>mac_address</code> <code>str</code> <p>Get the MAC address.</p> <code>mta_iface</code> <code>str</code> <p>MTA interface name.</p> <code>wan_iface</code> <code>str</code> <p>WAN interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.config","title":"config  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>config: dict[str, Any]\n</code></pre> <p>Device config.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.mac_address","title":"mac_address  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>mac_address: str\n</code></pre> <p>Get the MAC address.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.mta_iface","title":"mta_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>mta_iface: str\n</code></pre> <p>MTA interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.wan_iface","title":"wan_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>wan_iface: str\n</code></pre> <p>WAN interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.connect_to_consoles","title":"connect_to_consoles  <code>abstractmethod</code>","text":"<pre><code>connect_to_consoles(device_name: str) -&gt; None\n</code></pre> <p>Connect to the consoles.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the device</p> required Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef connect_to_consoles(self, device_name: str) -&gt; None:\n    \"\"\"Connect to the consoles.\n\n    :param device_name: name of the device\n    :type device_name: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.connect_to_consoles(device_name)","title":"<code>device_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.disconnect_from_consoles","title":"disconnect_from_consoles  <code>abstractmethod</code>","text":"<pre><code>disconnect_from_consoles() -&gt; None\n</code></pre> <p>Disconnect/Close the console connections.</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef disconnect_from_consoles(self) -&gt; None:\n    \"\"\"Disconnect/Close the console connections.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.flash_via_bootloader","title":"flash_via_bootloader  <code>abstractmethod</code>","text":"<pre><code>flash_via_bootloader(\n    image: str,\n    tftp_devices: dict[str, TFTP],\n    termination_sys: TerminationSystem = None,\n    method: str | None = None,\n) -&gt; None\n</code></pre> <p>Flash cable modem via the bootloader.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>image name</p> required <code>dict[str, TFTP]</code> <p>a list of LAN side TFTP devices</p> required <code>TerminationSystem</code> <p>the termination system device (e.g. CMTS), defaults to None</p> <code>None</code> <code>str | None</code> <p>flash method, defaults to None</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>as a safety measure</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef flash_via_bootloader(\n    self,\n    image: str,\n    tftp_devices: dict[str, TFTP],\n    termination_sys: TerminationSystem = None,\n    method: str | None = None,\n) -&gt; None:\n    \"\"\"Flash cable modem via the bootloader.\n\n    :param image: image name\n    :type image: str\n    :param tftp_devices: a list of LAN side TFTP devices\n    :type tftp_devices: dict[str, TFTP]\n    :param termination_sys: the termination system device (e.g. CMTS),\n        defaults to None\n    :type termination_sys: TerminationSystem\n    :param method: flash method, defaults to None\n    :type method: str, optional\n    :raises NotImplementedError: as a safety measure\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.flash_via_bootloader(image)","title":"<code>image</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.flash_via_bootloader(tftp_devices)","title":"<code>tftp_devices</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.flash_via_bootloader(termination_sys)","title":"<code>termination_sys</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.flash_via_bootloader(method)","title":"<code>method</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.get_console","title":"get_console  <code>abstractmethod</code>","text":"<pre><code>get_console(console_name: str) -&gt; BoardfarmPexpect\n</code></pre> <p>Return console instance with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the console</p> required <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console instance with given name</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on unknown console name</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef get_console(self, console_name: str) -&gt; BoardfarmPexpect:\n    \"\"\"Return console instance with the given name.\n\n    :param console_name: name of the console\n    :type console_name: str\n    :raises ValueError: on unknown console name\n    :return: console instance with given name\n    :rtype: BoardfarmPexpect\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.get_console(console_name)","title":"<code>console_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.get_interactive_consoles","title":"get_interactive_consoles  <code>abstractmethod</code>","text":"<pre><code>get_interactive_consoles() -&gt; dict[str, BoardfarmPexpect]\n</code></pre> <p>Get interactive consoles of the device.</p> <p>Returns:</p> Type Description <code>Dict[str, BoardfarmPexpect]</code> <p>device interactive consoles</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef get_interactive_consoles(self) -&gt; dict[str, BoardfarmPexpect]:\n    \"\"\"Get interactive consoles of the device.\n\n    :returns: device interactive consoles\n    :rtype: Dict[str, BoardfarmPexpect]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.power_cycle","title":"power_cycle  <code>abstractmethod</code>","text":"<pre><code>power_cycle() -&gt; None\n</code></pre> <p>Power cycle the board via HW (usually via a PDU device).</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef power_cycle(self) -&gt; None:\n    \"\"\"Power cycle the board via HW (usually via a PDU device).\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPEHW.wait_for_hw_boot","title":"wait_for_hw_boot  <code>abstractmethod</code>","text":"<pre><code>wait_for_hw_boot() -&gt; None\n</code></pre> <p>Wait for the HW boot messages(bootloader).</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef wait_for_hw_boot(self) -&gt; None:\n    \"\"\"Wait for the HW boot messages(bootloader).\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW","title":"CPESW","text":"<p>CPE Software Template.</p> <p>Methods:</p> Name Description <code>add_info_to_file</code> <p>Add data into a file.</p> <code>enable_logs</code> <p>Enable logs for given component.</p> <code>factory_reset</code> <p>Perform factory reset CPE via given method.</p> <code>finalize_boot</code> <p>Validate board settings post boot.</p> <code>get_board_logs</code> <p>Return board console logs for given timeout.</p> <code>get_boottime_log</code> <p>Return the boot time log from the board.</p> <code>get_date</code> <p>Get the system date and time.</p> <code>get_file_content</code> <p>Get the content of the given file.</p> <code>get_interface_ipv4addr</code> <p>Return given interface IPv4 address.</p> <code>get_interface_ipv6addr</code> <p>Return given interface IPv6 address.</p> <code>get_interface_link_local_ipv6_addr</code> <p>Return given interface link local IPv6 address.</p> <code>get_interface_mac_addr</code> <p>Return given interface mac address.</p> <code>get_interface_mtu_size</code> <p>Get the MTU size of the interface in bytes.</p> <code>get_load_avg</code> <p>Return current load average of the CPE.</p> <code>get_memory_utilization</code> <p>Return the current memory utilization of the CPE.</p> <code>get_ntp_sync_status</code> <p>Execute ntpq command to get the synchronization status.</p> <code>get_provision_mode</code> <p>Return provision mode.</p> <code>get_running_processes</code> <p>Return the currently running processes in the CPE via the <code>ps</code> command.</p> <code>get_seconds_uptime</code> <p>Return uptime in seconds.</p> <code>get_tr069_log</code> <p>Return the TR-069 log from the board.</p> <code>is_link_up</code> <p>Return the link status.</p> <code>is_online</code> <p>Is CPE online.</p> <code>is_production</code> <p>Is production software.</p> <code>is_tr069_connected</code> <p>Is TR-69 agent is connected.</p> <code>kill_process_immediately</code> <p>Kills any process based on the provided process ID.</p> <code>read_event_logs</code> <p>Return the event logs from the <code>logread</code> command.</p> <code>reset</code> <p>Perform reset via given method.</p> <code>set_date</code> <p>Set the device's date and time.</p> <code>verify_cpe_is_booting</code> <p>Verify CPE is booting.</p> <code>wait_for_boot</code> <p>Wait for CPE to boot.</p> <p>Attributes:</p> Name Type Description <code>aftr_iface</code> <code>str</code> <p>AFTR interface name.</p> <code>cpe_id</code> <code>str</code> <p>TR069 CPE ID.</p> <code>dmcli</code> <code>DMCLIAPI</code> <p>Dmcli instance running in CPE Software (if any).</p> <code>erouter_iface</code> <code>str</code> <p>e-Router interface name.</p> <code>firewall</code> <code>IptablesFirewall</code> <p>Firewall component of cpe software.</p> <code>guest_iface</code> <code>str</code> <p>Guest network interface name.</p> <code>gui_password</code> <code>str</code> <p>GUI login password.</p> <code>json_values</code> <code>dict[str, Any]</code> <p>CPE Specific JSON values.</p> <code>lan_gateway_ipv4</code> <code>IPv4Address</code> <p>LAN Gateway IPv4 address.</p> <code>lan_gateway_ipv6</code> <code>IPv6Address</code> <p>LAN Gateway IPv6 address.</p> <code>lan_iface</code> <code>str</code> <p>LAN interface name.</p> <code>lan_network_ipv4</code> <code>IPv4Network</code> <p>LAN IPv4 network.</p> <code>nw_utility</code> <code>NetworkUtility</code> <p>Network utility component of cpe software.</p> <code>tr69_cpe_id</code> <code>str</code> <p>TR-69 CPE Identifier.</p> <code>version</code> <code>str</code> <p>CPE software version.</p> <code>wifi</code> <code>WiFiHal</code> <p>Wifi instance CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.aftr_iface","title":"aftr_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>aftr_iface: str\n</code></pre> <p>AFTR interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.cpe_id","title":"cpe_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>cpe_id: str\n</code></pre> <p>TR069 CPE ID.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.dmcli","title":"dmcli  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>dmcli: DMCLIAPI\n</code></pre> <p>Dmcli instance running in CPE Software (if any).</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.erouter_iface","title":"erouter_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>erouter_iface: str\n</code></pre> <p>e-Router interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.firewall","title":"firewall  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>firewall: IptablesFirewall\n</code></pre> <p>Firewall component of cpe software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.guest_iface","title":"guest_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>guest_iface: str\n</code></pre> <p>Guest network interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.gui_password","title":"gui_password  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>gui_password: str\n</code></pre> <p>GUI login password.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.json_values","title":"json_values  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>json_values: dict[str, Any]\n</code></pre> <p>CPE Specific JSON values.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.lan_gateway_ipv4","title":"lan_gateway_ipv4  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_gateway_ipv4: IPv4Address\n</code></pre> <p>LAN Gateway IPv4 address.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.lan_gateway_ipv6","title":"lan_gateway_ipv6  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_gateway_ipv6: IPv6Address\n</code></pre> <p>LAN Gateway IPv6 address.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.lan_iface","title":"lan_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_iface: str\n</code></pre> <p>LAN interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.lan_network_ipv4","title":"lan_network_ipv4  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_network_ipv4: IPv4Network\n</code></pre> <p>LAN IPv4 network.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.nw_utility","title":"nw_utility  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nw_utility: NetworkUtility\n</code></pre> <p>Network utility component of cpe software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.tr69_cpe_id","title":"tr69_cpe_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>tr69_cpe_id: str\n</code></pre> <p>TR-69 CPE Identifier.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.version","title":"version  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>version: str\n</code></pre> <p>CPE software version.</p> <p>This will reload after each flash.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.wifi","title":"wifi  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>wifi: WiFiHal\n</code></pre> <p>Wifi instance CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.add_info_to_file","title":"add_info_to_file  <code>abstractmethod</code>","text":"<pre><code>add_info_to_file(to_add: str, fname: str) -&gt; None\n</code></pre> <p>Add data into a file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>contents/data to be added to a file.</p> required <code>str</code> <p>filename with absolute path</p> required Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef add_info_to_file(self, to_add: str, fname: str) -&gt; None:\n    \"\"\"Add data into a file.\n\n    :param to_add: contents/data to be added to a file.\n    :type to_add: str\n    :param fname: filename with absolute path\n    :type fname: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.add_info_to_file(to_add)","title":"<code>to_add</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.add_info_to_file(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.enable_logs","title":"enable_logs  <code>abstractmethod</code>","text":"<pre><code>enable_logs(component: str, flag: str = 'enable') -&gt; None\n</code></pre> <p>Enable logs for given component.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>component name</p> required <code>str</code> <p>flag name, Default: \"enable\"</p> <code>'enable'</code> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef enable_logs(self, component: str, flag: str = \"enable\") -&gt; None:\n    \"\"\"Enable logs for given component.\n\n    :param component: component name\n    :param flag: flag name, Default: \"enable\"\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.enable_logs(component)","title":"<code>component</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.enable_logs(flag)","title":"<code>flag</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.factory_reset","title":"factory_reset  <code>abstractmethod</code>","text":"<pre><code>factory_reset(method: str | None = None) -&gt; bool\n</code></pre> <p>Perform factory reset CPE via given method.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>factory reset method. Default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True on successful factory reset, False otherwise</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef factory_reset(self, method: str | None = None) -&gt; bool:\n    \"\"\"Perform factory reset CPE via given method.\n\n    :param method: factory reset method. Default None.\n    :type method: str | None\n    :return: True on successful factory reset, False otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.factory_reset(method)","title":"<code>method</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.finalize_boot","title":"finalize_boot  <code>abstractmethod</code>","text":"<pre><code>finalize_boot() -&gt; bool\n</code></pre> <p>Validate board settings post boot.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True on successful validation</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef finalize_boot(self) -&gt; bool:\n    \"\"\"Validate board settings post boot.\n\n    :return: True on successful validation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_board_logs","title":"get_board_logs  <code>abstractmethod</code>","text":"<pre><code>get_board_logs(timeout: int = 300) -&gt; str\n</code></pre> <p>Return board console logs for given timeout.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>log capture time in seconds</p> <code>300</code> <p>Returns:</p> Type Description <code>str</code> <p>captured logs</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_board_logs(self, timeout: int = 300) -&gt; str:\n    \"\"\"Return board console logs for given timeout.\n\n    :param timeout: log capture time in seconds\n    :return: captured logs\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_board_logs(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_boottime_log","title":"get_boottime_log  <code>abstractmethod</code>","text":"<pre><code>get_boottime_log() -&gt; list[str]\n</code></pre> <p>Return the boot time log from the board.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>boot time log</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_boottime_log(self) -&gt; list[str]:\n    \"\"\"Return the boot time log from the board.\n\n    :return: boot time log\n    :rtype: list[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_date","title":"get_date  <code>abstractmethod</code>","text":"<pre><code>get_date() -&gt; str | None\n</code></pre> <p>Get the system date and time.</p> <p>.. code-block:: python</p> <pre><code># example output\ndonderdag, mei 23, 2024 14:23:39\n</code></pre> <p>Returns:</p> Type Description <code>str | None</code> <p>date</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_date(self) -&gt; str | None:\n    \"\"\"Get the system date and time.\n\n    .. code-block:: python\n\n        # example output\n        donderdag, mei 23, 2024 14:23:39\n\n\n    :return: date\n    :rtype: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_file_content","title":"get_file_content  <code>abstractmethod</code>","text":"<pre><code>get_file_content(fname: str, timeout: int) -&gt; str\n</code></pre> <p>Get the content of the given file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required <code>int</code> <p>timeout value to fetch the file content</p> required <p>Returns:</p> Type Description <code>str</code> <p>contents of the file</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_file_content(self, fname: str, timeout: int) -&gt; str:\n    \"\"\"Get the content of the given file.\n\n    :param fname: name of the file with absolute path\n    :type fname: str\n    :param timeout: timeout value to fetch the file content\n    :type timeout: int\n    :return: contents of the file\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_file_content(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_file_content(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_ipv4addr","title":"get_interface_ipv4addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv4addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface IPv4 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv4addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface IPv4 address.\n\n    :param interface: interface name\n    :return: IPv4 address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_ipv4addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_ipv6addr","title":"get_interface_ipv6addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface IPv6 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface IPv6 address.\n\n    :param interface: interface name\n    :return: IPv6 address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_link_local_ipv6_addr","title":"get_interface_link_local_ipv6_addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_link_local_ipv6_addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface link local IPv6 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>link local IPv6 address</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_link_local_ipv6_addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface link local IPv6 address.\n\n    :param interface: interface name\n    :return: link local IPv6 address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_link_local_ipv6_addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_mac_addr","title":"get_interface_mac_addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_mac_addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface mac address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>mac address of the given interface</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_mac_addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface mac address.\n\n    :param interface: interface name\n    :return: mac address of the given interface\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_mac_addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_mtu_size","title":"get_interface_mtu_size  <code>abstractmethod</code>","text":"<pre><code>get_interface_mtu_size(interface: str) -&gt; int\n</code></pre> <p>Get the MTU size of the interface in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>int</code> <p>size of the MTU in bytes</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_mtu_size(self, interface: str) -&gt; int:\n    \"\"\"Get the MTU size of the interface in bytes.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: size of the MTU in bytes\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_interface_mtu_size(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_load_avg","title":"get_load_avg  <code>abstractmethod</code>","text":"<pre><code>get_load_avg() -&gt; float\n</code></pre> <p>Return current load average of the CPE.</p> <p>Returns:</p> Type Description <code>float</code> <p>current load average</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_load_avg(self) -&gt; float:\n    \"\"\"Return current load average of the CPE.\n\n    :return: current load average\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_memory_utilization","title":"get_memory_utilization  <code>abstractmethod</code>","text":"<pre><code>get_memory_utilization() -&gt; dict[str, int]\n</code></pre> <p>Return the current memory utilization of the CPE.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>current memory utilization</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_memory_utilization(self) -&gt; dict[str, int]:\n    \"\"\"Return the current memory utilization of the CPE.\n\n    :return: current memory utilization\n    :rtype: dict[str, int]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_ntp_sync_status","title":"get_ntp_sync_status  <code>abstractmethod</code>","text":"<pre><code>get_ntp_sync_status() -&gt; list[dict[str, Any]]\n</code></pre> <p>Execute ntpq command to get the synchronization status.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>parsed output of ntpq command</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_ntp_sync_status(\n    self,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute ntpq command to get the synchronization status.\n\n    :return: parsed output of ntpq command\n    :rtype: list[dict[str, Any]]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_provision_mode","title":"get_provision_mode  <code>abstractmethod</code>","text":"<pre><code>get_provision_mode() -&gt; str\n</code></pre> <p>Return provision mode.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_provision_mode(self) -&gt; str:\n    \"\"\"Return provision mode.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_running_processes","title":"get_running_processes  <code>abstractmethod</code>","text":"<pre><code>get_running_processes(ps_options: str = '-A') -&gt; Iterable[ParsedPSOutput]\n</code></pre> <p>Return the currently running processes in the CPE via the <code>ps</code> command.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The options to be passed to the ps command, defaults to \"-A\"</p> <code>'-A'</code> <p>Returns:</p> Type Description <code>Iterable[ParsedPSOutput]</code> <p>the currently running processes as a parsed tuple of dictionaries</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_running_processes(\n    self,\n    ps_options: str = \"-A\",\n) -&gt; Iterable[ParsedPSOutput]:\n    \"\"\"Return the currently running processes in the CPE via the `ps` command.\n\n    :param ps_options: The options to be passed to the ps command, defaults to \"-A\"\n    :type ps_options: str\n    :return: the currently running processes as a parsed tuple of dictionaries\n    :rtype: Iterable[ParsedPSOutput]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_running_processes(ps_options)","title":"<code>ps_options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_seconds_uptime","title":"get_seconds_uptime  <code>abstractmethod</code>","text":"<pre><code>get_seconds_uptime() -&gt; float\n</code></pre> <p>Return uptime in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>uptime in seconds</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_seconds_uptime(self) -&gt; float:\n    \"\"\"Return uptime in seconds.\n\n    :return: uptime in seconds\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.get_tr069_log","title":"get_tr069_log  <code>abstractmethod</code>","text":"<pre><code>get_tr069_log() -&gt; list[str]\n</code></pre> <p>Return the TR-069 log from the board.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>TR-069 logs</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_tr069_log(self) -&gt; list[str]:\n    \"\"\"Return the TR-069 log from the board.\n\n    :return: TR-069 logs\n    :rtype: list[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.is_link_up","title":"is_link_up  <code>abstractmethod</code>","text":"<pre><code>is_link_up(interface: str, pattern: str = 'BROADCAST,MULTICAST,UP') -&gt; bool\n</code></pre> <p>Return the link status.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface state</p> required <code>str</code> <p>interface name, defaults to \"BROADCAST,MULTICAST,UP\"</p> <code>'BROADCAST,MULTICAST,UP'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the link is up</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_link_up(\n    self,\n    interface: str,\n    pattern: str = \"BROADCAST,MULTICAST,UP\",\n) -&gt; bool:\n    \"\"\"Return the link status.\n\n    :param interface: interface state\n    :type interface: str\n    :param pattern: interface name, defaults to \"BROADCAST,MULTICAST,UP\"\n    :type pattern: str\n    :return: True if the link is up\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.is_link_up(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.is_link_up(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.is_online","title":"is_online  <code>abstractmethod</code>","text":"<pre><code>is_online() -&gt; bool\n</code></pre> <p>Is CPE online.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the CPE is online, False otherwise</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_online(self) -&gt; bool:\n    \"\"\"Is CPE online.\n\n    :return: True if the CPE is online, False otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.is_production","title":"is_production  <code>abstractmethod</code>","text":"<pre><code>is_production() -&gt; bool\n</code></pre> <p>Is production software.</p> <p>Production software has limited capabilities.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_production(self) -&gt; bool:\n    \"\"\"Is production software.\n\n    Production software has limited capabilities.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.is_tr069_connected","title":"is_tr069_connected  <code>abstractmethod</code>","text":"<pre><code>is_tr069_connected() -&gt; bool\n</code></pre> <p>Is TR-69 agent is connected.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True is TR-69 is connected, otherwise False</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_tr069_connected(self) -&gt; bool:\n    \"\"\"Is TR-69 agent is connected.\n\n    :return: True is TR-69 is connected, otherwise False\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.kill_process_immediately","title":"kill_process_immediately  <code>abstractmethod</code>","text":"<pre><code>kill_process_immediately(pid: int) -&gt; None\n</code></pre> <p>Kills any process based on the provided process ID.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>process number</p> required Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef kill_process_immediately(self, pid: int) -&gt; None:\n    \"\"\"Kills any process based on the provided process ID.\n\n    :param pid: process number\n    :type pid: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.kill_process_immediately(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.read_event_logs","title":"read_event_logs  <code>abstractmethod</code>","text":"<pre><code>read_event_logs() -&gt; JSONDictType | list[JSONDictType] | Iterator[JSONDictType]\n</code></pre> <p>Return the event logs from the <code>logread</code> command.</p> <p>Returns:</p> Type Description <code>JSONDictType | list[JSONDictType] | Iterator[JSONDictType]</code> <p>the event logs from the <code>logread</code> command.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef read_event_logs(\n    self,\n) -&gt; JSONDictType | list[JSONDictType] | Iterator[JSONDictType]:\n    \"\"\"Return the event logs from the `logread` command.\n\n    :return: the event logs from the `logread` command.\n    :rtype: JSONDictType | list[JSONDictType] | Iterator[JSONDictType]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.reset","title":"reset  <code>abstractmethod</code>","text":"<pre><code>reset(method: str | None = None) -&gt; None\n</code></pre> <p>Perform reset via given method.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>reset method. Default None</p> <code>None</code> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef reset(self, method: str | None = None) -&gt; None:\n    \"\"\"Perform reset via given method.\n\n    :param method: reset method. Default None\n    :type method: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.reset(method)","title":"<code>method</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.set_date","title":"set_date  <code>abstractmethod</code>","text":"<pre><code>set_date(date_string: str) -&gt; bool\n</code></pre> <p>Set the device's date and time.</p> <p>It should execute <code>date -s {date_string}</code> on the device's console.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>value to be changed</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if set is successful</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef set_date(self, date_string: str) -&gt; bool:\n    \"\"\"Set the device's date and time.\n\n    It should execute `date -s {date_string}` on the device's console.\n\n    :param date_string: value to be changed\n    :type date_string: str\n    :return: True if set is successful\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.set_date(date_string)","title":"<code>date_string</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.verify_cpe_is_booting","title":"verify_cpe_is_booting  <code>abstractmethod</code>","text":"<pre><code>verify_cpe_is_booting() -&gt; None\n</code></pre> <p>Verify CPE is booting.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef verify_cpe_is_booting(self) -&gt; None:\n    \"\"\"Verify CPE is booting.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.CPESW.wait_for_boot","title":"wait_for_boot  <code>abstractmethod</code>","text":"<pre><code>wait_for_boot() -&gt; None\n</code></pre> <p>Wait for CPE to boot.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef wait_for_boot(self) -&gt; None:\n    \"\"\"Wait for CPE to boot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe","title":"cpe","text":"<p>CPE template.</p> <p>Classes:</p> Name Description <code>CPE</code> <p>CPE Template.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe.CPE","title":"CPE","text":"<p>CPE Template.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>Device configuration.</p> <code>hw</code> <code>CPEHW</code> <p>CPE Hardware.</p> <code>sw</code> <code>CPESW</code> <p>CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe.CPE.config","title":"config  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>config: dict\n</code></pre> <p>Device configuration.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe.CPE.hw","title":"hw  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>hw: CPEHW\n</code></pre> <p>CPE Hardware.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe.CPE.sw","title":"sw  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>sw: CPESW\n</code></pre> <p>CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw","title":"cpe_hw","text":"<p>CPE HW Template.</p> <p>Classes:</p> Name Description <code>CPEHW</code> <p>CPE hardware template.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW","title":"CPEHW","text":"<p>CPE hardware template.</p> <p>Methods:</p> Name Description <code>connect_to_consoles</code> <p>Connect to the consoles.</p> <code>disconnect_from_consoles</code> <p>Disconnect/Close the console connections.</p> <code>flash_via_bootloader</code> <p>Flash cable modem via the bootloader.</p> <code>get_console</code> <p>Return console instance with the given name.</p> <code>get_interactive_consoles</code> <p>Get interactive consoles of the device.</p> <code>power_cycle</code> <p>Power cycle the board via HW (usually via a PDU device).</p> <code>wait_for_hw_boot</code> <p>Wait for the HW boot messages(bootloader).</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict[str, Any]</code> <p>Device config.</p> <code>mac_address</code> <code>str</code> <p>Get the MAC address.</p> <code>mta_iface</code> <code>str</code> <p>MTA interface name.</p> <code>wan_iface</code> <code>str</code> <p>WAN interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.config","title":"config  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>config: dict[str, Any]\n</code></pre> <p>Device config.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.mac_address","title":"mac_address  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>mac_address: str\n</code></pre> <p>Get the MAC address.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.mta_iface","title":"mta_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>mta_iface: str\n</code></pre> <p>MTA interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.wan_iface","title":"wan_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>wan_iface: str\n</code></pre> <p>WAN interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.connect_to_consoles","title":"connect_to_consoles  <code>abstractmethod</code>","text":"<pre><code>connect_to_consoles(device_name: str) -&gt; None\n</code></pre> <p>Connect to the consoles.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the device</p> required Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef connect_to_consoles(self, device_name: str) -&gt; None:\n    \"\"\"Connect to the consoles.\n\n    :param device_name: name of the device\n    :type device_name: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.connect_to_consoles(device_name)","title":"<code>device_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.disconnect_from_consoles","title":"disconnect_from_consoles  <code>abstractmethod</code>","text":"<pre><code>disconnect_from_consoles() -&gt; None\n</code></pre> <p>Disconnect/Close the console connections.</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef disconnect_from_consoles(self) -&gt; None:\n    \"\"\"Disconnect/Close the console connections.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.flash_via_bootloader","title":"flash_via_bootloader  <code>abstractmethod</code>","text":"<pre><code>flash_via_bootloader(\n    image: str,\n    tftp_devices: dict[str, TFTP],\n    termination_sys: TerminationSystem = None,\n    method: str | None = None,\n) -&gt; None\n</code></pre> <p>Flash cable modem via the bootloader.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>image name</p> required <code>dict[str, TFTP]</code> <p>a list of LAN side TFTP devices</p> required <code>TerminationSystem</code> <p>the termination system device (e.g. CMTS), defaults to None</p> <code>None</code> <code>str | None</code> <p>flash method, defaults to None</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>as a safety measure</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef flash_via_bootloader(\n    self,\n    image: str,\n    tftp_devices: dict[str, TFTP],\n    termination_sys: TerminationSystem = None,\n    method: str | None = None,\n) -&gt; None:\n    \"\"\"Flash cable modem via the bootloader.\n\n    :param image: image name\n    :type image: str\n    :param tftp_devices: a list of LAN side TFTP devices\n    :type tftp_devices: dict[str, TFTP]\n    :param termination_sys: the termination system device (e.g. CMTS),\n        defaults to None\n    :type termination_sys: TerminationSystem\n    :param method: flash method, defaults to None\n    :type method: str, optional\n    :raises NotImplementedError: as a safety measure\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.flash_via_bootloader(image)","title":"<code>image</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.flash_via_bootloader(tftp_devices)","title":"<code>tftp_devices</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.flash_via_bootloader(termination_sys)","title":"<code>termination_sys</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.flash_via_bootloader(method)","title":"<code>method</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.get_console","title":"get_console  <code>abstractmethod</code>","text":"<pre><code>get_console(console_name: str) -&gt; BoardfarmPexpect\n</code></pre> <p>Return console instance with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the console</p> required <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console instance with given name</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on unknown console name</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef get_console(self, console_name: str) -&gt; BoardfarmPexpect:\n    \"\"\"Return console instance with the given name.\n\n    :param console_name: name of the console\n    :type console_name: str\n    :raises ValueError: on unknown console name\n    :return: console instance with given name\n    :rtype: BoardfarmPexpect\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.get_console(console_name)","title":"<code>console_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.get_interactive_consoles","title":"get_interactive_consoles  <code>abstractmethod</code>","text":"<pre><code>get_interactive_consoles() -&gt; dict[str, BoardfarmPexpect]\n</code></pre> <p>Get interactive consoles of the device.</p> <p>Returns:</p> Type Description <code>Dict[str, BoardfarmPexpect]</code> <p>device interactive consoles</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef get_interactive_consoles(self) -&gt; dict[str, BoardfarmPexpect]:\n    \"\"\"Get interactive consoles of the device.\n\n    :returns: device interactive consoles\n    :rtype: Dict[str, BoardfarmPexpect]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.power_cycle","title":"power_cycle  <code>abstractmethod</code>","text":"<pre><code>power_cycle() -&gt; None\n</code></pre> <p>Power cycle the board via HW (usually via a PDU device).</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef power_cycle(self) -&gt; None:\n    \"\"\"Power cycle the board via HW (usually via a PDU device).\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_hw.CPEHW.wait_for_hw_boot","title":"wait_for_hw_boot  <code>abstractmethod</code>","text":"<pre><code>wait_for_hw_boot() -&gt; None\n</code></pre> <p>Wait for the HW boot messages(bootloader).</p> Source code in <code>boardfarm3/templates/cpe/cpe_hw.py</code> <pre><code>@abstractmethod\ndef wait_for_hw_boot(self) -&gt; None:\n    \"\"\"Wait for the HW boot messages(bootloader).\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw","title":"cpe_sw","text":"<p>CPE SW Template.</p> <p>Classes:</p> Name Description <code>CPESW</code> <p>CPE Software Template.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW","title":"CPESW","text":"<p>CPE Software Template.</p> <p>Methods:</p> Name Description <code>add_info_to_file</code> <p>Add data into a file.</p> <code>enable_logs</code> <p>Enable logs for given component.</p> <code>factory_reset</code> <p>Perform factory reset CPE via given method.</p> <code>finalize_boot</code> <p>Validate board settings post boot.</p> <code>get_board_logs</code> <p>Return board console logs for given timeout.</p> <code>get_boottime_log</code> <p>Return the boot time log from the board.</p> <code>get_date</code> <p>Get the system date and time.</p> <code>get_file_content</code> <p>Get the content of the given file.</p> <code>get_interface_ipv4addr</code> <p>Return given interface IPv4 address.</p> <code>get_interface_ipv6addr</code> <p>Return given interface IPv6 address.</p> <code>get_interface_link_local_ipv6_addr</code> <p>Return given interface link local IPv6 address.</p> <code>get_interface_mac_addr</code> <p>Return given interface mac address.</p> <code>get_interface_mtu_size</code> <p>Get the MTU size of the interface in bytes.</p> <code>get_load_avg</code> <p>Return current load average of the CPE.</p> <code>get_memory_utilization</code> <p>Return the current memory utilization of the CPE.</p> <code>get_ntp_sync_status</code> <p>Execute ntpq command to get the synchronization status.</p> <code>get_provision_mode</code> <p>Return provision mode.</p> <code>get_running_processes</code> <p>Return the currently running processes in the CPE via the <code>ps</code> command.</p> <code>get_seconds_uptime</code> <p>Return uptime in seconds.</p> <code>get_tr069_log</code> <p>Return the TR-069 log from the board.</p> <code>is_link_up</code> <p>Return the link status.</p> <code>is_online</code> <p>Is CPE online.</p> <code>is_production</code> <p>Is production software.</p> <code>is_tr069_connected</code> <p>Is TR-69 agent is connected.</p> <code>kill_process_immediately</code> <p>Kills any process based on the provided process ID.</p> <code>read_event_logs</code> <p>Return the event logs from the <code>logread</code> command.</p> <code>reset</code> <p>Perform reset via given method.</p> <code>set_date</code> <p>Set the device's date and time.</p> <code>verify_cpe_is_booting</code> <p>Verify CPE is booting.</p> <code>wait_for_boot</code> <p>Wait for CPE to boot.</p> <p>Attributes:</p> Name Type Description <code>aftr_iface</code> <code>str</code> <p>AFTR interface name.</p> <code>cpe_id</code> <code>str</code> <p>TR069 CPE ID.</p> <code>dmcli</code> <code>DMCLIAPI</code> <p>Dmcli instance running in CPE Software (if any).</p> <code>erouter_iface</code> <code>str</code> <p>e-Router interface name.</p> <code>firewall</code> <code>IptablesFirewall</code> <p>Firewall component of cpe software.</p> <code>guest_iface</code> <code>str</code> <p>Guest network interface name.</p> <code>gui_password</code> <code>str</code> <p>GUI login password.</p> <code>json_values</code> <code>dict[str, Any]</code> <p>CPE Specific JSON values.</p> <code>lan_gateway_ipv4</code> <code>IPv4Address</code> <p>LAN Gateway IPv4 address.</p> <code>lan_gateway_ipv6</code> <code>IPv6Address</code> <p>LAN Gateway IPv6 address.</p> <code>lan_iface</code> <code>str</code> <p>LAN interface name.</p> <code>lan_network_ipv4</code> <code>IPv4Network</code> <p>LAN IPv4 network.</p> <code>nw_utility</code> <code>NetworkUtility</code> <p>Network utility component of cpe software.</p> <code>tr69_cpe_id</code> <code>str</code> <p>TR-69 CPE Identifier.</p> <code>version</code> <code>str</code> <p>CPE software version.</p> <code>wifi</code> <code>WiFiHal</code> <p>Wifi instance CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.aftr_iface","title":"aftr_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>aftr_iface: str\n</code></pre> <p>AFTR interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.cpe_id","title":"cpe_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>cpe_id: str\n</code></pre> <p>TR069 CPE ID.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.dmcli","title":"dmcli  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>dmcli: DMCLIAPI\n</code></pre> <p>Dmcli instance running in CPE Software (if any).</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.erouter_iface","title":"erouter_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>erouter_iface: str\n</code></pre> <p>e-Router interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.firewall","title":"firewall  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>firewall: IptablesFirewall\n</code></pre> <p>Firewall component of cpe software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.guest_iface","title":"guest_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>guest_iface: str\n</code></pre> <p>Guest network interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.gui_password","title":"gui_password  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>gui_password: str\n</code></pre> <p>GUI login password.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.json_values","title":"json_values  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>json_values: dict[str, Any]\n</code></pre> <p>CPE Specific JSON values.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.lan_gateway_ipv4","title":"lan_gateway_ipv4  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_gateway_ipv4: IPv4Address\n</code></pre> <p>LAN Gateway IPv4 address.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.lan_gateway_ipv6","title":"lan_gateway_ipv6  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_gateway_ipv6: IPv6Address\n</code></pre> <p>LAN Gateway IPv6 address.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.lan_iface","title":"lan_iface  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_iface: str\n</code></pre> <p>LAN interface name.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.lan_network_ipv4","title":"lan_network_ipv4  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_network_ipv4: IPv4Network\n</code></pre> <p>LAN IPv4 network.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.nw_utility","title":"nw_utility  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nw_utility: NetworkUtility\n</code></pre> <p>Network utility component of cpe software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.tr69_cpe_id","title":"tr69_cpe_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>tr69_cpe_id: str\n</code></pre> <p>TR-69 CPE Identifier.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.version","title":"version  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>version: str\n</code></pre> <p>CPE software version.</p> <p>This will reload after each flash.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.wifi","title":"wifi  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>wifi: WiFiHal\n</code></pre> <p>Wifi instance CPE Software.</p>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.add_info_to_file","title":"add_info_to_file  <code>abstractmethod</code>","text":"<pre><code>add_info_to_file(to_add: str, fname: str) -&gt; None\n</code></pre> <p>Add data into a file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>contents/data to be added to a file.</p> required <code>str</code> <p>filename with absolute path</p> required Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef add_info_to_file(self, to_add: str, fname: str) -&gt; None:\n    \"\"\"Add data into a file.\n\n    :param to_add: contents/data to be added to a file.\n    :type to_add: str\n    :param fname: filename with absolute path\n    :type fname: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.add_info_to_file(to_add)","title":"<code>to_add</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.add_info_to_file(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.enable_logs","title":"enable_logs  <code>abstractmethod</code>","text":"<pre><code>enable_logs(component: str, flag: str = 'enable') -&gt; None\n</code></pre> <p>Enable logs for given component.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>component name</p> required <code>str</code> <p>flag name, Default: \"enable\"</p> <code>'enable'</code> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef enable_logs(self, component: str, flag: str = \"enable\") -&gt; None:\n    \"\"\"Enable logs for given component.\n\n    :param component: component name\n    :param flag: flag name, Default: \"enable\"\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.enable_logs(component)","title":"<code>component</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.enable_logs(flag)","title":"<code>flag</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.factory_reset","title":"factory_reset  <code>abstractmethod</code>","text":"<pre><code>factory_reset(method: str | None = None) -&gt; bool\n</code></pre> <p>Perform factory reset CPE via given method.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>factory reset method. Default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True on successful factory reset, False otherwise</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef factory_reset(self, method: str | None = None) -&gt; bool:\n    \"\"\"Perform factory reset CPE via given method.\n\n    :param method: factory reset method. Default None.\n    :type method: str | None\n    :return: True on successful factory reset, False otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.factory_reset(method)","title":"<code>method</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.finalize_boot","title":"finalize_boot  <code>abstractmethod</code>","text":"<pre><code>finalize_boot() -&gt; bool\n</code></pre> <p>Validate board settings post boot.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True on successful validation</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef finalize_boot(self) -&gt; bool:\n    \"\"\"Validate board settings post boot.\n\n    :return: True on successful validation\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_board_logs","title":"get_board_logs  <code>abstractmethod</code>","text":"<pre><code>get_board_logs(timeout: int = 300) -&gt; str\n</code></pre> <p>Return board console logs for given timeout.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>log capture time in seconds</p> <code>300</code> <p>Returns:</p> Type Description <code>str</code> <p>captured logs</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_board_logs(self, timeout: int = 300) -&gt; str:\n    \"\"\"Return board console logs for given timeout.\n\n    :param timeout: log capture time in seconds\n    :return: captured logs\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_board_logs(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_boottime_log","title":"get_boottime_log  <code>abstractmethod</code>","text":"<pre><code>get_boottime_log() -&gt; list[str]\n</code></pre> <p>Return the boot time log from the board.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>boot time log</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_boottime_log(self) -&gt; list[str]:\n    \"\"\"Return the boot time log from the board.\n\n    :return: boot time log\n    :rtype: list[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_date","title":"get_date  <code>abstractmethod</code>","text":"<pre><code>get_date() -&gt; str | None\n</code></pre> <p>Get the system date and time.</p> <p>.. code-block:: python</p> <pre><code># example output\ndonderdag, mei 23, 2024 14:23:39\n</code></pre> <p>Returns:</p> Type Description <code>str | None</code> <p>date</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_date(self) -&gt; str | None:\n    \"\"\"Get the system date and time.\n\n    .. code-block:: python\n\n        # example output\n        donderdag, mei 23, 2024 14:23:39\n\n\n    :return: date\n    :rtype: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_file_content","title":"get_file_content  <code>abstractmethod</code>","text":"<pre><code>get_file_content(fname: str, timeout: int) -&gt; str\n</code></pre> <p>Get the content of the given file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required <code>int</code> <p>timeout value to fetch the file content</p> required <p>Returns:</p> Type Description <code>str</code> <p>contents of the file</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_file_content(self, fname: str, timeout: int) -&gt; str:\n    \"\"\"Get the content of the given file.\n\n    :param fname: name of the file with absolute path\n    :type fname: str\n    :param timeout: timeout value to fetch the file content\n    :type timeout: int\n    :return: contents of the file\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_file_content(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_file_content(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_ipv4addr","title":"get_interface_ipv4addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv4addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface IPv4 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv4addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface IPv4 address.\n\n    :param interface: interface name\n    :return: IPv4 address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_ipv4addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_ipv6addr","title":"get_interface_ipv6addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface IPv6 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface IPv6 address.\n\n    :param interface: interface name\n    :return: IPv6 address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_link_local_ipv6_addr","title":"get_interface_link_local_ipv6_addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_link_local_ipv6_addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface link local IPv6 address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>link local IPv6 address</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_link_local_ipv6_addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface link local IPv6 address.\n\n    :param interface: interface name\n    :return: link local IPv6 address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_link_local_ipv6_addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_mac_addr","title":"get_interface_mac_addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_mac_addr(interface: str) -&gt; str\n</code></pre> <p>Return given interface mac address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>mac address of the given interface</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_mac_addr(self, interface: str) -&gt; str:\n    \"\"\"Return given interface mac address.\n\n    :param interface: interface name\n    :return: mac address of the given interface\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_mac_addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_mtu_size","title":"get_interface_mtu_size  <code>abstractmethod</code>","text":"<pre><code>get_interface_mtu_size(interface: str) -&gt; int\n</code></pre> <p>Get the MTU size of the interface in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>int</code> <p>size of the MTU in bytes</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_interface_mtu_size(self, interface: str) -&gt; int:\n    \"\"\"Get the MTU size of the interface in bytes.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: size of the MTU in bytes\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_interface_mtu_size(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_load_avg","title":"get_load_avg  <code>abstractmethod</code>","text":"<pre><code>get_load_avg() -&gt; float\n</code></pre> <p>Return current load average of the CPE.</p> <p>Returns:</p> Type Description <code>float</code> <p>current load average</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_load_avg(self) -&gt; float:\n    \"\"\"Return current load average of the CPE.\n\n    :return: current load average\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_memory_utilization","title":"get_memory_utilization  <code>abstractmethod</code>","text":"<pre><code>get_memory_utilization() -&gt; dict[str, int]\n</code></pre> <p>Return the current memory utilization of the CPE.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>current memory utilization</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_memory_utilization(self) -&gt; dict[str, int]:\n    \"\"\"Return the current memory utilization of the CPE.\n\n    :return: current memory utilization\n    :rtype: dict[str, int]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_ntp_sync_status","title":"get_ntp_sync_status  <code>abstractmethod</code>","text":"<pre><code>get_ntp_sync_status() -&gt; list[dict[str, Any]]\n</code></pre> <p>Execute ntpq command to get the synchronization status.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>parsed output of ntpq command</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_ntp_sync_status(\n    self,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute ntpq command to get the synchronization status.\n\n    :return: parsed output of ntpq command\n    :rtype: list[dict[str, Any]]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_provision_mode","title":"get_provision_mode  <code>abstractmethod</code>","text":"<pre><code>get_provision_mode() -&gt; str\n</code></pre> <p>Return provision mode.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_provision_mode(self) -&gt; str:\n    \"\"\"Return provision mode.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_running_processes","title":"get_running_processes  <code>abstractmethod</code>","text":"<pre><code>get_running_processes(ps_options: str = '-A') -&gt; Iterable[ParsedPSOutput]\n</code></pre> <p>Return the currently running processes in the CPE via the <code>ps</code> command.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The options to be passed to the ps command, defaults to \"-A\"</p> <code>'-A'</code> <p>Returns:</p> Type Description <code>Iterable[ParsedPSOutput]</code> <p>the currently running processes as a parsed tuple of dictionaries</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_running_processes(\n    self,\n    ps_options: str = \"-A\",\n) -&gt; Iterable[ParsedPSOutput]:\n    \"\"\"Return the currently running processes in the CPE via the `ps` command.\n\n    :param ps_options: The options to be passed to the ps command, defaults to \"-A\"\n    :type ps_options: str\n    :return: the currently running processes as a parsed tuple of dictionaries\n    :rtype: Iterable[ParsedPSOutput]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_running_processes(ps_options)","title":"<code>ps_options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_seconds_uptime","title":"get_seconds_uptime  <code>abstractmethod</code>","text":"<pre><code>get_seconds_uptime() -&gt; float\n</code></pre> <p>Return uptime in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>uptime in seconds</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_seconds_uptime(self) -&gt; float:\n    \"\"\"Return uptime in seconds.\n\n    :return: uptime in seconds\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.get_tr069_log","title":"get_tr069_log  <code>abstractmethod</code>","text":"<pre><code>get_tr069_log() -&gt; list[str]\n</code></pre> <p>Return the TR-069 log from the board.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>TR-069 logs</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef get_tr069_log(self) -&gt; list[str]:\n    \"\"\"Return the TR-069 log from the board.\n\n    :return: TR-069 logs\n    :rtype: list[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.is_link_up","title":"is_link_up  <code>abstractmethod</code>","text":"<pre><code>is_link_up(interface: str, pattern: str = 'BROADCAST,MULTICAST,UP') -&gt; bool\n</code></pre> <p>Return the link status.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface state</p> required <code>str</code> <p>interface name, defaults to \"BROADCAST,MULTICAST,UP\"</p> <code>'BROADCAST,MULTICAST,UP'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the link is up</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_link_up(\n    self,\n    interface: str,\n    pattern: str = \"BROADCAST,MULTICAST,UP\",\n) -&gt; bool:\n    \"\"\"Return the link status.\n\n    :param interface: interface state\n    :type interface: str\n    :param pattern: interface name, defaults to \"BROADCAST,MULTICAST,UP\"\n    :type pattern: str\n    :return: True if the link is up\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.is_link_up(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.is_link_up(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.is_online","title":"is_online  <code>abstractmethod</code>","text":"<pre><code>is_online() -&gt; bool\n</code></pre> <p>Is CPE online.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the CPE is online, False otherwise</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_online(self) -&gt; bool:\n    \"\"\"Is CPE online.\n\n    :return: True if the CPE is online, False otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.is_production","title":"is_production  <code>abstractmethod</code>","text":"<pre><code>is_production() -&gt; bool\n</code></pre> <p>Is production software.</p> <p>Production software has limited capabilities.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_production(self) -&gt; bool:\n    \"\"\"Is production software.\n\n    Production software has limited capabilities.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.is_tr069_connected","title":"is_tr069_connected  <code>abstractmethod</code>","text":"<pre><code>is_tr069_connected() -&gt; bool\n</code></pre> <p>Is TR-69 agent is connected.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True is TR-69 is connected, otherwise False</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef is_tr069_connected(self) -&gt; bool:\n    \"\"\"Is TR-69 agent is connected.\n\n    :return: True is TR-69 is connected, otherwise False\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.kill_process_immediately","title":"kill_process_immediately  <code>abstractmethod</code>","text":"<pre><code>kill_process_immediately(pid: int) -&gt; None\n</code></pre> <p>Kills any process based on the provided process ID.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>process number</p> required Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef kill_process_immediately(self, pid: int) -&gt; None:\n    \"\"\"Kills any process based on the provided process ID.\n\n    :param pid: process number\n    :type pid: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.kill_process_immediately(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.read_event_logs","title":"read_event_logs  <code>abstractmethod</code>","text":"<pre><code>read_event_logs() -&gt; JSONDictType | list[JSONDictType] | Iterator[JSONDictType]\n</code></pre> <p>Return the event logs from the <code>logread</code> command.</p> <p>Returns:</p> Type Description <code>JSONDictType | list[JSONDictType] | Iterator[JSONDictType]</code> <p>the event logs from the <code>logread</code> command.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef read_event_logs(\n    self,\n) -&gt; JSONDictType | list[JSONDictType] | Iterator[JSONDictType]:\n    \"\"\"Return the event logs from the `logread` command.\n\n    :return: the event logs from the `logread` command.\n    :rtype: JSONDictType | list[JSONDictType] | Iterator[JSONDictType]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.reset","title":"reset  <code>abstractmethod</code>","text":"<pre><code>reset(method: str | None = None) -&gt; None\n</code></pre> <p>Perform reset via given method.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>reset method. Default None</p> <code>None</code> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef reset(self, method: str | None = None) -&gt; None:\n    \"\"\"Perform reset via given method.\n\n    :param method: reset method. Default None\n    :type method: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.reset(method)","title":"<code>method</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.set_date","title":"set_date  <code>abstractmethod</code>","text":"<pre><code>set_date(date_string: str) -&gt; bool\n</code></pre> <p>Set the device's date and time.</p> <p>It should execute <code>date -s {date_string}</code> on the device's console.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>value to be changed</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if set is successful</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef set_date(self, date_string: str) -&gt; bool:\n    \"\"\"Set the device's date and time.\n\n    It should execute `date -s {date_string}` on the device's console.\n\n    :param date_string: value to be changed\n    :type date_string: str\n    :return: True if set is successful\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.set_date(date_string)","title":"<code>date_string</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.verify_cpe_is_booting","title":"verify_cpe_is_booting  <code>abstractmethod</code>","text":"<pre><code>verify_cpe_is_booting() -&gt; None\n</code></pre> <p>Verify CPE is booting.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef verify_cpe_is_booting(self) -&gt; None:\n    \"\"\"Verify CPE is booting.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.cpe.cpe_sw.CPESW.wait_for_boot","title":"wait_for_boot  <code>abstractmethod</code>","text":"<pre><code>wait_for_boot() -&gt; None\n</code></pre> <p>Wait for CPE to boot.</p> Source code in <code>boardfarm3/templates/cpe/cpe_sw.py</code> <pre><code>@abstractmethod\ndef wait_for_boot(self) -&gt; None:\n    \"\"\"Wait for CPE to boot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan","title":"lan","text":"<p>Boardfarm LAN device template.</p> <p>Classes:</p> Name Description <code>LAN</code> <p>Boardfarm LAN device template.</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN","title":"LAN","text":"<p>Boardfarm LAN device template.</p> <p>Methods:</p> Name Description <code>add_hosts_entry</code> <p>Add entry in hosts file.</p> <code>create_upnp_rule</code> <p>Create UPnP rule on the device.</p> <code>curl</code> <p>Perform curl action to Web service.</p> <code>del_default_route</code> <p>Remove the default gateway.</p> <code>delete_arp_table_entry</code> <p>Delete ARP table output.</p> <code>delete_file</code> <p>Delete the file from the device.</p> <code>delete_hosts_entry</code> <p>Delete entry in hosts file.</p> <code>delete_upnp_rule</code> <p>Delete UPnP rule on the device.</p> <code>disable_ipv6</code> <p>Disable IPv6 on the connected client interface.</p> <code>dns_lookup</code> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <code>enable_ipv6</code> <p>Enable IPv6 on the connected client interface.</p> <code>flush_arp_cache</code> <p>Flushes arp cache entries.</p> <code>get_arp_table</code> <p>Fetch ARP table output.</p> <code>get_date</code> <p>Get the system date and time.</p> <code>get_default_gateway</code> <p>Get the default gateway from IP route output.</p> <code>get_hostname</code> <p>Get the hostname of the device.</p> <code>get_interface_ipv4addr</code> <p>Get IPv4 address of interface.</p> <code>get_interface_ipv6addr</code> <p>Get IPv6 address of the interface.</p> <code>get_interface_link_local_ipv6addr</code> <p>Get IPv6 link local address of the interface.</p> <code>get_interface_macaddr</code> <p>Get the interface MAC address.</p> <code>get_interface_mask</code> <p>Get the subnet mask of the interface.</p> <code>get_interface_mtu_size</code> <p>Get the MTU size of the interface in bytes.</p> <code>get_iperf_logs</code> <p>Read the file output for traffic flow.</p> <code>get_process_id</code> <p>Return the process id to the device.</p> <code>hping_flood</code> <p>Validate SYN, UDP and ICMP flood operation.</p> <code>http_get</code> <p>Peform HTTP Get and return parsed result.</p> <code>is_link_up</code> <p>Return the link status.</p> <code>kill_process</code> <p>Kill the running process based on the process id.</p> <code>netcat</code> <p>Run netcat command to initiate brute force.</p> <code>nmap</code> <p>Perform nmap operation on linux device.</p> <code>ping</code> <p>Ping remote host.</p> <code>release_dhcp</code> <p>Release IPv4 of the specified interface.</p> <code>release_ipv6</code> <p>Release IPv6 of the specified interface.</p> <code>renew_dhcp</code> <p>Renew IPv4 of the specified interface by restart of the IPv4 dhclient.</p> <code>renew_ipv6</code> <p>Renew IPv6 of the specified interface.</p> <code>scp_device_file_to_local</code> <p>Copy a local file from a server using SCP.</p> <code>send_mldv2_report</code> <p>Send an MLDv2 report with desired multicast record.</p> <code>set_date</code> <p>Set the device's date and time.</p> <code>set_default_gw</code> <p>Set given IP address as default gateway address for given interface.</p> <code>set_link_state</code> <p>Set link state.</p> <code>set_static_ip</code> <p>Set given static IP for the LAN.</p> <code>start_http_service</code> <p>Start HTTP service on given port number.</p> <code>start_ipv4_lan_client</code> <p>Restart IPv4 dhclient to obtain IP.</p> <code>start_ipv6_lan_client</code> <p>Restart IPv6 dhclient to obtain IP.</p> <code>start_nping</code> <p>Perform nping.</p> <code>start_tcpdump</code> <p>Start tcpdump capture on given interface.</p> <code>start_traffic_receiver</code> <p>Start the server on a linux device to generate traffic using iperf3.</p> <code>start_traffic_sender</code> <p>Start traffic on a linux client using iperf3.</p> <code>stop_http_service</code> <p>Stop HTTP service running on given port.</p> <code>stop_nping</code> <p>Stop nping process running in background.</p> <code>stop_tcpdump</code> <p>Stop tcpdump capture.</p> <code>stop_traffic</code> <p>Stop the iPerf3 process for a specific PID or killall.</p> <code>tcpdump_capture</code> <p>Capture packets from specified interface.</p> <code>traceroute</code> <p>Return output of traceroute command.</p> <code>tshark_read_pcap</code> <p>Read packet captures from an existing file.</p> <p>Attributes:</p> Name Type Description <code>console</code> <code>BoardfarmPexpect</code> <p>Returns LAN console.</p> <code>firewall</code> <code>IptablesFirewall</code> <p>Returns Firewall iptables instance.</p> <code>http_proxy</code> <code>str</code> <p>SOCKS5 Dante proxy address, e.g http://{proxy_ip}:{proxy_port}/.</p> <code>iface_dut</code> <code>str</code> <p>Name of the interface that is connected to DUT.</p> <code>ipv4_addr</code> <code>str</code> <p>Return the IPv4 address on IFACE facing DUT.</p> <code>ipv6_addr</code> <code>str</code> <p>Return the IPv6 address on IFACE facing DUT.</p> <code>lan_gateway</code> <code>str</code> <p>Gateway address.</p> <code>multicast</code> <code>Multicast</code> <p>Return multicast component instance.</p> <code>nslookup</code> <code>NSLookup</code> <p>Returns NSLookup utility instance.</p> <code>nw_utility</code> <code>NetworkUtility</code> <p>Returns Network utility instance.</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.console","title":"console  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>console: BoardfarmPexpect\n</code></pre> <p>Returns LAN console.</p> <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.firewall","title":"firewall  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>firewall: IptablesFirewall\n</code></pre> <p>Returns Firewall iptables instance.</p> <p>Returns:</p> Type Description <code>IptablesFirewall</code> <p>firewall iptables instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.http_proxy","title":"http_proxy  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>http_proxy: str\n</code></pre> <p>SOCKS5 Dante proxy address, e.g http://{proxy_ip}:{proxy_port}/.</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.iface_dut","title":"iface_dut  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>iface_dut: str\n</code></pre> <p>Name of the interface that is connected to DUT.</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ipv4_addr","title":"ipv4_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv4_addr: str\n</code></pre> <p>Return the IPv4 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ipv6_addr","title":"ipv6_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv6_addr: str\n</code></pre> <p>Return the IPv6 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.lan_gateway","title":"lan_gateway  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_gateway: str\n</code></pre> <p>Gateway address.</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.multicast","title":"multicast  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>multicast: Multicast\n</code></pre> <p>Return multicast component instance.</p> <p>Returns:</p> Type Description <code>Multicast</code> <p>multicast component instance</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nslookup","title":"nslookup  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nslookup: NSLookup\n</code></pre> <p>Returns NSLookup utility instance.</p> <p>Returns:</p> Type Description <code>NSLookup</code> <p>NSLookup utility instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nw_utility","title":"nw_utility  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nw_utility: NetworkUtility\n</code></pre> <p>Returns Network utility instance.</p> <p>Returns:</p> Type Description <code>NetworkUtility</code> <p>network utiluty instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.add_hosts_entry","title":"add_hosts_entry  <code>abstractmethod</code>","text":"<pre><code>add_hosts_entry(ip: str, host_name: str) -&gt; None\n</code></pre> <p>Add entry in hosts file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>host ip addr</p> required <code>str</code> <p>host name to be added</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef add_hosts_entry(self, ip: str, host_name: str) -&gt; None:\n    \"\"\"Add entry in hosts file.\n\n    :param ip: host ip addr\n    :type ip: str\n    :param host_name: host name to be added\n    :type host_name: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.add_hosts_entry(ip)","title":"<code>ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.add_hosts_entry(host_name)","title":"<code>host_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.create_upnp_rule","title":"create_upnp_rule  <code>abstractmethod</code>","text":"<pre><code>create_upnp_rule(int_port: str, ext_port: str, protocol: str, url: str) -&gt; str\n</code></pre> <p>Create UPnP rule on the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>internal port for UPnP</p> required <code>str</code> <p>external port for UPnP</p> required <code>str</code> <p>protocol to be used</p> required <code>str</code> <p>url to be used</p> required <p>Returns:</p> Type Description <code>str</code> <p>output of upnpc add port command</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef create_upnp_rule(\n    self,\n    int_port: str,\n    ext_port: str,\n    protocol: str,\n    url: str,\n) -&gt; str:\n    \"\"\"Create UPnP rule on the device.\n\n    :param int_port: internal port for UPnP\n    :type int_port: str\n    :param ext_port: external port for UPnP\n    :type ext_port: str\n    :param protocol: protocol to be used\n    :type protocol: str\n    :param url: url to be used\n    :type url: str\n    :return: output of upnpc add port command\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.create_upnp_rule(int_port)","title":"<code>int_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.create_upnp_rule(ext_port)","title":"<code>ext_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.create_upnp_rule(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.create_upnp_rule(url)","title":"<code>url</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.curl","title":"curl  <code>abstractmethod</code>","text":"<pre><code>curl(\n    url: str | IPv4Address,\n    protocol: str,\n    port: str | int | None = None,\n    options: str = \"\",\n) -&gt; bool\n</code></pre> <p>Perform curl action to Web service.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <p>Web service address</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if curl action is successful</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef curl(\n    self,\n    url: str | IPv4Address,\n    protocol: str,\n    port: str | int | None = None,\n    options: str = \"\",\n) -&gt; bool:\n    \"\"\"Perform curl action to Web service.\n\n    :param url : Web service address\n    :type url : str\n    :param protocol : Web Protocol (HTTP or HTTPS)\n    :type protocol : str\n    :param port : port number of server\n    :type port : str | int | None\n    :param options : Additional curl options\n    :type options : str\n    :return: True if curl action is successful\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.curl()","title":"","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.del_default_route","title":"del_default_route  <code>abstractmethod</code>","text":"<pre><code>del_default_route(interface: str | None = None) -&gt; None\n</code></pre> <p>Remove the default gateway.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>interface name, default to None</p> <code>None</code> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef del_default_route(self, interface: str | None = None) -&gt; None:\n    \"\"\"Remove the default gateway.\n\n    :param interface: interface name, default to None\n    :type interface: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.del_default_route(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_arp_table_entry","title":"delete_arp_table_entry  <code>abstractmethod</code>","text":"<pre><code>delete_arp_table_entry(ip: str, intf: str) -&gt; None\n</code></pre> <p>Delete ARP table output.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip of the host entry to be deleted</p> required <code>str</code> <p>interface for which the entry needs to be deleted</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef delete_arp_table_entry(self, ip: str, intf: str) -&gt; None:\n    \"\"\"Delete ARP table output.\n\n    :param ip: ip of the host entry to be deleted\n    :type ip: str\n    :param intf: interface for which the entry needs to be deleted\n    :type intf: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_arp_table_entry(ip)","title":"<code>ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_arp_table_entry(intf)","title":"<code>intf</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_file","title":"delete_file  <code>abstractmethod</code>","text":"<pre><code>delete_file(filename: str) -&gt; None\n</code></pre> <p>Delete the file from the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef delete_file(self, filename: str) -&gt; None:\n    \"\"\"Delete the file from the device.\n\n    :param filename: name of the file with absolute path\n    :type filename: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_file(filename)","title":"<code>filename</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_hosts_entry","title":"delete_hosts_entry  <code>abstractmethod</code>","text":"<pre><code>delete_hosts_entry(host_name: str, ip: str) -&gt; None\n</code></pre> <p>Delete entry in hosts file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>host name to be deleted</p> required <code>str</code> <p>host ip addr</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef delete_hosts_entry(self, host_name: str, ip: str) -&gt; None:\n    \"\"\"Delete entry in hosts file.\n\n    :param host_name: host name to be deleted\n    :type host_name: str\n    :param ip: host ip addr\n    :type ip: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_hosts_entry(host_name)","title":"<code>host_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_hosts_entry(ip)","title":"<code>ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_upnp_rule","title":"delete_upnp_rule  <code>abstractmethod</code>","text":"<pre><code>delete_upnp_rule(ext_port: str, protocol: str, url: str) -&gt; str\n</code></pre> <p>Delete UPnP rule on the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>external port for UPnP</p> required <code>str</code> <p>protocol to be used</p> required <code>str</code> <p>url to be used</p> required <p>Returns:</p> Type Description <code>str</code> <p>output of upnpc delete port command</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef delete_upnp_rule(self, ext_port: str, protocol: str, url: str) -&gt; str:\n    \"\"\"Delete UPnP rule on the device.\n\n    :param ext_port: external port for UPnP\n    :type ext_port: str\n    :param protocol: protocol to be used\n    :type protocol: str\n    :param url: url to be used\n    :type url: str\n    :return: output of upnpc delete port command\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_upnp_rule(ext_port)","title":"<code>ext_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_upnp_rule(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.delete_upnp_rule(url)","title":"<code>url</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.disable_ipv6","title":"disable_ipv6  <code>abstractmethod</code>","text":"<pre><code>disable_ipv6() -&gt; None\n</code></pre> <p>Disable IPv6 on the connected client interface.</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef disable_ipv6(self) -&gt; None:\n    \"\"\"Disable IPv6 on the connected client interface.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.dns_lookup","title":"dns_lookup  <code>abstractmethod</code>","text":"<pre><code>dns_lookup(domain_name: str, record_type: str, opts: str = '') -&gt; list[dict[str, Any]]\n</code></pre> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>domain name which needs lookup</p> required <code>str</code> <p>AAAA for IPv6 else A</p> required <code>str</code> <p>options to be provided to dig command, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>List[dict[str, Any]]</code> <p>parsed dig command ouput</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef dns_lookup(\n    self, domain_name: str, record_type: str, opts: str = \"\"\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Perform ``dig`` command in the devices to resolve DNS.\n\n    :param domain_name: domain name which needs lookup\n    :type domain_name: str\n    :param record_type: AAAA for IPv6 else A\n    :type record_type: str\n    :param opts: options to be provided to dig command, defaults to \"\"\n    :type opts: str\n    :return: parsed dig command ouput\n    :rtype: List[dict[str, Any]]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.dns_lookup(domain_name)","title":"<code>domain_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.dns_lookup(record_type)","title":"<code>record_type</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.dns_lookup(opts)","title":"<code>opts</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.enable_ipv6","title":"enable_ipv6  <code>abstractmethod</code>","text":"<pre><code>enable_ipv6() -&gt; None\n</code></pre> <p>Enable IPv6 on the connected client interface.</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef enable_ipv6(self) -&gt; None:\n    \"\"\"Enable IPv6 on the connected client interface.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.flush_arp_cache","title":"flush_arp_cache  <code>abstractmethod</code>","text":"<pre><code>flush_arp_cache() -&gt; None\n</code></pre> <p>Flushes arp cache entries.</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef flush_arp_cache(self) -&gt; None:\n    \"\"\"Flushes arp cache entries.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_arp_table","title":"get_arp_table  <code>abstractmethod</code>","text":"<pre><code>get_arp_table() -&gt; str\n</code></pre> <p>Fetch ARP table output.</p> <p>Returns:</p> Type Description <code>str</code> <p>output of arp command</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_arp_table(self) -&gt; str:\n    \"\"\"Fetch ARP table output.\n\n    :return: output of arp command\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_date","title":"get_date  <code>abstractmethod</code>","text":"<pre><code>get_date() -&gt; str | None\n</code></pre> <p>Get the system date and time.</p> <p>.. code-block:: python</p> <pre><code># example output\ndonderdag, mei 23, 2024 14:23:39\n</code></pre> <p>Returns:</p> Type Description <code>str | None</code> <p>date</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_date(self) -&gt; str | None:\n    \"\"\"Get the system date and time.\n\n    .. code-block:: python\n\n        # example output\n        donderdag, mei 23, 2024 14:23:39\n\n\n    :return: date\n    :rtype: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_default_gateway","title":"get_default_gateway  <code>abstractmethod</code>","text":"<pre><code>get_default_gateway() -&gt; IPv4Address\n</code></pre> <p>Get the default gateway from IP route output.</p> <p>Returns:</p> Type Description <code>IPv4Address</code> <p>IPv4 of the default gateway</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_default_gateway(self) -&gt; IPv4Address:\n    \"\"\"Get the default gateway from IP route output.\n\n    :return: IPv4 of the default gateway\n    :rtype: IPv4Address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_hostname","title":"get_hostname  <code>abstractmethod</code>","text":"<pre><code>get_hostname() -&gt; str\n</code></pre> <p>Get the hostname of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>hostname of the device</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_hostname(self) -&gt; str:\n    \"\"\"Get the hostname of the device.\n\n    :return: hostname of the device\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_ipv4addr","title":"get_interface_ipv4addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv4addr(interface: str) -&gt; str\n</code></pre> <p>Get IPv4 address of interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv4 can not be found</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv4addr(self, interface: str) -&gt; str:\n    \"\"\"Get IPv4 address of interface.\n\n    :param interface: interface name\n    :type interface: str\n    :return: IPv4 address of the interface\n    :rtype: str\n    :raises BoardfarmException: in case IPv4 can not be found\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_ipv4addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_ipv6addr","title":"get_interface_ipv6addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Get IPv6 address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name to get the link local</p> required <p>Returns:</p> Type Description <code>str</code> <p>Global IPv6 address of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv6 can not be found</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Get IPv6 address of the interface.\n\n    :param interface: interface name to get the link local\n    :type interface: str\n    :return: Global IPv6 address of the interface\n    :rtype: str\n    :raises BoardfarmException: in case IPv6 can not be found\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_link_local_ipv6addr","title":"get_interface_link_local_ipv6addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_link_local_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Get IPv6 link local address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>Link local ipv6 address of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case ipv6 can not be found</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_interface_link_local_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Get IPv6 link local address of the interface.\n\n    :param interface: interface name\n    :type interface: str\n    :return: Link local ipv6 address of the interface\n    :rtype: str\n    :raises BoardfarmException: in case ipv6 can not be found\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_link_local_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_macaddr","title":"get_interface_macaddr  <code>abstractmethod</code>","text":"<pre><code>get_interface_macaddr(interface: str) -&gt; str\n</code></pre> <p>Get the interface MAC address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>MAC address of the interface</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_interface_macaddr(self, interface: str) -&gt; str:\n    \"\"\"Get the interface MAC address.\n\n    :param interface: interface name\n    :type interface: str\n    :return: MAC address of the interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_macaddr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_mask","title":"get_interface_mask  <code>abstractmethod</code>","text":"<pre><code>get_interface_mask(interface: str) -&gt; str\n</code></pre> <p>Get the subnet mask of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>str</code> <p>subnet mask of interface</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_interface_mask(self, interface: str) -&gt; str:\n    \"\"\"Get the subnet mask of the interface.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: subnet mask of interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_mask(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_mtu_size","title":"get_interface_mtu_size  <code>abstractmethod</code>","text":"<pre><code>get_interface_mtu_size(interface: str) -&gt; int\n</code></pre> <p>Get the MTU size of the interface in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>int</code> <p>size of the MTU in bytes</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_interface_mtu_size(self, interface: str) -&gt; int:\n    \"\"\"Get the MTU size of the interface in bytes.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: size of the MTU in bytes\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_interface_mtu_size(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_iperf_logs","title":"get_iperf_logs  <code>abstractmethod</code>","text":"<pre><code>get_iperf_logs(log_file: str) -&gt; str\n</code></pre> <p>Read the file output for traffic flow.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>iperf log file path</p> required <p>Returns:</p> Type Description <code>str</code> <p>traffic flow logs</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_iperf_logs(self, log_file: str) -&gt; str:\n    \"\"\"Read the file output for traffic flow.\n\n    :param log_file: iperf log file path\n    :type log_file: str\n    :return: traffic flow logs\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_iperf_logs(log_file)","title":"<code>log_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_process_id","title":"get_process_id  <code>abstractmethod</code>","text":"<pre><code>get_process_id(process_name: str) -&gt; list[str] | None\n</code></pre> <p>Return the process id to the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the process</p> required <p>Returns:</p> Type Description <code>list[str] | None</code> <p>process id if the process exist, else None</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef get_process_id(self, process_name: str) -&gt; list[str] | None:\n    \"\"\"Return the process id to the device.\n\n    :param process_name: name of the process\n    :type process_name: str\n    :return: process id if the process exist, else None\n    :rtype: list[str] | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.get_process_id(process_name)","title":"<code>process_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.hping_flood","title":"hping_flood  <code>abstractmethod</code>","text":"<pre><code>hping_flood(\n    protocol: str,\n    target: str,\n    packet_count: str,\n    extra_args: str | None = None,\n    pkt_interval: str = \"\",\n) -&gt; str\n</code></pre> <p>Validate SYN, UDP and ICMP flood operation.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>mode, for ex 'S': syn-flood '1': ping-flood (icmp) '2': udp</p> required <code>str</code> <p>target IP addr</p> required <code>str</code> <p>number of packets to be transmitted.</p> required <code>str | None</code> <p>extra arguments to be passed, defaults to None</p> <code>None</code> <code>str</code> <p>wait for X microseconds before sending next packet uX, defaults to \"\", uX for X microseconds, for example -i u1000</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef hping_flood(\n    self,\n    protocol: str,\n    target: str,\n    packet_count: str,\n    extra_args: str | None = None,\n    pkt_interval: str = \"\",\n) -&gt; str:\n    \"\"\"Validate SYN, UDP and ICMP flood operation.\n\n    :param protocol: mode, for ex 'S': syn-flood '1': ping-flood (icmp) '2': udp\n    :type protocol: str\n    :param target: target IP addr\n    :type target: str\n    :param packet_count: number of packets to be transmitted.\n    :type packet_count: str\n    :param extra_args: extra arguments to be passed, defaults to None\n    :type extra_args: str\n    :param pkt_interval: wait for X microseconds before sending next packet uX,\n        defaults to \"\", uX for X microseconds, for example -i u1000\n    :type pkt_interval: str\n    :return: command output\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.hping_flood(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.hping_flood(target)","title":"<code>target</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.hping_flood(packet_count)","title":"<code>packet_count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.hping_flood(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.hping_flood(pkt_interval)","title":"<code>pkt_interval</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.http_get","title":"http_get  <code>abstractmethod</code>","text":"<pre><code>http_get(url: str, timeout: int, options: str) -&gt; HTTPResult\n</code></pre> <p>Peform HTTP Get and return parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>URL to get the response</p> required <code>int</code> <p>connection timeout for the curl command in seconds</p> required <code>str</code> <p>additional curl options</p> required <p>Returns:</p> Type Description <code>HTTPResult</code> <p>parsed HTTP response</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef http_get(self, url: str, timeout: int, options: str) -&gt; HTTPResult:\n    \"\"\"Peform HTTP Get and return parsed result.\n\n    :param url: URL to get the response\n    :type url: str\n    :param timeout: connection timeout for the curl command in seconds\n    :type timeout: int\n    :param options: additional curl options\n    :type options: str\n    :return: parsed HTTP response\n    :rtype: HTTPResult\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.http_get(url)","title":"<code>url</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.http_get(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.http_get(options)","title":"<code>options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.is_link_up","title":"is_link_up  <code>abstractmethod</code>","text":"<pre><code>is_link_up(interface: str, pattern: str = 'BROADCAST,MULTICAST,UP') -&gt; bool\n</code></pre> <p>Return the link status.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name, defaults to \"BROADCAST,MULTICAST,UP\"</p> required <code>str</code> <p>interface state</p> <code>'BROADCAST,MULTICAST,UP'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the link is up</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef is_link_up(\n    self,\n    interface: str,\n    pattern: str = \"BROADCAST,MULTICAST,UP\",\n) -&gt; bool:\n    \"\"\"Return the link status.\n\n    :param interface: interface name, defaults to \"BROADCAST,MULTICAST,UP\"\n    :type interface: str\n    :param pattern: interface state\n    :type pattern: str\n    :return: True if the link is up\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.is_link_up(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.is_link_up(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.kill_process","title":"kill_process  <code>abstractmethod</code>","text":"<pre><code>kill_process(pid: int, signal: int) -&gt; None\n</code></pre> <p>Kill the running process based on the process id.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>process id</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef kill_process(self, pid: int, signal: int) -&gt; None:\n    \"\"\"Kill the running process based on the process id.\n\n    :param pid: process id\n    :type pid: int\n    :type signal: signal number to terminate the process\n    :type signal: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.kill_process(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.netcat","title":"netcat  <code>abstractmethod</code>","text":"<pre><code>netcat(host_ip: str, port: str, additional_args: str) -&gt; None\n</code></pre> <p>Run netcat command to initiate brute force.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>host ip address</p> required <code>str</code> <p>port number of the host</p> required <code>str</code> <p>additional args to be provided with netcat command</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef netcat(self, host_ip: str, port: str, additional_args: str) -&gt; None:\n    \"\"\"Run netcat command to initiate brute force.\n\n    :param host_ip: host ip address\n    :type host_ip: str\n    :param port: port number of the host\n    :type port: str\n    :param additional_args: additional args to be provided with netcat command\n    :type additional_args: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.netcat(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.netcat(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.netcat(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap","title":"nmap  <code>abstractmethod</code>","text":"<pre><code>nmap(\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict\n</code></pre> <p>Perform nmap operation on linux device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>IP address on which nmap is performed</p> required <code>str</code> <p>type of IP eg: IPv4/IPv6</p> required <code>str | int | None</code> <p>destination port on IP, defaults to None</p> <code>None</code> <code>str | None</code> <p>specific protocol to follow eg: tcp(-sT)/udp(-sU), defaults to None</p> <code>None</code> <code>int | None</code> <p>number of port scan probe retransmissions, defaults to None</p> <code>None</code> <code>int | None</code> <p>send packets no slower than per second, defaults to None</p> <code>None</code> <code>str | None</code> <p>other options for a nmap command, defaults to None</p> <code>None</code> <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict</code> <p>response of nmap command in XML/dict format</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>if IP type is invalid</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef nmap(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict:\n    \"\"\"Perform nmap operation on linux device.\n\n    :param ipaddr: IP address on which nmap is performed\n    :type ipaddr: str\n    :param ip_type: type of IP eg: IPv4/IPv6\n    :type ip_type: str\n    :param port: destination port on IP, defaults to None\n    :type port: str | int | None\n    :param protocol: specific protocol to follow eg: tcp(-sT)/udp(-sU),\n        defaults to None\n    :type protocol: str | None\n    :param max_retries: number of port scan probe retransmissions, defaults to None\n    :type max_retries: int | None\n    :param min_rate: send packets no slower than per second, defaults to None\n    :type min_rate: int | None\n    :param opts: other options for a nmap command, defaults to None\n    :type opts: str | None\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :raises BoardfarmException: if IP type is invalid\n    :return: response of nmap command in XML/dict format\n    :rtype: dict\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(ipaddr)","title":"<code>ipaddr</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(min_rate)","title":"<code>min_rate</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(opts)","title":"<code>opts</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.nmap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ping","title":"ping  <code>abstractmethod</code>","text":"<pre><code>ping(\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict[str, Any]\n</code></pre> <p>Ping remote host.</p> <p>Return True if ping has 0% loss or parsed output in JSON if json_output=True flag is provided.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ping IP</p> required <code>int</code> <p>number of ping, defaults to 4</p> <code>4</code> <code>str | None</code> <p>ping via interface, defaults to None</p> <code>None</code> <code>str</code> <p>extra ping options, defaults to \"\"</p> <code>''</code> <code>int</code> <p>timeout, defaults to 50</p> <code>50</code> <code>bool</code> <p>return ping output in dictionary format, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>bool | dict[str, Any]</code> <p>ping output</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef ping(  # noqa: PLR0913\n    self,\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict[str, Any]:\n    \"\"\"Ping remote host.\n\n    Return True if ping has 0% loss\n    or parsed output in JSON if json_output=True flag is provided.\n\n    :param ping_ip: ping IP\n    :type ping_ip: str\n    :param ping_count: number of ping, defaults to 4\n    :type ping_count: int\n    :param ping_interface: ping via interface, defaults to None\n    :type ping_interface: str\n    :param options: extra ping options, defaults to \"\"\n    :type options: str\n    :param timeout: timeout, defaults to 50\n    :type timeout: int\n    :param json_output: return ping output in dictionary format, defaults to False\n    :type json_output: bool\n    :return: ping output\n    :rtype: bool | dict[str, Any]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ping(ping_ip)","title":"<code>ping_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ping(ping_count)","title":"<code>ping_count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ping(ping_interface)","title":"<code>ping_interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ping(options)","title":"<code>options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ping(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.ping(json_output)","title":"<code>json_output</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.release_dhcp","title":"release_dhcp  <code>abstractmethod</code>","text":"<pre><code>release_dhcp(interface: str) -&gt; None\n</code></pre> <p>Release IPv4 of the specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef release_dhcp(self, interface: str) -&gt; None:\n    \"\"\"Release IPv4 of the specified interface.\n\n    :param interface: interface name\n    :type interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.release_dhcp(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.release_ipv6","title":"release_ipv6  <code>abstractmethod</code>","text":"<pre><code>release_ipv6(interface: str, stateless: bool = False) -&gt; None\n</code></pre> <p>Release IPv6 of the specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <code>bool</code> <p>run command with -S or -6 options. -6 by default</p> <code>False</code> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef release_ipv6(self, interface: str, stateless: bool = False) -&gt; None:\n    \"\"\"Release IPv6 of the specified interface.\n\n    :param interface: interface name\n    :type interface: str\n    :param stateless: run command with -S or -6 options. -6 by default\n    :type stateless: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.release_ipv6(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.release_ipv6(stateless)","title":"<code>stateless</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.renew_dhcp","title":"renew_dhcp  <code>abstractmethod</code>","text":"<pre><code>renew_dhcp(interface: str) -&gt; None\n</code></pre> <p>Renew IPv4 of the specified interface by restart of the IPv4 dhclient.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef renew_dhcp(self, interface: str) -&gt; None:\n    \"\"\"Renew IPv4 of the specified interface by restart of the IPv4 dhclient.\n\n    :param interface: interface name\n    :type interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.renew_dhcp(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.renew_ipv6","title":"renew_ipv6  <code>abstractmethod</code>","text":"<pre><code>renew_ipv6(interface: str, stateless: bool = False) -&gt; None\n</code></pre> <p>Renew IPv6 of the specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <code>bool</code> <p>run command with -S or -6 options. -6 by default</p> <code>False</code> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef renew_ipv6(self, interface: str, stateless: bool = False) -&gt; None:\n    \"\"\"Renew IPv6 of the specified interface.\n\n    :param interface: interface name\n    :type interface: str\n    :param stateless: run command with -S or -6 options. -6 by default\n    :type stateless: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.renew_ipv6(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.renew_ipv6(stateless)","title":"<code>stateless</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.scp_device_file_to_local","title":"scp_device_file_to_local  <code>abstractmethod</code>","text":"<pre><code>scp_device_file_to_local(local_path: str, source_path: str) -&gt; None\n</code></pre> <p>Copy a local file from a server using SCP.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local file path</p> required <code>str</code> <p>source path</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef scp_device_file_to_local(self, local_path: str, source_path: str) -&gt; None:\n    \"\"\"Copy a local file from a server using SCP.\n\n    :param local_path: local file path\n    :param source_path: source path\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.scp_device_file_to_local(local_path)","title":"<code>local_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.scp_device_file_to_local(source_path)","title":"<code>source_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.send_mldv2_report","title":"send_mldv2_report  <code>abstractmethod</code>","text":"<pre><code>send_mldv2_report(mcast_group_record: MulticastGroupRecord, count: int) -&gt; None\n</code></pre> <p>Send an MLDv2 report with desired multicast record.</p> <p>Multicast source and group must be IPv6 addresses. Multicast sources need to be non-multicast addresses and group address needs to be a multicast address.</p> <p>Implementation relies on a custom send_mld_report script based on scapy.</p> <p>Parameters:</p> Name Type Description Default <code>MulticastGroupRecord</code> <p>MLDv2 multicast group record</p> required <code>int</code> <p>num of packets to send in 1s interval</p> required <p>Raises:</p> Type Description <code>CodeError</code> <p>if send_mld_report command fails</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef send_mldv2_report(\n    self, mcast_group_record: MulticastGroupRecord, count: int\n) -&gt; None:\n    \"\"\"Send an MLDv2 report with desired multicast record.\n\n    Multicast source and group must be IPv6 addresses.\n    Multicast sources need to be non-multicast addresses and\n    group address needs to be a multicast address.\n\n    Implementation relies on a custom send_mld_report\n    script based on scapy.\n\n    :param mcast_group_record: MLDv2 multicast group record\n    :type mcast_group_record: MulticastGroupRecord\n    :param count: num of packets to send in 1s interval\n    :type count: int\n    :raises CodeError: if send_mld_report command fails\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.send_mldv2_report(mcast_group_record)","title":"<code>mcast_group_record</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.send_mldv2_report(count)","title":"<code>count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_date","title":"set_date  <code>abstractmethod</code>","text":"<pre><code>set_date(opt: str, date_string: str) -&gt; bool\n</code></pre> <p>Set the device's date and time.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>value to be changed</p> required <code>str</code> <p>Option to set the date or time or day</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if set is successful</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef set_date(self, opt: str, date_string: str) -&gt; bool:\n    \"\"\"Set the device's date and time.\n\n    :param date_string: value to be changed\n    :type date_string: str\n    :param opt: Option to set the date or time or day\n    :type opt: str\n    :return: True if set is successful\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_date(date_string)","title":"<code>date_string</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_date(opt)","title":"<code>opt</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_default_gw","title":"set_default_gw  <code>abstractmethod</code>","text":"<pre><code>set_default_gw(ip_address: IPv4Address, interface: str) -&gt; None\n</code></pre> <p>Set given IP address as default gateway address for given interface.</p> <p>Parameters:</p> Name Type Description Default <code>IPv4Address</code> <p>gateway IP address</p> required <code>str</code> <p>interface name</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef set_default_gw(self, ip_address: IPv4Address, interface: str) -&gt; None:\n    \"\"\"Set given IP address as default gateway address for given interface.\n\n    :param ip_address: gateway IP address\n    :type ip_address: IPv4Address\n    :param interface: interface name\n    :type interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_default_gw(ip_address)","title":"<code>ip_address</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_default_gw(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_link_state","title":"set_link_state  <code>abstractmethod</code>","text":"<pre><code>set_link_state(interface: str, state: str) -&gt; None\n</code></pre> <p>Set link state.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <code>str</code> <p>desired state up or down</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef set_link_state(self, interface: str, state: str) -&gt; None:\n    \"\"\"Set link state.\n\n    :param interface: name of the interface\n    :type interface: str\n    :param state: desired state up or down\n    :type state: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_link_state(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_link_state(state)","title":"<code>state</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_static_ip","title":"set_static_ip  <code>abstractmethod</code>","text":"<pre><code>set_static_ip(interface: str, ip_address: IPv4Address, netmask: IPv4Address) -&gt; None\n</code></pre> <p>Set given static IP for the LAN.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <code>IPv4Address</code> <p>static IP address</p> required <code>IPv4Address</code> <p>netmask</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef set_static_ip(\n    self,\n    interface: str,\n    ip_address: IPv4Address,\n    netmask: IPv4Address,\n) -&gt; None:\n    \"\"\"Set given static IP for the LAN.\n\n    :param interface: interface name\n    :type interface: str\n    :param ip_address: static IP address\n    :type ip_address: IPv4Address\n    :param netmask: netmask\n    :type netmask: IPv4Address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_static_ip(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_static_ip(ip_address)","title":"<code>ip_address</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.set_static_ip(netmask)","title":"<code>netmask</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_http_service","title":"start_http_service  <code>abstractmethod</code>","text":"<pre><code>start_http_service(port: str, ip_version: str) -&gt; str\n</code></pre> <p>Start HTTP service on given port number.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>port number</p> required <code>str</code> <p>IP version, 4 - IPv4, 6 - IPv6</p> required <p>Returns:</p> Type Description <code>str</code> <p>PID number of the HTTP service</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef start_http_service(self, port: str, ip_version: str) -&gt; str:\n    \"\"\"Start HTTP service on given port number.\n\n    :param port: port number\n    :type port: str\n    :param ip_version: IP version, 4 - IPv4, 6 - IPv6\n    :type ip_version: str\n    :return: PID number of the HTTP service\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_http_service(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_http_service(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_ipv4_lan_client","title":"start_ipv4_lan_client  <code>abstractmethod</code>","text":"<pre><code>start_ipv4_lan_client(\n    wan_gw: str | IPv4Address | None = None, prep_iface: bool = False\n) -&gt; str\n</code></pre> <p>Restart IPv4 dhclient to obtain IP.</p> <p>Parameters:</p> Name Type Description Default <code>str | IPv4Address | None</code> <p>WAN gateway IP to setup fixed route in case lan_fixed_route_to_wan option is provided</p> <code>None</code> <code>bool</code> <p>restart interface before dhclient request</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>IPv4 after renewal</p> <p>Raises:</p> Type Description <code>pexpect.TimeoutException</code> <p>in case of failure</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef start_ipv4_lan_client(\n    self,\n    wan_gw: str | IPv4Address | None = None,\n    prep_iface: bool = False,\n) -&gt; str:\n    \"\"\"Restart IPv4 dhclient to obtain IP.\n\n    :param wan_gw: WAN gateway IP\n        to setup fixed route in case lan_fixed_route_to_wan option is provided\n    :type wan_gw: str | IPv4Address | None\n    :param prep_iface: restart interface before dhclient request\n    :type prep_iface: bool\n    :return: IPv4 after renewal\n    :rtype: str\n    :raises pexpect.TimeoutException: in case of failure\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_ipv4_lan_client(wan_gw)","title":"<code>wan_gw</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_ipv4_lan_client(prep_iface)","title":"<code>prep_iface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_ipv6_lan_client","title":"start_ipv6_lan_client  <code>abstractmethod</code>","text":"<pre><code>start_ipv6_lan_client(\n    wan_gw: str | IPv4Address | None = None, prep_iface: bool = False\n) -&gt; str\n</code></pre> <p>Restart IPv6 dhclient to obtain IP.</p> <p>Parameters:</p> Name Type Description Default <code>str | IPv4Address | None</code> <p>WAN gateway IP to setup fixed route in case lan_fixed_route_to_wan option is provided</p> <code>None</code> <code>bool</code> <p>restart interface before dhclient request</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>IPv6 after renewal</p> <p>Raises:</p> Type Description <code>pexpect.TimeoutException</code> <p>in case of failure</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef start_ipv6_lan_client(\n    self,\n    wan_gw: str | IPv4Address | None = None,\n    prep_iface: bool = False,\n) -&gt; str:\n    \"\"\"Restart IPv6 dhclient to obtain IP.\n\n    :param wan_gw: WAN gateway IP\n        to setup fixed route in case lan_fixed_route_to_wan option is provided\n    :type wan_gw: str | IPv4Address | None\n    :param prep_iface: restart interface before dhclient request\n    :type prep_iface: bool\n    :return: IPv6 after renewal\n    :rtype: str\n    :raises pexpect.TimeoutException: in case of failure\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_ipv6_lan_client(wan_gw)","title":"<code>wan_gw</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_ipv6_lan_client(prep_iface)","title":"<code>prep_iface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping","title":"start_nping  <code>abstractmethod</code>","text":"<pre><code>start_nping(\n    interface_ip: str,\n    ipv6_flag: bool,\n    extra_args: str,\n    port_range: str,\n    hit_count: str,\n    rate: str,\n    mode: str,\n) -&gt; str\n</code></pre> <p>Perform nping.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface ip addr</p> required <code>bool</code> <p>flag if ipv6 addr to be used</p> required <code>str</code> <p>any extra arguments</p> required <code>str</code> <p>target port range</p> required <code>str</code> <p>the number of times to target each host</p> required <code>str</code> <p>num of packets per second to send</p> required <code>str</code> <p>probe mode. tcp/udp/icmp etc protocol</p> required <p>Returns:</p> Type Description <code>str</code> <p>process id</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if unable to start nping.</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef start_nping(  # pylint: disable=too-many-arguments # noqa: PLR0913\n    self,\n    interface_ip: str,\n    ipv6_flag: bool,\n    extra_args: str,\n    port_range: str,\n    hit_count: str,\n    rate: str,\n    mode: str,\n) -&gt; str:\n    \"\"\"Perform nping.\n\n    :param interface_ip: interface ip addr\n    :type interface_ip: str\n    :param ipv6_flag: flag if ipv6 addr to be used\n    :type ipv6_flag: bool\n    :param extra_args: any extra arguments\n    :type extra_args: str\n    :param port_range: target port range\n    :type port_range: str\n    :param hit_count: the number of times to target each host\n    :type hit_count: str\n    :param rate: num of packets per second to send\n    :type rate: str\n    :param mode: probe mode. tcp/udp/icmp etc protocol\n    :type mode: str\n    :return: process id\n    :rtype: str\n    :raises ValueError: if unable to start nping.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping(interface_ip)","title":"<code>interface_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping(ipv6_flag)","title":"<code>ipv6_flag</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping(port_range)","title":"<code>port_range</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping(hit_count)","title":"<code>hit_count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping(rate)","title":"<code>rate</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_nping(mode)","title":"<code>mode</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_tcpdump","title":"start_tcpdump  <code>abstractmethod</code>","text":"<pre><code>start_tcpdump(\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str\n</code></pre> <p>Start tcpdump capture on given interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>inteface name where packets to be captured</p> required <code>str | None</code> <p>port number, can be a range of ports(eg: 443 or 433-443)</p> required <code>str</code> <p>pcap file name, Defaults: pkt_capture.pcap</p> <code>'pkt_capture.pcap'</code> <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})</p> <code>None</code> <code>str | None</code> <p>additional filters</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>console ouput and tcpdump process id</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on failed to start tcpdump</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef start_tcpdump(\n    self,\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str:\n    \"\"\"Start tcpdump capture on given interface.\n\n    :param interface: inteface name where packets to be captured\n    :type interface: str\n    :param port: port number, can be a range of ports(eg: 443 or 433-443)\n    :type port: str\n    :param output_file: pcap file name, Defaults: pkt_capture.pcap\n    :type output_file: str\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n    :type filters: Optional[Dict]\n    :param additional_filters: additional filters\n    :type additional_filters: Optional[str]\n    :raises ValueError: on failed to start tcpdump\n    :return: console ouput and tcpdump process id\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_tcpdump(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_tcpdump(output_file)","title":"<code>output_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_tcpdump(additional_filters)","title":"<code>additional_filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_receiver","title":"start_traffic_receiver  <code>abstractmethod</code>","text":"<pre><code>start_traffic_receiver(\n    traffic_port: int,\n    bind_to_ip: str | None = None,\n    ip_version: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]\n</code></pre> <p>Start the server on a linux device to generate traffic using iperf3.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>server port to listen on</p> required <code>str | None</code> <p>bind to the interface associated with the address host, defaults to None</p> <code>None</code> <code>int | None</code> <p>4 or 6 as it uses only IPv4 or IPv6, defaults to None</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2 as iperf3 does not support udp only flag for server</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>the process id(pid) and log file path</p> <p>Raises:</p> Type Description <code>CodeError</code> <p>raises if unable to start server</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef start_traffic_receiver(\n    self,\n    traffic_port: int,\n    bind_to_ip: str | None = None,\n    ip_version: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]:\n    \"\"\"Start the server on a linux device to generate traffic using iperf3.\n\n    :param traffic_port: server port to listen on\n    :type traffic_port: int\n    :param bind_to_ip: bind to the interface associated with\n        the address host, defaults to None\n    :type bind_to_ip: str | None\n    :param ip_version: 4 or 6 as it uses only IPv4 or IPv6, defaults to None\n    :type ip_version: int | None\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2 as iperf3 does not support\n        udp only flag for server\n    :type udp_only: bool, optional\n    :raises CodeError: raises if unable to start server\n    :return: the process id(pid) and log file path\n    :rtype: tuple[int, str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_receiver(traffic_port)","title":"<code>traffic_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_receiver(bind_to_ip)","title":"<code>bind_to_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_receiver(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_receiver(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender","title":"start_traffic_sender  <code>abstractmethod</code>","text":"<pre><code>start_traffic_sender(\n    host: str,\n    traffic_port: int,\n    bandwidth: int | None = None,\n    bind_to_ip: str | None = None,\n    direction: str | None = None,\n    ip_version: int | None = None,\n    udp_protocol: bool = False,\n    time: int = 10,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]\n</code></pre> <p>Start traffic on a linux client using iperf3.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>a host to run in client mode</p> required <code>int</code> <p>server port to connect to</p> required <code>int | None</code> <p>bandwidth(mbps) at which the traffic has to be generated, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the address host, defaults to None</p> <code>None</code> <code>str | None</code> <p><code>--reverse</code> to run in reverse mode (server sends, client receives) or <code>--bidir</code> to run in bidirectional mode, defaults to None</p> <code>None</code> <code>int | None</code> <p>4 or 6 as it uses only IPv4 or IPv6, defaults to None</p> <code>None</code> <code>bool</code> <p>use UDP rather than TCP, defaults to False</p> <code>False</code> <code>int</code> <p>time in seconds to transmit for, defaults to 10</p> <code>10</code> <code>int | None</code> <p>client port from where the traffic is getting started</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>the process id(pid) and log file path</p> <p>Raises:</p> Type Description <code>CodeError</code> <p>raises if unable to start server</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef start_traffic_sender(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    host: str,\n    traffic_port: int,\n    bandwidth: int | None = None,\n    bind_to_ip: str | None = None,\n    direction: str | None = None,\n    ip_version: int | None = None,\n    udp_protocol: bool = False,\n    time: int = 10,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]:\n    \"\"\"Start traffic on a linux client using iperf3.\n\n    :param host: a host to run in client mode\n    :type host: str\n    :param traffic_port: server port to connect to\n    :type traffic_port: int\n    :param bandwidth: bandwidth(mbps) at which the traffic\n        has to be generated, defaults to None\n    :type bandwidth: int | None\n    :param bind_to_ip: bind to the interface associated with\n        the address host, defaults to None\n    :type bind_to_ip: str | None\n    :param direction: `--reverse` to run in reverse mode\n        (server sends, client receives) or `--bidir` to run in\n        bidirectional mode, defaults to None\n    :type direction: str | None\n    :param ip_version: 4 or 6 as it uses only IPv4 or IPv6, defaults to None\n    :type ip_version: int | None\n    :param udp_protocol: use UDP rather than TCP, defaults to False\n    :type udp_protocol: bool\n    :param time: time in seconds to transmit for, defaults to 10\n    :type time: int\n    :param client_port: client port from where the traffic is getting started\n    :type client_port: int | None\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :raises CodeError: raises if unable to start server\n    :return: the process id(pid) and log file path\n    :rtype: tuple[int, str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(host)","title":"<code>host</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(traffic_port)","title":"<code>traffic_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(bandwidth)","title":"<code>bandwidth</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(bind_to_ip)","title":"<code>bind_to_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(direction)","title":"<code>direction</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(time)","title":"<code>time</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(client_port)","title":"<code>client_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.start_traffic_sender(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_http_service","title":"stop_http_service  <code>abstractmethod</code>","text":"<pre><code>stop_http_service(port: str) -&gt; None\n</code></pre> <p>Stop HTTP service running on given port.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>port number</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef stop_http_service(self, port: str) -&gt; None:\n    \"\"\"Stop HTTP service running on given port.\n\n    :param port: port number\n    :type port: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_http_service(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_nping","title":"stop_nping  <code>abstractmethod</code>","text":"<pre><code>stop_nping(process_id: str) -&gt; None\n</code></pre> <p>Stop nping process running in background.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>process id of nping</p> required <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>when unable to stop process</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef stop_nping(self, process_id: str) -&gt; None:\n    \"\"\"Stop nping process running in background.\n\n    :param process_id: process id of nping\n    :type process_id: str\n    :raises BoardfarmException: when unable to stop process\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_nping(process_id)","title":"<code>process_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_tcpdump","title":"stop_tcpdump  <code>abstractmethod</code>","text":"<pre><code>stop_tcpdump(process_id: str) -&gt; None\n</code></pre> <p>Stop tcpdump capture.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump process id</p> required Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef stop_tcpdump(self, process_id: str) -&gt; None:\n    \"\"\"Stop tcpdump capture.\n\n    :param process_id: tcpdump process id\n    :type process_id: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_tcpdump(process_id)","title":"<code>process_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_traffic","title":"stop_traffic  <code>abstractmethod</code>","text":"<pre><code>stop_traffic(pid: int | None = None) -&gt; bool\n</code></pre> <p>Stop the iPerf3 process for a specific PID or killall.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>process ID for a iPerf3 service either for reciever or sender, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if process is stopped else False</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef stop_traffic(self, pid: int | None = None) -&gt; bool:\n    \"\"\"Stop the iPerf3 process for a specific PID or killall.\n\n    :param pid: process ID for a iPerf3 service either for reciever or sender,\n        defaults to None\n    :type pid: int | None\n    :return: True if process is stopped else False\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.stop_traffic(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tcpdump_capture","title":"tcpdump_capture  <code>abstractmethod</code>","text":"<pre><code>tcpdump_capture(\n    fname: str, interface: str = \"any\", additional_args: str | None = None\n) -&gt; Generator[str]\n</code></pre> <p>Capture packets from specified interface.</p> <p>Packet capture using tcpdump utility at a specified interface.</p> <p>:yield: process id of tcpdump process</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file where packet captures will be stored</p> required <code>str</code> <p>name of the interface, defaults to \"any\"</p> <code>'any'</code> <code>str | None</code> <p>argument arguments to tcpdump executable</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator[str, None, None]</code> <p>tcpdump capture command console output</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@contextmanager\n@abstractmethod\ndef tcpdump_capture(\n    self,\n    fname: str,\n    interface: str = \"any\",\n    additional_args: str | None = None,\n) -&gt; Generator[str]:\n    \"\"\"Capture packets from specified interface.\n\n    Packet capture using tcpdump utility at a specified interface.\n\n    :param fname: name of the file where packet captures will be stored\n    :type fname: str\n    :param interface: name of the interface, defaults to \"any\"\n    :type interface: str\n    :param additional_args: argument arguments to tcpdump executable\n    :type additional_args: str\n    :return: tcpdump capture command console output\n    :rtype: Generator[str, None, None]\n    :yield: process id of tcpdump process\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tcpdump_capture(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tcpdump_capture(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tcpdump_capture(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.traceroute","title":"traceroute  <code>abstractmethod</code>","text":"<pre><code>traceroute(\n    host_ip: str | IPv4Address, version: str = \"\", options: str = \"\", timeout: int = 60\n) -&gt; str | None\n</code></pre> <p>Return output of traceroute command.</p> <p>Parameters:</p> Name Type Description Default <code>str | IPv4Address</code> <p>destination IP address</p> required <code>str</code> <p>4 or 6</p> <code>''</code> <code>str</code> <p>traceroute command options</p> <code>''</code> <code>int</code> <p>request timeout</p> <code>60</code> <p>Returns:</p> Type Description <code>str | None</code> <p>traceroute command output</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef traceroute(\n    self,\n    host_ip: str | IPv4Address,\n    version: str = \"\",\n    options: str = \"\",\n    timeout: int = 60,\n) -&gt; str | None:\n    \"\"\"Return output of traceroute command.\n\n    :param host_ip: destination IP address\n    :type host_ip: str | IPv4Address\n    :param version: 4 or 6\n    :type version: str\n    :param options: traceroute command options\n    :type options: str\n    :param timeout: request timeout\n    :type timeout: int\n    :return: traceroute command output\n    :rtype: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.traceroute(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.traceroute(version)","title":"<code>version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.traceroute(options)","title":"<code>options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.traceroute(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tshark_read_pcap","title":"tshark_read_pcap  <code>abstractmethod</code>","text":"<pre><code>tshark_read_pcap(\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str\n</code></pre> <p>Read packet captures from an existing file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file in which captures are saved</p> required <code>str | None</code> <p>additional arguments for tshark command</p> <code>None</code> <code>int</code> <p>time out for tshark command to be executed, defaults to 30</p> <code>30</code> <code>bool</code> <p>If True remove the packet capture file after reading it</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>return tshark read command console output</p> Source code in <code>boardfarm3/templates/lan.py</code> <pre><code>@abstractmethod\ndef tshark_read_pcap(\n    self,\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str:\n    \"\"\"Read packet captures from an existing file.\n\n    :param fname: name of the file in which captures are saved\n    :type fname: str\n    :param additional_args: additional arguments for tshark command\n    :type additional_args: str\n    :param timeout: time out for tshark command to be executed, defaults to 30\n    :type timeout: int\n    :param rm_pcap: If True remove the packet capture file after reading it\n    :type rm_pcap: bool\n    :return: return tshark read command console output\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tshark_read_pcap(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tshark_read_pcap(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tshark_read_pcap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.lan.LAN.tshark_read_pcap(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.line_termination","title":"line_termination","text":"<p>Generic Template for Line Termination Systems.</p> <p>Acts as a boilerplate to further extend templating of different broadband LTSs like CMTS, OLT or DSLAMs.</p> <p>Classes:</p> Name Description <code>LTS</code> <p>Generic LTS template.</p>"},{"location":"reference/templates/#boardfarm3.templates.line_termination.LTS","title":"LTS","text":"<p>Generic LTS template.</p> <p>Methods:</p> Name Description <code>tshark_read_pcap</code> <p>Read packet captures from an existing file.</p>"},{"location":"reference/templates/#boardfarm3.templates.line_termination.LTS.tshark_read_pcap","title":"tshark_read_pcap  <code>abstractmethod</code>","text":"<pre><code>tshark_read_pcap(\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str\n</code></pre> <p>Read packet captures from an existing file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file in which captures are saved</p> required <code>str | None</code> <p>additional arguments for tshark command</p> <code>None</code> <code>int</code> <p>time out for tshark command to be executed, defaults to 30</p> <code>30</code> <code>bool</code> <p>If True remove the packet capture file after reading it</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>return tshark read command console output</p> Source code in <code>boardfarm3/templates/line_termination.py</code> <pre><code>@abstractmethod\ndef tshark_read_pcap(\n    self,\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str:\n    \"\"\"Read packet captures from an existing file.\n\n    :param fname: name of the file in which captures are saved\n    :param additional_args: additional arguments for tshark command\n    :param timeout: time out for tshark command to be executed, defaults to 30\n    :param rm_pcap: If True remove the packet capture file after reading it\n    :return: return tshark read command console output\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.line_termination.LTS.tshark_read_pcap(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.line_termination.LTS.tshark_read_pcap(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.line_termination.LTS.tshark_read_pcap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.line_termination.LTS.tshark_read_pcap(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.pdu","title":"pdu","text":"<p>Define the PDU template.</p> <p>Classes:</p> Name Description <code>PDU</code> <p>PDU template to be implemented.</p>"},{"location":"reference/templates/#boardfarm3.templates.pdu.PDU","title":"PDU","text":"<pre><code>PDU(uri: str)\n</code></pre> <p>PDU template to be implemented.</p> <p>Initialise the PUD object.</p> <p>examples of PDU uris:</p> <pre><code>NetIO:        \"10.64.40.34; 2\"\nRaritan PX2:  \"10.71.10.53:23; 2\"\nRaritan PX3:  \"10.71.10.53:22; 1\"\n</code></pre> <p>No type is passed to the PDU only the connection parameters.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>a string relating to the PDU access params</p> required <p>Methods:</p> Name Description <code>power_cycle</code> <p>Power cycle the given PDU outlet.</p> <code>power_off</code> <p>Power OFF the given PDU outlet.</p> <code>power_on</code> <p>Power ON the given PDU outlet.</p> Source code in <code>boardfarm3/templates/pdu.py</code> <pre><code>@abstractmethod\ndef __init__(self, uri: str) -&gt; None:\n    \"\"\"Initialise the PUD object.\n\n    examples of PDU uris:\n\n        NetIO:        \"10.64.40.34; 2\"\n        Raritan PX2:  \"10.71.10.53:23; 2\"\n        Raritan PX3:  \"10.71.10.53:22; 1\"\n\n    No type is passed to the PDU only the connection parameters.\n\n    :param uri: a string relating to the PDU access params\n    :type uri: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.pdu.PDU(uri)","title":"<code>uri</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.pdu.PDU.power_cycle","title":"power_cycle  <code>abstractmethod</code>","text":"<pre><code>power_cycle() -&gt; bool\n</code></pre> <p>Power cycle the given PDU outlet.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True on success</p> Source code in <code>boardfarm3/templates/pdu.py</code> <pre><code>@abstractmethod\ndef power_cycle(self) -&gt; bool:\n    \"\"\"Power cycle the given PDU outlet.\n\n    :returns: True on success\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.pdu.PDU.power_off","title":"power_off  <code>abstractmethod</code>","text":"<pre><code>power_off() -&gt; bool\n</code></pre> <p>Power OFF the given PDU outlet.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True on success</p> Source code in <code>boardfarm3/templates/pdu.py</code> <pre><code>@abstractmethod\ndef power_off(self) -&gt; bool:\n    \"\"\"Power OFF the given PDU outlet.\n\n    :returns: True on success\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.pdu.PDU.power_on","title":"power_on  <code>abstractmethod</code>","text":"<pre><code>power_on() -&gt; bool\n</code></pre> <p>Power ON the given PDU outlet.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True on success</p> Source code in <code>boardfarm3/templates/pdu.py</code> <pre><code>@abstractmethod\ndef power_on(self) -&gt; bool:\n    \"\"\"Power ON the given PDU outlet.\n\n    :returns: True on success\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner","title":"provisioner","text":"<p>Provisioner device template.</p> <p>Classes:</p> Name Description <code>Provisioner</code> <p>Boardfarm base provisioner device template.</p>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner","title":"Provisioner","text":"<pre><code>Provisioner(config: dict, cmdline_args: Namespace)\n</code></pre> <p>Boardfarm base provisioner device template.</p> <p>Initialize boardfarm base device.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>device configuration</p> required <code>Namespace</code> <p>command line arguments</p> required <p>Methods:</p> Name Description <code>delete_file</code> <p>Delete the file from the device.</p> <code>get_interactive_consoles</code> <p>Get interactive consoles from device.</p> <code>provision_cpe</code> <p>Provision the CPE.</p> <code>scp_device_file_to_local</code> <p>Copy a local file from a server using SCP.</p> <code>start_tcpdump</code> <p>Start tcpdump capture on given interface.</p> <code>stop_tcpdump</code> <p>Stop tcpdump capture.</p> <code>tshark_read_pcap</code> <p>Read packet captures from an existing file.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>Get device configuration.</p> <code>console</code> <code>BoardfarmPexpect</code> <p>Returns Provisioner console.</p> <code>device_name</code> <code>str</code> <p>Get name of the device.</p> <code>device_type</code> <code>str</code> <p>Get type of the device.</p> <code>firewall</code> <code>IptablesFirewall</code> <p>Returns Firewall utility instance.</p> <code>iface_dut</code> <code>str</code> <p>Name of the interface that is connected to DUT.</p> Source code in <code>boardfarm3/devices/base_devices/boardfarm_device.py</code> <pre><code>def __init__(self, config: dict, cmdline_args: Namespace) -&gt; None:\n    \"\"\"Initialize boardfarm base device.\n\n    :param config: device configuration\n    :param cmdline_args: command line arguments\n    \"\"\"\n    self._config: dict = config\n    self._cmdline_args = cmdline_args\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner(config)","title":"<code>config</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner(cmdline_args)","title":"<code>cmdline_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.config","title":"config  <code>property</code>","text":"<pre><code>config: dict\n</code></pre> <p>Get device configuration.</p> <p>Returns:</p> Type Description <code>dict</code> <p>device configuration</p>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.console","title":"console  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>console: BoardfarmPexpect\n</code></pre> <p>Returns Provisioner console.</p> <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console</p>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.device_name","title":"device_name  <code>property</code>","text":"<pre><code>device_name: str\n</code></pre> <p>Get name of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>device name</p>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.device_type","title":"device_type  <code>property</code>","text":"<pre><code>device_type: str\n</code></pre> <p>Get type of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>device type</p>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.firewall","title":"firewall  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>firewall: IptablesFirewall\n</code></pre> <p>Returns Firewall utility instance.</p> <p>Returns:</p> Type Description <code>IptablesFirewall</code> <p>firewall utility instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.iface_dut","title":"iface_dut  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>iface_dut: str\n</code></pre> <p>Name of the interface that is connected to DUT.</p>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.delete_file","title":"delete_file  <code>abstractmethod</code>","text":"<pre><code>delete_file(filename: str) -&gt; None\n</code></pre> <p>Delete the file from the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required Source code in <code>boardfarm3/templates/provisioner.py</code> <pre><code>@abstractmethod\ndef delete_file(self, filename: str) -&gt; None:\n    \"\"\"Delete the file from the device.\n\n    :param filename: name of the file with absolute path\n    :type filename: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.delete_file(filename)","title":"<code>filename</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.get_interactive_consoles","title":"get_interactive_consoles","text":"<pre><code>get_interactive_consoles() -&gt; dict[str, BoardfarmPexpect]\n</code></pre> <p>Get interactive consoles from device.</p> <p>Returns:</p> Type Description <code>dict[str, BoardfarmPexpect]</code> <p>interactive consoles of the device</p> Source code in <code>boardfarm3/devices/base_devices/boardfarm_device.py</code> <pre><code>def get_interactive_consoles(self) -&gt; dict[str, BoardfarmPexpect]:\n    \"\"\"Get interactive consoles from device.\n\n    :returns: interactive consoles of the device\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.provision_cpe","title":"provision_cpe  <code>abstractmethod</code>","text":"<pre><code>provision_cpe(\n    cpe_mac: str,\n    dhcpv4_options: dict[DHCPServicePools, DHCPv4Options],\n    dhcpv6_options: dict[DHCPServicePools, DHCPv6Options],\n) -&gt; None\n</code></pre> <p>Provision the CPE.</p> <p>Adds a DHCP Host reservation in the provisioner.</p> <p>The host reservation can further be configured to also provide custom DHCP option data, depending on the option requested as part of the <code>dhcpv4_option</code> and <code>dhcpv6_options</code> arguments.</p> <p>.. code-block:: python</p> <pre><code>mac = \"AA:BB:CC:DD:EE:AA\"\nprovisioner = device_manager.get_device_by_type(Provisioner)\n\n# Provision a CPE MAC with default DHCP options\nprovisioner.provision_cpe(\n    cpe_mac=mac,\n    dhcpv4_options={},\n    dhcpv6_options={},\n)\n\n# Provision a CPE MAC with custom DHCP options\n# Note: This is a partial configuration.\n# If only partial details are provided, device class\n# will fill the remaining option data with defaults\ndhcpv4_options = {\n    \"data\": {\"dns-server\": \"x.x.x.x\"},\n    \"voice\": {\"ntp-server\": \"y.y.y.y\"},\n}\nprovisioner.provision_cpe(\n    cpe_mac=mac, dhcpv4_options=dhcpv4_options, dhcpv6_options={}\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>CPE mac address</p> required <code>dict[DHCPServicePools, DHCPv4Options]</code> <p>DHCPv4 Options with ACS, NTP, DNS details</p> required <code>dict[DHCPServicePools, DHCPv6Options]</code> <p>DHCPv6 Options with ACS, NTP, DNS details</p> required Source code in <code>boardfarm3/templates/provisioner.py</code> <pre><code>@abstractmethod\ndef provision_cpe(\n    self,\n    cpe_mac: str,\n    dhcpv4_options: dict[DHCPServicePools, DHCPv4Options],\n    dhcpv6_options: dict[DHCPServicePools, DHCPv6Options],\n) -&gt; None:\n    \"\"\"Provision the CPE.\n\n    Adds a DHCP Host reservation in the provisioner.\n\n    The host reservation can further be configured to also provide\n    custom DHCP option data, depending on the option requested as part\n    of the ```dhcpv4_option``` and ```dhcpv6_options``` arguments.\n\n    .. code-block:: python\n\n        mac = \"AA:BB:CC:DD:EE:AA\"\n        provisioner = device_manager.get_device_by_type(Provisioner)\n\n        # Provision a CPE MAC with default DHCP options\n        provisioner.provision_cpe(\n            cpe_mac=mac,\n            dhcpv4_options={},\n            dhcpv6_options={},\n        )\n\n        # Provision a CPE MAC with custom DHCP options\n        # Note: This is a partial configuration.\n        # If only partial details are provided, device class\n        # will fill the remaining option data with defaults\n        dhcpv4_options = {\n            \"data\": {\"dns-server\": \"x.x.x.x\"},\n            \"voice\": {\"ntp-server\": \"y.y.y.y\"},\n        }\n        provisioner.provision_cpe(\n            cpe_mac=mac, dhcpv4_options=dhcpv4_options, dhcpv6_options={}\n        )\n\n    :param cpe_mac: CPE mac address\n    :type cpe_mac: str\n    :param dhcpv4_options: DHCPv4 Options with ACS, NTP, DNS details\n    :type dhcpv4_options: dict[DHCPServicePools, DHCPv4Options]\n    :param dhcpv6_options: DHCPv6 Options with ACS, NTP, DNS details\n    :type dhcpv6_options: dict[DHCPServicePools, DHCPv6Options]\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.provision_cpe(cpe_mac)","title":"<code>cpe_mac</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.provision_cpe(dhcpv4_options)","title":"<code>dhcpv4_options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.provision_cpe(dhcpv6_options)","title":"<code>dhcpv6_options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.scp_device_file_to_local","title":"scp_device_file_to_local  <code>abstractmethod</code>","text":"<pre><code>scp_device_file_to_local(local_path: str, source_path: str) -&gt; None\n</code></pre> <p>Copy a local file from a server using SCP.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local file path</p> required <code>str</code> <p>source path</p> required Source code in <code>boardfarm3/templates/provisioner.py</code> <pre><code>@abstractmethod\ndef scp_device_file_to_local(self, local_path: str, source_path: str) -&gt; None:\n    \"\"\"Copy a local file from a server using SCP.\n\n    :param local_path: local file path\n    :param source_path: source path\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.scp_device_file_to_local(local_path)","title":"<code>local_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.scp_device_file_to_local(source_path)","title":"<code>source_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.start_tcpdump","title":"start_tcpdump  <code>abstractmethod</code>","text":"<pre><code>start_tcpdump(\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str\n</code></pre> <p>Start tcpdump capture on given interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>inteface name where packets to be captured</p> required <code>str | None</code> <p>port number, can be a range of ports(eg: 443 or 433-443)</p> required <code>str</code> <p>pcap file name, Defaults: pkt_capture.pcap</p> <code>'pkt_capture.pcap'</code> <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})</p> <code>None</code> <code>str | None</code> <p>additional filters</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>console ouput and tcpdump process id</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on failed to start tcpdump</p> Source code in <code>boardfarm3/templates/provisioner.py</code> <pre><code>@abstractmethod\ndef start_tcpdump(\n    self,\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str:\n    \"\"\"Start tcpdump capture on given interface.\n\n    :param interface: inteface name where packets to be captured\n    :type interface: str\n    :param port: port number, can be a range of ports(eg: 443 or 433-443)\n    :type port: str\n    :param output_file: pcap file name, Defaults: pkt_capture.pcap\n    :type output_file: str\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n    :type filters: Optional[Dict]\n    :param additional_filters: additional filters\n    :type additional_filters: Optional[str]\n    :raises ValueError: on failed to start tcpdump\n    :return: console ouput and tcpdump process id\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.start_tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.start_tcpdump(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.start_tcpdump(output_file)","title":"<code>output_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.start_tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.start_tcpdump(additional_filters)","title":"<code>additional_filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.stop_tcpdump","title":"stop_tcpdump  <code>abstractmethod</code>","text":"<pre><code>stop_tcpdump(process_id: str) -&gt; None\n</code></pre> <p>Stop tcpdump capture.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump process id</p> required Source code in <code>boardfarm3/templates/provisioner.py</code> <pre><code>@abstractmethod\ndef stop_tcpdump(self, process_id: str) -&gt; None:\n    \"\"\"Stop tcpdump capture.\n\n    :param process_id: tcpdump process id\n    :type process_id: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.stop_tcpdump(process_id)","title":"<code>process_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.tshark_read_pcap","title":"tshark_read_pcap  <code>abstractmethod</code>","text":"<pre><code>tshark_read_pcap(\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str\n</code></pre> <p>Read packet captures from an existing file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file in which captures are saved</p> required <code>str | None</code> <p>additional arguments for tshark command</p> <code>None</code> <code>int</code> <p>timeout for tshark command to be executed, defaults to 30</p> <code>30</code> <code>bool</code> <p>If True remove the packet capture file after reading it</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>return tshark read command console output</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>when invalid filters are added</p> Source code in <code>boardfarm3/templates/provisioner.py</code> <pre><code>@abstractmethod\ndef tshark_read_pcap(\n    self,\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str:\n    \"\"\"Read packet captures from an existing file.\n\n    :param fname: name of the file in which captures are saved\n    :param additional_args: additional arguments for tshark command\n    :param timeout: timeout for tshark command to be executed, defaults to 30\n    :param rm_pcap: If True remove the packet capture file after reading it\n    :return: return tshark read command console output\n    :raises  FileNotFoundError: when file is not found\n    :raises BoardfarmException: when invalid filters are added\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.tshark_read_pcap(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.tshark_read_pcap(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.tshark_read_pcap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.provisioner.Provisioner.tshark_read_pcap(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_phone","title":"sip_phone","text":"<p>SIPPhone Template module.</p> <p>Classes:</p> Name Description <code>SIPPhone</code> <p>SIP Phone Template.</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone","title":"SIPPhone","text":"<p>SIP Phone Template.</p> <p>Methods:</p> Name Description <code>answer</code> <p>To answer a call on RING state.</p> <code>answer_waiting_call</code> <p>Answer the waiting call and hang up on the current call.</p> <code>detect_dialtone</code> <p>Check if dialtone is detected off_hook on the active_line.</p> <code>dial</code> <p>Dial the given sequence.</p> <code>dial_feature_code</code> <p>Dial a feature code.</p> <code>has_off_hook_warning</code> <p>Check if Phone has off hook warning on a line represented by active_line.</p> <code>hook_flash</code> <p>Perform hook flash.</p> <code>is_call_ended</code> <p>Check if Phone has end up the call on a line represented by active_line.</p> <code>is_call_not_answered</code> <p>Verify if caller's call was not answered on active_line.</p> <code>is_call_waiting</code> <p>Check if Phone is on call waiting on a line represented by active_line.</p> <code>is_code_ended</code> <p>Check if Phone has end up the code on a line represented by active_line.</p> <code>is_connected</code> <p>Check if call is connected on the active_line.</p> <code>is_dialing</code> <p>Check if the phone is dialing to another phone.</p> <code>is_idle</code> <p>Check if Phone is in idle state on a line represented by active_line.</p> <code>is_in_conference</code> <p>Check if Phone is in conference on a line represented by active_line.</p> <code>is_incall_connected</code> <p>Check if call is in call connected on the active_line.</p> <code>is_incall_dialing</code> <p>Check if Phone is in call and dialing.</p> <code>is_incall_playing_dialtone</code> <p>Check if Phone is playing dialtone. on one line and on call to another line.</p> <code>is_line_busy</code> <p>Check if the call is denied due to callee being busy.</p> <code>is_onhold</code> <p>Check if Phone is on hold on a line represented by active_line.</p> <code>is_playing_dialtone</code> <p>Check if Phone is playing dialtone on a line represented by active_line.</p> <code>is_ringing</code> <p>Check if Phone is ringing on a line represented by active_line.</p> <code>merge_two_calls</code> <p>Merge the two calls for conference calling.</p> <code>off_hook</code> <p>Execute off_hook procedure to connect to a line.</p> <code>on_hook</code> <p>Execute on_hook procedure to disconnect to a line.</p> <code>phone_config</code> <p>Configure phone with a SIP url using SIP server ddqn for registration.</p> <code>phone_kill</code> <p>Close the serial connection.</p> <code>phone_start</code> <p>Connect to the serial line of FXS modem.</p> <code>place_call_offhold</code> <p>Place an ongoing call off-hold.</p> <code>place_call_onhold</code> <p>Place an ongoing call on-hold.</p> <code>press_R_button</code> <p>Press the R button.</p> <code>press_buttons</code> <p>Press the given sequence of buttons.</p> <code>reject_waiting_call</code> <p>Reject a call on waiting on second line.</p> <code>reply_with_code</code> <p>To reply back to an incoming call with a SIP code value.</p> <code>toggle_call</code> <p>Toggle between the calls.</p> <p>Attributes:</p> Name Type Description <code>ipv4_addr</code> <code>str | None</code> <p>Return the SIP Phone IP v4 address.</p> <code>ipv6_addr</code> <code>str | None</code> <p>Return the SIP Phone IP v6 address.</p> <code>name</code> <code>str</code> <p>Return the SIP Phone name.</p> <code>number</code> <code>str</code> <p>To get the registered SIP number.</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.ipv4_addr","title":"ipv4_addr  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>ipv4_addr: str | None\n</code></pre> <p>Return the SIP Phone IP v4 address.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>phone IP v4 address</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.ipv6_addr","title":"ipv6_addr  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>ipv6_addr: str | None\n</code></pre> <p>Return the SIP Phone IP v6 address.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>phone IP v6 address</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.name","title":"name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Return the SIP Phone name.</p> <p>Returns:</p> Type Description <code>str</code> <p>phone name</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.number","title":"number  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>number: str\n</code></pre> <p>To get the registered SIP number.</p> <p>This property shall be dynamically populated during the post_boot activities of environment setup for voice.</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.answer","title":"answer  <code>abstractmethod</code>","text":"<pre><code>answer() -&gt; bool\n</code></pre> <p>To answer a call on RING state.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef answer(self) -&gt; bool:\n    \"\"\"To answer a call on RING state.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.answer_waiting_call","title":"answer_waiting_call  <code>abstractmethod</code>","text":"<pre><code>answer_waiting_call() -&gt; None\n</code></pre> <p>Answer the waiting call and hang up on the current call.</p> <p>This will toggle the line on the device.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef answer_waiting_call(self) -&gt; None:\n    \"\"\"Answer the waiting call and hang up on the current call.\n\n    This will toggle the line on the device.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.detect_dialtone","title":"detect_dialtone  <code>abstractmethod</code>","text":"<pre><code>detect_dialtone() -&gt; bool\n</code></pre> <p>Check if dialtone is detected off_hook on the active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if dial tone is detected</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef detect_dialtone(self) -&gt; bool:\n    \"\"\"Check if dialtone is detected off_hook on the active_line.\n\n    :return: True if dial tone is detected\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.dial","title":"dial  <code>abstractmethod</code>","text":"<pre><code>dial(sequence: str) -&gt; None\n</code></pre> <p>Dial the given sequence.</p> <p>This sequence could be a phone number or a VSC.</p> <p>Call shall proceed on the line indicated by active_line property.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>phone number or VSC</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>as this is a Template.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef dial(self, sequence: str) -&gt; None:\n    \"\"\"Dial the given sequence.\n\n    This sequence could be a phone number or a VSC.\n\n    Call shall proceed on the line indicated by active_line property.\n\n    :param sequence: phone number or VSC\n    :type sequence: str\n    :raises NotImplementedError: as this is a Template.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.dial(sequence)","title":"<code>sequence</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.dial_feature_code","title":"dial_feature_code","text":"<pre><code>dial_feature_code(code: str) -&gt; None\n</code></pre> <p>Dial a feature code.</p> <p>Dial the given code, check that it executed and put the phone on hook.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the code to be executed</p> required <p>Raises:</p> Type Description <code>VoiceError</code> <p>in case execution did not end well</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>def dial_feature_code(self, code: str) -&gt; None:\n    \"\"\"Dial a feature code.\n\n    Dial the given code, check that it executed and put the phone on hook.\n\n    :param code: the code to be executed\n    :type code: str\n    :raises VoiceError: in case execution did not end well\n    \"\"\"\n    self.dial(sequence=code)\n    if not self.is_code_ended():\n        msg = f\"Call not ended after dialing a feature code: {code}\"\n        raise VoiceError(msg)\n    self.on_hook()\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.dial_feature_code(code)","title":"<code>code</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.has_off_hook_warning","title":"has_off_hook_warning  <code>abstractmethod</code>","text":"<pre><code>has_off_hook_warning() -&gt; bool\n</code></pre> <p>Check if Phone has off hook warning on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone has off hook warning</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef has_off_hook_warning(self) -&gt; bool:\n    \"\"\"Check if Phone has off hook warning on a line represented by active_line.\n\n    :return: True if the phone has off hook warning\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.hook_flash","title":"hook_flash  <code>abstractmethod</code>","text":"<pre><code>hook_flash() -&gt; None\n</code></pre> <p>Perform hook flash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>as this is a Template</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef hook_flash(self) -&gt; None:\n    \"\"\"Perform hook flash.\n\n    :raises NotImplementedError: as this is a Template\n    \"\"\"\n    msg = \"Not supported.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_call_ended","title":"is_call_ended  <code>abstractmethod</code>","text":"<pre><code>is_call_ended() -&gt; bool\n</code></pre> <p>Check if Phone has end up the call on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone end up the call</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_call_ended(self) -&gt; bool:\n    \"\"\"Check if Phone has end up the call on a line represented by active_line.\n\n    :return: True if the phone end up the call\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_call_not_answered","title":"is_call_not_answered  <code>abstractmethod</code>","text":"<pre><code>is_call_not_answered() -&gt; bool\n</code></pre> <p>Verify if caller's call was not answered on active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if not answered, else False</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_call_not_answered(self) -&gt; bool:\n    \"\"\"Verify if caller's call was not answered on active_line.\n\n    :return: True if not answered, else False\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_call_waiting","title":"is_call_waiting  <code>abstractmethod</code>","text":"<pre><code>is_call_waiting() -&gt; bool\n</code></pre> <p>Check if Phone is on call waiting on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is on call waiting</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_call_waiting(self) -&gt; bool:\n    \"\"\"Check if Phone is on call waiting on a line represented by active_line.\n\n    :return: True if the phone is on call waiting\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_code_ended","title":"is_code_ended  <code>abstractmethod</code>","text":"<pre><code>is_code_ended() -&gt; bool\n</code></pre> <p>Check if Phone has end up the code on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone has end up the code</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_code_ended(self) -&gt; bool:\n    \"\"\"Check if Phone has end up the code on a line represented by active_line.\n\n    :return: True if the phone has end up the code\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_connected","title":"is_connected  <code>abstractmethod</code>","text":"<pre><code>is_connected() -&gt; bool\n</code></pre> <p>Check if call is connected on the active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is connected</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_connected(self) -&gt; bool:\n    \"\"\"Check if call is connected on the active_line.\n\n    :return: True if the phone is connected\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_dialing","title":"is_dialing  <code>abstractmethod</code>","text":"<pre><code>is_dialing() -&gt; bool\n</code></pre> <p>Check if the phone is dialing to another phone.</p> <p>Check if the phone is dialing to another phone on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is dialing in progress</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_dialing(self) -&gt; bool:\n    \"\"\"Check if the phone is dialing to another phone.\n\n    Check if the phone is dialing to another phone on a line represented\n    by active_line.\n\n    :return: True if the phone is dialing in progress\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_idle","title":"is_idle  <code>abstractmethod</code>","text":"<pre><code>is_idle() -&gt; bool\n</code></pre> <p>Check if Phone is in idle state on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is idle</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_idle(self) -&gt; bool:\n    \"\"\"Check if Phone is in idle state on a line represented by active_line.\n\n    :return: True if the phone is idle\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_in_conference","title":"is_in_conference  <code>abstractmethod</code>","text":"<pre><code>is_in_conference() -&gt; bool\n</code></pre> <p>Check if Phone is in conference on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is in conference</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_in_conference(self) -&gt; bool:\n    \"\"\"Check if Phone is in conference on a line represented by active_line.\n\n    :return: True if the phone is in conference\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_incall_connected","title":"is_incall_connected  <code>abstractmethod</code>","text":"<pre><code>is_incall_connected() -&gt; bool\n</code></pre> <p>Check if call is in call connected on the active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is in call connected</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_incall_connected(self) -&gt; bool:\n    \"\"\"Check if call is in call connected on the active_line.\n\n    :return: True if the phone is in call connected\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_incall_dialing","title":"is_incall_dialing  <code>abstractmethod</code>","text":"<pre><code>is_incall_dialing() -&gt; bool\n</code></pre> <p>Check if Phone is in call and dialing.</p> <p>Check if Phone is in call and dialing to another phone on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is in call and dialing in progress on another line</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_incall_dialing(self) -&gt; bool:\n    \"\"\"Check if Phone is in call and dialing.\n\n    Check if Phone is in call and dialing to another phone on a line\n    represented by active_line.\n\n    :return: True if the phone is in call and dialing in progress on\n             another line\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_incall_playing_dialtone","title":"is_incall_playing_dialtone  <code>abstractmethod</code>","text":"<pre><code>is_incall_playing_dialtone() -&gt; bool\n</code></pre> <p>Check if Phone is playing dialtone. on one line and on call to another line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is incall playing dialtone</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_incall_playing_dialtone(self) -&gt; bool:\n    \"\"\"Check if Phone is playing dialtone. on one line and on call to another line.\n\n    :return: True if the phone is incall playing dialtone\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_line_busy","title":"is_line_busy  <code>abstractmethod</code>","text":"<pre><code>is_line_busy() -&gt; bool\n</code></pre> <p>Check if the call is denied due to callee being busy.</p> <p>Validation will be performed on the line indicated by active_line property.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if line is busy, else False</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_line_busy(self) -&gt; bool:\n    \"\"\"Check if the call is denied due to callee being busy.\n\n    Validation will be performed on the line indicated by\n    active_line property.\n\n    :return: True if line is busy, else False\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_onhold","title":"is_onhold  <code>abstractmethod</code>","text":"<pre><code>is_onhold() -&gt; bool\n</code></pre> <p>Check if Phone is on hold on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is on hold</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_onhold(self) -&gt; bool:\n    \"\"\"Check if Phone is on hold on a line represented by active_line.\n\n    :return: True if the phone is on hold\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_playing_dialtone","title":"is_playing_dialtone  <code>abstractmethod</code>","text":"<pre><code>is_playing_dialtone() -&gt; bool\n</code></pre> <p>Check if Phone is playing dialtone on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is playing dialtone</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_playing_dialtone(self) -&gt; bool:\n    \"\"\"Check if Phone is playing dialtone on a line represented by active_line.\n\n    :return: True if the phone is playing dialtone\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.is_ringing","title":"is_ringing  <code>abstractmethod</code>","text":"<pre><code>is_ringing() -&gt; bool\n</code></pre> <p>Check if Phone is ringing on a line represented by active_line.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the phone is ringing</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef is_ringing(self) -&gt; bool:\n    \"\"\"Check if Phone is ringing on a line represented by active_line.\n\n    :return: True if the phone is ringing\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.merge_two_calls","title":"merge_two_calls  <code>abstractmethod</code>","text":"<pre><code>merge_two_calls() -&gt; None\n</code></pre> <p>Merge the two calls for conference calling.</p> <p>Ensure call waiting must be enabled. There must be a call on other line to add to conference.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef merge_two_calls(self) -&gt; None:\n    \"\"\"Merge the two calls for conference calling.\n\n    Ensure call waiting must be enabled.\n    There must be a call on other line to add to conference.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.off_hook","title":"off_hook  <code>abstractmethod</code>","text":"<pre><code>off_hook() -&gt; None\n</code></pre> <p>Execute off_hook procedure to connect to a line.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef off_hook(self) -&gt; None:\n    \"\"\"Execute off_hook procedure to connect to a line.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.on_hook","title":"on_hook  <code>abstractmethod</code>","text":"<pre><code>on_hook() -&gt; None\n</code></pre> <p>Execute on_hook procedure to disconnect to a line.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef on_hook(self) -&gt; None:\n    \"\"\"Execute on_hook procedure to disconnect to a line.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.phone_config","title":"phone_config  <code>abstractmethod</code>","text":"<pre><code>phone_config(ipv6_flag: bool, sipserver_fqdn: str = '') -&gt; None\n</code></pre> <p>Configure phone with a SIP url using SIP server ddqn for registration.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>dicatates whether to use ipv6 address or not</p> required <code>str</code> <p>the sip server, defaults to \"\"</p> <code>''</code> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef phone_config(self, ipv6_flag: bool, sipserver_fqdn: str = \"\") -&gt; None:\n    \"\"\"Configure phone with a SIP url using SIP server ddqn for registration.\n\n    :param ipv6_flag: dicatates whether to use ipv6 address or not\n    :type ipv6_flag: bool\n    :param sipserver_fqdn: the sip server, defaults to \"\"\n    :type sipserver_fqdn: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.phone_config(ipv6_flag)","title":"<code>ipv6_flag</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.phone_config(sipserver_fqdn)","title":"<code>sipserver_fqdn</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.phone_kill","title":"phone_kill  <code>abstractmethod</code>","text":"<pre><code>phone_kill() -&gt; None\n</code></pre> <p>Close the serial connection.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef phone_kill(self) -&gt; None:\n    \"\"\"Close the serial connection.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.phone_start","title":"phone_start  <code>abstractmethod</code>","text":"<pre><code>phone_start() -&gt; None\n</code></pre> <p>Connect to the serial line of FXS modem.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef phone_start(self) -&gt; None:\n    \"\"\"Connect to the serial line of FXS modem.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.place_call_offhold","title":"place_call_offhold  <code>abstractmethod</code>","text":"<pre><code>place_call_offhold() -&gt; None\n</code></pre> <p>Place an ongoing call off-hold.</p> <p>There must be a call on hold to be placed to off hold.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef place_call_offhold(self) -&gt; None:\n    \"\"\"Place an ongoing call off-hold.\n\n    There must be a call on hold to be placed to off hold.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.place_call_onhold","title":"place_call_onhold  <code>abstractmethod</code>","text":"<pre><code>place_call_onhold() -&gt; None\n</code></pre> <p>Place an ongoing call on-hold.</p> <p>There must be an active call to be placed on hold.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef place_call_onhold(self) -&gt; None:\n    \"\"\"Place an ongoing call on-hold.\n\n    There must be an active call to be placed on hold.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.press_R_button","title":"press_R_button  <code>abstractmethod</code>","text":"<pre><code>press_R_button() -&gt; None\n</code></pre> <p>Press the R button.</p> <p>Used when we put a call on hold, or during dialing.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef press_R_button(self) -&gt; None:  # pylint: disable=invalid-name\n    \"\"\"Press the R button.\n\n    Used when we put a call on hold, or during dialing.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.press_buttons","title":"press_buttons  <code>abstractmethod</code>","text":"<pre><code>press_buttons(buttons: str) -&gt; None\n</code></pre> <p>Press the given sequence of buttons.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>sequence of buttons, e.g. \"R2\"</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>as this is a Template</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef press_buttons(self, buttons: str) -&gt; None:\n    \"\"\"Press the given sequence of buttons.\n\n    :param buttons: sequence of buttons, e.g. \"R2\"\n    :type buttons: str\n    :raises NotImplementedError: as this is a Template\n    \"\"\"\n    # press a button for each button in the list\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.press_buttons(buttons)","title":"<code>buttons</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.reject_waiting_call","title":"reject_waiting_call  <code>abstractmethod</code>","text":"<pre><code>reject_waiting_call() -&gt; None\n</code></pre> <p>Reject a call on waiting on second line.</p> <p>This will send the call to voice mail or a busy tone. There must be a call on the second line to reject.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef reject_waiting_call(self) -&gt; None:\n    \"\"\"Reject a call on waiting on second line.\n\n    This will send the call to voice mail or a busy tone.\n    There must be a call on the second line to reject.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.reply_with_code","title":"reply_with_code  <code>abstractmethod</code>","text":"<pre><code>reply_with_code(code: int) -&gt; None\n</code></pre> <p>To reply back to an incoming call with a SIP code value.</p> <p>In case of certain phones, we need to explicitly send out SIP codes such as: - 486 Busy - 200 OK - 603 Decline - 608 Rejected</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>SIP code value</p> required Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef reply_with_code(self, code: int) -&gt; None:\n    \"\"\"To reply back to an incoming call with a SIP code value.\n\n    In case of certain phones, we need to explicitly send out SIP codes\n    such as:\n    - 486 Busy\n    - 200 OK\n    - 603 Decline\n    - 608 Rejected\n\n    :param code: SIP code value\n    :type code: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.reply_with_code(code)","title":"<code>code</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_phone.SIPPhone.toggle_call","title":"toggle_call  <code>abstractmethod</code>","text":"<pre><code>toggle_call() -&gt; None\n</code></pre> <p>Toggle between the calls.</p> <p>Need to first validate, there is an incoming call on other line. If not throw an exception.</p> Source code in <code>boardfarm3/templates/sip_phone.py</code> <pre><code>@abstractmethod\ndef toggle_call(self) -&gt; None:\n    \"\"\"Toggle between the calls.\n\n    Need to first validate, there is an incoming call on other line.\n    If not throw an exception.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server","title":"sip_server","text":"<p>SIPServer Template module.</p> <p>Classes:</p> Name Description <code>SIPServer</code> <p>SIP Server template class.</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer","title":"SIPServer","text":"<p>SIP Server template class.</p> <p>Contains a list of APIs to interact with the SIP server. All methods marked with @abstractmethod annotation have to be implemented in the derived class with the same signatures as in template. Unsupported functionality shall raise a NotSupportedError exception.</p> <p>Methods:</p> Name Description <code>add_user</code> <p>Add user to the directory.</p> <code>allocate_number</code> <p>Allocate a number from the sipserver number list.</p> <code>delete_file</code> <p>Delete the file from the device.</p> <code>get_expire_timer</code> <p>Get the call expire timer in the sipserver config.</p> <code>get_interface_ipaddr</code> <p>Return the IPv4 address of the DUT connected interface.</p> <code>get_online_users</code> <p>Get SipServer online users.</p> <code>get_status</code> <p>Return the status of the server.</p> <code>get_vsc_prefix</code> <p>Get prefix to build a VSC.</p> <code>remove_endpoint</code> <p>Remove an endpoint from the directory.</p> <code>remove_endpoint_from_sipserver</code> <p>Remove an endpoint from the directory.</p> <code>restart</code> <p>Restart the server.</p> <code>scp_device_file_to_local</code> <p>Copy a local file from a server using SCP.</p> <code>set_expire_timer</code> <p>Modify call expire timer in the sipserver config.</p> <code>sipserver_get_expire_timer</code> <p>Get the call expire timer in the sipserver config.</p> <code>sipserver_get_online_users</code> <p>Get SipServer online users.</p> <code>sipserver_restart</code> <p>Restart the server.</p> <code>sipserver_set_expire_timer</code> <p>Modify call expire timer in the sipserver config.</p> <code>sipserver_start</code> <p>Start the server.</p> <code>sipserver_status</code> <p>Return the status of the server.</p> <code>sipserver_stop</code> <p>Stop the server.</p> <code>sipserver_user_add</code> <p>Add user to the directory.</p> <code>start</code> <p>Start the server.</p> <code>stop</code> <p>Stop the server.</p> <code>tcpdump_capture</code> <p>Capture packets from specified interface.</p> <code>tshark_read_pcap</code> <p>Read packet captures from an existing file.</p> <p>Attributes:</p> Name Type Description <code>fqdn</code> <code>Optional[str]</code> <p>Return the sipserver fqdn.</p> <code>iface_dut</code> <code>str</code> <p>Return the DUT connected interface.</p> <code>ipv4_addr</code> <code>Optional[str]</code> <p>Return the server IP v4 address.</p> <code>ipv6_addr</code> <code>Optional[str]</code> <p>Return the server IP v6 address.</p> <code>name</code> <code>str</code> <p>Return the SIP server name.</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.fqdn","title":"fqdn  <code>property</code>","text":"<pre><code>fqdn: Optional[str]\n</code></pre> <p>Return the sipserver fqdn.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>not implemented yet</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.iface_dut","title":"iface_dut  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>iface_dut: str\n</code></pre> <p>Return the DUT connected interface.</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.ipv4_addr","title":"ipv4_addr  <code>property</code>","text":"<pre><code>ipv4_addr: Optional[str]\n</code></pre> <p>Return the server IP v4 address.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>not implemented yet</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.ipv6_addr","title":"ipv6_addr  <code>property</code>","text":"<pre><code>ipv6_addr: Optional[str]\n</code></pre> <p>Return the server IP v6 address.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>not implemented yet</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.name","title":"name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Return the SIP server name.</p> <p>Returns:</p> Type Description <code>str</code> <p>server name</p>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.add_user","title":"add_user  <code>abstractmethod</code>","text":"<pre><code>add_user(user: str, password: Optional[str] = None) -&gt; None\n</code></pre> <p>Add user to the directory.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the user entry to be added</p> required <code>Optional[str]</code> <p>the password of the endpoint is determined by the user</p> <code>None</code> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef add_user(\n    self,\n    user: str,\n    password: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add user to the directory.\n\n    :param user: the user entry to be added\n    :type user: str\n    :param password: the password of the endpoint is determined by the user\n    :type password: Optional[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.add_user(user)","title":"<code>user</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.add_user(password)","title":"<code>password</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.allocate_number","title":"allocate_number  <code>abstractmethod</code>","text":"<pre><code>allocate_number(number: Optional[str] = None) -&gt; str\n</code></pre> <p>Allocate a number from the sipserver number list.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[str]</code> <p>the phone number, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the allocated number</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef allocate_number(self, number: Optional[str] = None) -&gt; str:\n    \"\"\"Allocate a number from the sipserver number list.\n\n    :param number: the phone number, defaults to None\n    :type number: Optional[str]\n    :return: the allocated number\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.allocate_number(number)","title":"<code>number</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.delete_file","title":"delete_file  <code>abstractmethod</code>","text":"<pre><code>delete_file(filename: str) -&gt; None\n</code></pre> <p>Delete the file from the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef delete_file(self, filename: str) -&gt; None:\n    \"\"\"Delete the file from the device.\n\n    :param filename: name of the file with absolute path\n    :type filename: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.delete_file(filename)","title":"<code>filename</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.get_expire_timer","title":"get_expire_timer  <code>abstractmethod</code>","text":"<pre><code>get_expire_timer() -&gt; int\n</code></pre> <p>Get the call expire timer in the sipserver config.</p> <p>Returns:</p> Type Description <code>int</code> <p>expiry timer saved in the config</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef get_expire_timer(self) -&gt; int:\n    \"\"\"Get the call expire timer in the sipserver config.\n\n    :return: expiry timer saved in the config\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.get_interface_ipaddr","title":"get_interface_ipaddr","text":"<pre><code>get_interface_ipaddr() -&gt; Optional[str]\n</code></pre> <p>Return the IPv4 address of the DUT connected interface.</p> <p>This method is deprecated in favour of reading the <code>ipv4_addr</code> property.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>the IPv4 address</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"ipv4_addr\")\ndef get_interface_ipaddr(self) -&gt; Optional[str]:\n    \"\"\"Return the IPv4 address of the DUT connected interface.\n\n    This method is deprecated in favour of reading the `ipv4_addr` property.\n\n    :return: the IPv4 address\n    :rtype: Optional[str]\n    \"\"\"\n    return self.ipv4_addr\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.get_online_users","title":"get_online_users  <code>abstractmethod</code>","text":"<pre><code>get_online_users() -&gt; str\n</code></pre> <p>Get SipServer online users.</p> <p>Returns:</p> Type Description <code>str</code> <p>the online users</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef get_online_users(self) -&gt; str:\n    \"\"\"Get SipServer online users.\n\n    :return: the online users\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.get_status","title":"get_status  <code>abstractmethod</code>","text":"<pre><code>get_status() -&gt; str\n</code></pre> <p>Return the status of the server.</p> <p>Returns:</p> Type Description <code>str</code> <p>the status of the server</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef get_status(self) -&gt; str:\n    \"\"\"Return the status of the server.\n\n    :return: the status of the server\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.get_vsc_prefix","title":"get_vsc_prefix  <code>abstractmethod</code>","text":"<pre><code>get_vsc_prefix(scope: VscScopeType) -&gt; str\n</code></pre> <p>Get prefix to build a VSC.</p> <p>It is expected that, to enable call forwarding, the phone dials a pattern as: \"{prefix}{phone_number}#\".</p> <p>It is is expected that all prefixes to disable call forwarding terminate with <code>#</code> to execute the VSC.</p> <p>.. code-block:: python</p> <pre><code># example output\n\"*63*\"  # to activate call forwarding busy\n\n\"#63#\"  # to disable call forwarding busy\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VscScopeType</code> <p>Set/Unset call forwarding in case of busy/no answer/unconditional</p> required <p>Returns:</p> Type Description <code>str</code> <p>the prefix to be dialled</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>as this is a Template</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef get_vsc_prefix(self, scope: VscScopeType) -&gt; str:\n    \"\"\"Get prefix to build a VSC.\n\n    It is expected that, to enable call forwarding, the phone dials a pattern as:\n    \"{prefix}{phone_number}#\".\n\n    It is is expected that all prefixes to disable call forwarding terminate with\n    `#` to execute the VSC.\n\n    .. code-block:: python\n\n        # example output\n        \"*63*\"  # to activate call forwarding busy\n\n        \"#63#\"  # to disable call forwarding busy\n\n\n    :param scope: Set/Unset call forwarding in case of busy/no answer/unconditional\n    :type scope: VscScopeType\n    :raises NotImplementedError: as this is a Template\n    :return: the prefix to be dialled\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.get_vsc_prefix(scope)","title":"<code>scope</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.remove_endpoint","title":"remove_endpoint  <code>abstractmethod</code>","text":"<pre><code>remove_endpoint(endpoint: str) -&gt; None\n</code></pre> <p>Remove an endpoint from the directory.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the endpoint entry to be added</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef remove_endpoint(self, endpoint: str) -&gt; None:\n    \"\"\"Remove an endpoint from the directory.\n\n    :param endpoint: the endpoint entry to be added\n    :type endpoint: str\n    :return: None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.remove_endpoint(endpoint)","title":"<code>endpoint</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.remove_endpoint_from_sipserver","title":"remove_endpoint_from_sipserver","text":"<pre><code>remove_endpoint_from_sipserver(endpoint: str) -&gt; None\n</code></pre> <p>Remove an endpoint from the directory.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the endpoint entry to be added</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"remove_endpoint\")\ndef remove_endpoint_from_sipserver(self, endpoint: str) -&gt; None:\n    \"\"\"Remove an endpoint from the directory.\n\n    :param endpoint: the endpoint entry to be added\n    :type endpoint: str\n    :return: None\n    \"\"\"\n    return self.remove_endpoint(endpoint=endpoint)\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.remove_endpoint_from_sipserver(endpoint)","title":"<code>endpoint</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.restart","title":"restart  <code>abstractmethod</code>","text":"<pre><code>restart() -&gt; None\n</code></pre> <p>Restart the server.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef restart(self) -&gt; None:\n    \"\"\"Restart the server.\n\n    :return: None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.scp_device_file_to_local","title":"scp_device_file_to_local  <code>abstractmethod</code>","text":"<pre><code>scp_device_file_to_local(local_path: str, source_path: str) -&gt; None\n</code></pre> <p>Copy a local file from a server using SCP.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local file path</p> required <code>str</code> <p>source path</p> required Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef scp_device_file_to_local(self, local_path: str, source_path: str) -&gt; None:\n    \"\"\"Copy a local file from a server using SCP.\n\n    :param local_path: local file path\n    :param source_path: source path\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.scp_device_file_to_local(local_path)","title":"<code>local_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.scp_device_file_to_local(source_path)","title":"<code>source_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.set_expire_timer","title":"set_expire_timer  <code>abstractmethod</code>","text":"<pre><code>set_expire_timer(to_timer: int = 60) -&gt; None\n</code></pre> <p>Modify call expire timer in the sipserver config.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Expire timer value change to, default to 60</p> <code>60</code> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef set_expire_timer(self, to_timer: int = 60) -&gt; None:\n    \"\"\"Modify call expire timer in the sipserver config.\n\n    :param to_timer: Expire timer value change to, default to 60\n    :type to_timer: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.set_expire_timer(to_timer)","title":"<code>to_timer</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_get_expire_timer","title":"sipserver_get_expire_timer","text":"<pre><code>sipserver_get_expire_timer() -&gt; int\n</code></pre> <p>Get the call expire timer in the sipserver config.</p> <p>Returns:</p> Type Description <code>int</code> <p>expiry timer saved in the config</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"get_expire_timer\")\ndef sipserver_get_expire_timer(self) -&gt; int:\n    \"\"\"Get the call expire timer in the sipserver config.\n\n    :return: expiry timer saved in the config\n    :rtype: int\n    \"\"\"\n    return self.get_expire_timer()\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_get_online_users","title":"sipserver_get_online_users","text":"<pre><code>sipserver_get_online_users() -&gt; str\n</code></pre> <p>Get SipServer online users.</p> <p>Returns:</p> Type Description <code>str</code> <p>the online users</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"get_online_users\")\ndef sipserver_get_online_users(self) -&gt; str:\n    \"\"\"Get SipServer online users.\n\n    :return: the online users\n    :rtype: str\n    \"\"\"\n    return self.get_online_users()\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_restart","title":"sipserver_restart","text":"<pre><code>sipserver_restart() -&gt; None\n</code></pre> <p>Restart the server.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"restart\")\ndef sipserver_restart(self) -&gt; None:\n    \"\"\"Restart the server.\n\n    :return: None\n    \"\"\"\n    return self.restart()\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_set_expire_timer","title":"sipserver_set_expire_timer","text":"<pre><code>sipserver_set_expire_timer(to_timer: int = 60) -&gt; None\n</code></pre> <p>Modify call expire timer in the sipserver config.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Expire timer value change to, default to 60</p> <code>60</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"set_expire_timer\")\ndef sipserver_set_expire_timer(self, to_timer: int = 60) -&gt; None:\n    \"\"\"Modify call expire timer in the sipserver config.\n\n    :param to_timer: Expire timer value change to, default to 60\n    :type to_timer: int\n    :return: None\n    \"\"\"\n    return self.set_expire_timer(to_timer=to_timer)\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_set_expire_timer(to_timer)","title":"<code>to_timer</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_start","title":"sipserver_start","text":"<pre><code>sipserver_start() -&gt; None\n</code></pre> <p>Start the server.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"start\")\ndef sipserver_start(self) -&gt; None:\n    \"\"\"Start the server.\n\n    :return: None\n    \"\"\"\n    return self.start()\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_status","title":"sipserver_status","text":"<pre><code>sipserver_status() -&gt; str\n</code></pre> <p>Return the status of the server.</p> <p>Returns:</p> Type Description <code>str</code> <p>the status of the server</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"get_status\")\ndef sipserver_status(self) -&gt; str:\n    \"\"\"Return the status of the server.\n\n    :return: the status of the server\n    :rtype: str\n    \"\"\"\n    return self.get_status()\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_stop","title":"sipserver_stop","text":"<pre><code>sipserver_stop() -&gt; None\n</code></pre> <p>Stop the server.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"stop\")\ndef sipserver_stop(self) -&gt; None:\n    \"\"\"Stop the server.\n\n    :return: None\n    \"\"\"\n    return self.stop()\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_user_add","title":"sipserver_user_add","text":"<pre><code>sipserver_user_add(user: str, password: Optional[str] = None) -&gt; None\n</code></pre> <p>Add user to the directory.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the user entry to be added</p> required <code>Optional[str]</code> <p>the password of the endpoint is determined by the user</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@moves.moved_method(\"add_user\")\ndef sipserver_user_add(\n    self,\n    user: str,\n    password: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add user to the directory.\n\n    :param user: the user entry to be added\n    :type user: str\n    :param password: the password of the endpoint is determined by the user\n    :type password: Optional[str]\n    :return: None\n    \"\"\"\n    return self.add_user(user=user, password=password)\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_user_add(user)","title":"<code>user</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.sipserver_user_add(password)","title":"<code>password</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the server.</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start the server.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.stop","title":"stop  <code>abstractmethod</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the server.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"Stop the server.\n\n    :return: None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tcpdump_capture","title":"tcpdump_capture  <code>abstractmethod</code>","text":"<pre><code>tcpdump_capture(\n    fname: str, interface: str = \"any\", additional_args: Optional[str] = None\n) -&gt; Generator[str, None, None]\n</code></pre> <p>Capture packets from specified interface.</p> <p>Packet capture using tcpdump utility at a specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file where packet captures will be stored</p> required <code>str</code> <p>name of the interface, defaults to \"any\"</p> <code>'any'</code> <code>Optional[str]</code> <p>arguments to tcpdump command, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator[str, None, None]</code> <p>process id of tcpdump process</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@contextmanager\n@abstractmethod\ndef tcpdump_capture(\n    self,\n    fname: str,\n    interface: str = \"any\",\n    additional_args: Optional[str] = None,\n) -&gt; Generator[str, None, None]:\n    \"\"\"Capture packets from specified interface.\n\n    Packet capture using tcpdump utility at a specified interface.\n\n    :param fname: name of the file where packet captures will be stored\n    :type fname: str\n    :param interface: name of the interface, defaults to \"any\"\n    :type interface: str\n    :param additional_args: arguments to tcpdump command, defaults to None\n    :type additional_args: Optional[str]\n    :return: process id of tcpdump process\n    :rtype: Generator[str, None, None]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tcpdump_capture(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tcpdump_capture(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tcpdump_capture(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tshark_read_pcap","title":"tshark_read_pcap  <code>abstractmethod</code>","text":"<pre><code>tshark_read_pcap(\n    fname: str,\n    additional_args: Optional[str] = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str\n</code></pre> <p>Read packet captures from an existing file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file in which captures are saved</p> required <code>Optional[str]</code> <p>additional arguments for tshark, defaults to None</p> <code>None</code> <code>int</code> <p>timeout for tshark command to be executed, defaults to 30</p> <code>30</code> <code>bool</code> <p>remove the pcap file after reading if True, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>return tshark read command console output</p> Source code in <code>boardfarm3/templates/sip_server.py</code> <pre><code>@abstractmethod\ndef tshark_read_pcap(\n    self,\n    fname: str,\n    additional_args: Optional[str] = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str:\n    \"\"\"Read packet captures from an existing file.\n\n    :param fname: name of the file in which captures are saved\n    :type fname: str\n    :param additional_args: additional arguments for tshark, defaults to None\n    :type additional_args: Optional[str], optional\n    :param timeout: timeout for tshark command to be executed, defaults to 30\n    :type timeout: int\n    :param rm_pcap: remove the pcap file after reading if True, defaults to False\n    :type rm_pcap: bool\n    :return: return tshark read command console output\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tshark_read_pcap(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tshark_read_pcap(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tshark_read_pcap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.sip_server.SIPServer.tshark_read_pcap(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.tftp","title":"tftp","text":"<p>Boardfarm TFTP device template.</p> <p>Classes:</p> Name Description <code>TFTP</code> <p>Boardfarm TFTP device template.</p>"},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP","title":"TFTP","text":"<p>Boardfarm TFTP device template.</p> <p>Methods:</p> Name Description <code>download_image_from_uri</code> <p>Download image from given URI.</p> <code>get_eth_interface_ipv4_address</code> <p>Get eth interface ipv4 address.</p> <code>restart_lighttpd</code> <p>Restart lighttpd service.</p> <code>set_tmp_static_ip</code> <p>Temporarily set a static IPv4 on the DUT connected iface via the <code>ip</code> cmd.</p> <code>stop_lighttpd</code> <p>Stop the lighttpd service.</p>"},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP.download_image_from_uri","title":"download_image_from_uri  <code>abstractmethod</code>","text":"<pre><code>download_image_from_uri(image_uri: str) -&gt; str\n</code></pre> <p>Download image from given URI.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>image URI</p> required <p>Returns:</p> Type Description <code>str</code> <p>downloaded image name</p> Source code in <code>boardfarm3/templates/tftp.py</code> <pre><code>@abstractmethod\ndef download_image_from_uri(self, image_uri: str) -&gt; str:\n    \"\"\"Download image from given URI.\n\n    :param image_uri: image URI\n    :returns: downloaded image name\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP.download_image_from_uri(image_uri)","title":"<code>image_uri</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP.get_eth_interface_ipv4_address","title":"get_eth_interface_ipv4_address  <code>abstractmethod</code>","text":"<pre><code>get_eth_interface_ipv4_address() -&gt; str\n</code></pre> <p>Get eth interface ipv4 address.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address of eth interface</p> Source code in <code>boardfarm3/templates/tftp.py</code> <pre><code>@abstractmethod\ndef get_eth_interface_ipv4_address(self) -&gt; str:\n    \"\"\"Get eth interface ipv4 address.\n\n    :returns: IPv4 address of eth interface\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP.restart_lighttpd","title":"restart_lighttpd  <code>abstractmethod</code>","text":"<pre><code>restart_lighttpd() -&gt; None\n</code></pre> <p>Restart lighttpd service.</p> Source code in <code>boardfarm3/templates/tftp.py</code> <pre><code>@abstractmethod\ndef restart_lighttpd(self) -&gt; None:\n    \"\"\"Restart lighttpd service.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP.set_tmp_static_ip","title":"set_tmp_static_ip  <code>abstractmethod</code>","text":"<pre><code>set_tmp_static_ip(static_address: IPv4Address) -&gt; Generator[None, None, None]\n</code></pre> <p>Temporarily set a static IPv4 on the DUT connected iface via the <code>ip</code> cmd.</p> <p>:yield: The DUT connected interface with the static ip address applied</p> <p>Parameters:</p> Name Type Description Default <code>IPv4Address</code> <p>Static IPv4 address to be set</p> required Source code in <code>boardfarm3/templates/tftp.py</code> <pre><code>@abstractmethod\n@contextmanager\ndef set_tmp_static_ip(\n    self, static_address: IPv4Address\n) -&gt; Generator[None, None, None]:\n    \"\"\"Temporarily set a static IPv4 on the DUT connected iface via the `ip` cmd.\n\n    :param static_address: Static IPv4 address to be set\n    :type static_address: IPv4Address\n    :yield: The DUT connected interface with the static ip address applied\n    :rtype: Generator[None, None, None]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP.set_tmp_static_ip(static_address)","title":"<code>static_address</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.tftp.TFTP.stop_lighttpd","title":"stop_lighttpd  <code>abstractmethod</code>","text":"<pre><code>stop_lighttpd() -&gt; None\n</code></pre> <p>Stop the lighttpd service.</p> Source code in <code>boardfarm3/templates/tftp.py</code> <pre><code>@abstractmethod\ndef stop_lighttpd(self) -&gt; None:\n    \"\"\"Stop the lighttpd service.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan","title":"wan","text":"<p>Boardfarm WAN device template.</p> <p>Classes:</p> Name Description <code>WAN</code> <p>Boardfarm WAN device template.</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN","title":"WAN","text":"<p>Boardfarm WAN device template.</p> <p>Methods:</p> Name Description <code>add_route</code> <p>Add a route to a destination via a specific gateway interface.</p> <code>copy_local_file_to_tftpboot</code> <p>SCP local file to tftpboot directory.</p> <code>curl</code> <p>Perform curl action to web service.</p> <code>delete_file</code> <p>Delete the file from the device.</p> <code>delete_route</code> <p>Delete a route to a destination.</p> <code>dns_lookup</code> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <code>download_image_to_tftpboot</code> <p>Download image from URL to tftpboot directory.</p> <code>execute_snmp_command</code> <p>Execute SNMP command.</p> <code>get_date</code> <p>Get the system date and time.</p> <code>get_eth_interface_ipv4_address</code> <p>Get eth interface ipv4 address.</p> <code>get_eth_interface_ipv6_address</code> <p>Get IPv6 address of eth interface.</p> <code>get_hostname</code> <p>Get the hostname of the device.</p> <code>get_interface_ipv4addr</code> <p>Return ipv4 address of the interface.</p> <code>get_interface_ipv6addr</code> <p>Return ipv4 address of the interface.</p> <code>get_interface_macaddr</code> <p>Get the interface MAC address.</p> <code>get_interface_mask</code> <p>Get the subnet mask of the interface.</p> <code>get_interface_mtu_size</code> <p>Get the MTU size of the interface in bytes.</p> <code>get_iperf_logs</code> <p>Read the file output for traffic flow.</p> <code>get_network_statistics</code> <p>Execute netstat command to get the port status.</p> <code>get_process_id</code> <p>Return the process id to the device.</p> <code>hping_flood</code> <p>Validate SYN, UDP and ICMP flood operation.</p> <code>http_get</code> <p>Peform http get and return parsed result.</p> <code>is_connect_to_board_via_reverse_ssh_successful</code> <p>Perform reverse SSH from jump server to CPE.</p> <code>is_link_up</code> <p>Return the link status.</p> <code>kill_process</code> <p>Kill the running process based on the process id.</p> <code>nmap</code> <p>Perform nmap operation on linux device.</p> <code>ping</code> <p>Ping remote host.</p> <code>release_dhcp</code> <p>Release IPv4 of the specified interface.</p> <code>scp_device_file_to_local</code> <p>Copy a local file from a server using SCP.</p> <code>set_date</code> <p>Set the device's date and time.</p> <code>set_default_gw</code> <p>Set given IP address as default gateway address for given interface.</p> <code>set_link_state</code> <p>Set link state.</p> <code>set_static_ip</code> <p>Set given static IP for the LAN.</p> <code>start_http_service</code> <p>Start HTTP service on given port number.</p> <code>start_tcpdump</code> <p>Start tcpdump capture on given interface.</p> <code>start_traffic_receiver</code> <p>Start the server on a linux device to generate traffic using iperf3.</p> <code>start_traffic_sender</code> <p>Start traffic on a linux client using iperf3.</p> <code>stop_http_service</code> <p>Stop http service running on given port.</p> <code>stop_tcpdump</code> <p>Stop tcpdump capture.</p> <code>stop_traffic</code> <p>Stop the iPerf3 process for a specific PID or killall.</p> <code>tcpdump_capture</code> <p>Capture packets from specified interface.</p> <code>tshark_read_pcap</code> <p>Read packet captures from an existing file.</p> <p>Attributes:</p> Name Type Description <code>console</code> <code>BoardfarmPexpect</code> <p>Returns WAN console.</p> <code>firewall</code> <code>IptablesFirewall</code> <p>Returns Firewall iptables instance.</p> <code>http_proxy</code> <code>str</code> <p>SOCKS5 Dante proxy address, e.g http://{proxy_ip}:{proxy_port}/.</p> <code>iface_dut</code> <code>str</code> <p>Name of the interface that is connected to DUT.</p> <code>ipv4_addr</code> <code>str</code> <p>Return the IPv4 address on IFACE facing DUT.</p> <code>ipv6_addr</code> <code>str</code> <p>Return the IPv6 address on IFACE facing DUT.</p> <code>multicast</code> <code>Multicast</code> <p>Return multicast component instance.</p> <code>nslookup</code> <code>NSLookup</code> <p>Returns NSLookup utility instance.</p> <code>nw_utility</code> <code>NetworkUtility</code> <p>Returns Network utility instance.</p> <code>rssh_password</code> <code>str</code> <p>Return the WAN password for reverse SSH.</p> <code>rssh_username</code> <code>str</code> <p>Return the WAN username for reverse SSH.</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.console","title":"console  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>console: BoardfarmPexpect\n</code></pre> <p>Returns WAN console.</p> <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.firewall","title":"firewall  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>firewall: IptablesFirewall\n</code></pre> <p>Returns Firewall iptables instance.</p> <p>Returns:</p> Type Description <code>IptablesFirewall</code> <p>firewall iptables instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.http_proxy","title":"http_proxy  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>http_proxy: str\n</code></pre> <p>SOCKS5 Dante proxy address, e.g http://{proxy_ip}:{proxy_port}/.</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.iface_dut","title":"iface_dut  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>iface_dut: str\n</code></pre> <p>Name of the interface that is connected to DUT.</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ipv4_addr","title":"ipv4_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv4_addr: str\n</code></pre> <p>Return the IPv4 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ipv6_addr","title":"ipv6_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv6_addr: str\n</code></pre> <p>Return the IPv6 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.multicast","title":"multicast  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>multicast: Multicast\n</code></pre> <p>Return multicast component instance.</p> <p>Returns:</p> Type Description <code>Multicast</code> <p>multicast component instance</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nslookup","title":"nslookup  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nslookup: NSLookup\n</code></pre> <p>Returns NSLookup utility instance.</p> <p>Returns:</p> Type Description <code>NSLookup</code> <p>nslookup utility instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nw_utility","title":"nw_utility  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>nw_utility: NetworkUtility\n</code></pre> <p>Returns Network utility instance.</p> <p>Returns:</p> Type Description <code>NetworkUtility</code> <p>network utiluty instance with console object</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.rssh_password","title":"rssh_password  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>rssh_password: str\n</code></pre> <p>Return the WAN password for reverse SSH.</p> <p>Returns:</p> Type Description <code>str</code> <p>WAN password</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.rssh_username","title":"rssh_username  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>rssh_username: str\n</code></pre> <p>Return the WAN username for reverse SSH.</p> <p>Returns:</p> Type Description <code>str</code> <p>WAN username</p>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.add_route","title":"add_route  <code>abstractmethod</code>","text":"<pre><code>add_route(destination: str, gw_interface: str) -&gt; None\n</code></pre> <p>Add a route to a destination via a specific gateway interface.</p> <p>The method will internally calculate the exit interface's ip address before adding the route. The gw_interface must be an interface name that exists on the host.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address of the destination</p> required <code>str</code> <p>name of the interface</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef add_route(self, destination: str, gw_interface: str) -&gt; None:\n    \"\"\"Add a route to a destination via a specific gateway interface.\n\n    The method will internally calculate the exit interface's ip address\n    before adding the route.\n    The gw_interface must be an interface name that exists on the host.\n\n    :param destination: ip address of the destination\n    :type destination: str\n    :param gw_interface: name of the interface\n    :type gw_interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.add_route(destination)","title":"<code>destination</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.add_route(gw_interface)","title":"<code>gw_interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.copy_local_file_to_tftpboot","title":"copy_local_file_to_tftpboot  <code>abstractmethod</code>","text":"<pre><code>copy_local_file_to_tftpboot(local_file_path: str) -&gt; str\n</code></pre> <p>SCP local file to tftpboot directory.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local file path</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef copy_local_file_to_tftpboot(self, local_file_path: str) -&gt; str:\n    \"\"\"SCP local file to tftpboot directory.\n\n    :param local_file_path: local file path\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.copy_local_file_to_tftpboot(local_file_path)","title":"<code>local_file_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.curl","title":"curl  <code>abstractmethod</code>","text":"<pre><code>curl(\n    url: str | IPv4Address,\n    protocol: str,\n    port: str | int | None = None,\n    options: str = \"\",\n) -&gt; bool\n</code></pre> <p>Perform curl action to web service.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <p>web service address</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef curl(\n    self,\n    url: str | IPv4Address,\n    protocol: str,\n    port: str | int | None = None,\n    options: str = \"\",\n) -&gt; bool:\n    \"\"\"Perform curl action to web service.\n\n    :param url : web service address\n    :param protocol : Web Protocol (http or https)\n    :param port : port number of server\n    :param options : Additional curl options\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.curl()","title":"","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.delete_file","title":"delete_file  <code>abstractmethod</code>","text":"<pre><code>delete_file(filename: str) -&gt; None\n</code></pre> <p>Delete the file from the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef delete_file(self, filename: str) -&gt; None:\n    \"\"\"Delete the file from the device.\n\n    :param filename: name of the file with absolute path\n    :type filename: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.delete_file(filename)","title":"<code>filename</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.delete_route","title":"delete_route  <code>abstractmethod</code>","text":"<pre><code>delete_route(destination: str) -&gt; None\n</code></pre> <p>Delete a route to a destination.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address of the destination</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef delete_route(self, destination: str) -&gt; None:\n    \"\"\"Delete a route to a destination.\n\n    :param destination: ip address of the destination\n    :type destination: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.delete_route(destination)","title":"<code>destination</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.dns_lookup","title":"dns_lookup  <code>abstractmethod</code>","text":"<pre><code>dns_lookup(domain_name: str, record_type: str, opts: str = '') -&gt; list[dict[str, Any]]\n</code></pre> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>domain name which needs lookup</p> required <code>str</code> <p>AAAA for ipv6 else A</p> required <code>str</code> <p>options to be provided to dig command, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>parsed dig command ouput</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef dns_lookup(\n    self, domain_name: str, record_type: str, opts: str = \"\"\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Perform ``dig`` command in the devices to resolve DNS.\n\n    :param domain_name: domain name which needs lookup\n    :type domain_name: str\n    :param record_type: AAAA for ipv6 else A\n    :type record_type: str\n    :param opts: options to be provided to dig command, defaults to \"\"\n    :type opts: str\n    :return: parsed dig command ouput\n    :rtype: List[Dict[str, Any]]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.dns_lookup(domain_name)","title":"<code>domain_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.dns_lookup(record_type)","title":"<code>record_type</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.dns_lookup(opts)","title":"<code>opts</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.download_image_to_tftpboot","title":"download_image_to_tftpboot  <code>abstractmethod</code>","text":"<pre><code>download_image_to_tftpboot(image_uri: str) -&gt; str\n</code></pre> <p>Download image from URL to tftpboot directory.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>image file URI</p> required <p>Returns:</p> Type Description <code>str</code> <p>name of the image in tftpboot</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef download_image_to_tftpboot(self, image_uri: str) -&gt; str:\n    \"\"\"Download image from URL to tftpboot directory.\n\n    :param image_uri: image file URI\n    :returns: name of the image in tftpboot\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.download_image_to_tftpboot(image_uri)","title":"<code>image_uri</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.execute_snmp_command","title":"execute_snmp_command  <code>abstractmethod</code>","text":"<pre><code>execute_snmp_command(snmp_command: str, timeout: int = 30) -&gt; str\n</code></pre> <p>Execute SNMP command.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>snmp command</p> required <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>str</code> <p>given snmp command output</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef execute_snmp_command(self, snmp_command: str, timeout: int = 30) -&gt; str:\n    \"\"\"Execute SNMP command.\n\n    :param snmp_command: snmp command\n    :type snmp_command: str\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :returns: given snmp command output\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.execute_snmp_command(snmp_command)","title":"<code>snmp_command</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.execute_snmp_command(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_date","title":"get_date  <code>abstractmethod</code>","text":"<pre><code>get_date() -&gt; str | None\n</code></pre> <p>Get the system date and time.</p> <p>.. code-block:: python</p> <pre><code># example output\ndonderdag, mei 23, 2024 14:23:39\n</code></pre> <p>Returns:</p> Type Description <code>str | None</code> <p>date</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_date(self) -&gt; str | None:\n    \"\"\"Get the system date and time.\n\n    .. code-block:: python\n\n        # example output\n        donderdag, mei 23, 2024 14:23:39\n\n\n    :return: date\n    :rtype: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_eth_interface_ipv4_address","title":"get_eth_interface_ipv4_address  <code>abstractmethod</code>","text":"<pre><code>get_eth_interface_ipv4_address() -&gt; str\n</code></pre> <p>Get eth interface ipv4 address.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address of eth interface</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_eth_interface_ipv4_address(self) -&gt; str:\n    \"\"\"Get eth interface ipv4 address.\n\n    :returns: IPv4 address of eth interface\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_eth_interface_ipv6_address","title":"get_eth_interface_ipv6_address  <code>abstractmethod</code>","text":"<pre><code>get_eth_interface_ipv6_address(address_type: str = 'global') -&gt; str\n</code></pre> <p>Get IPv6 address of eth interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ipv6 address type. defaults to \"global\".</p> <code>'global'</code> <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address of eth interface</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_eth_interface_ipv6_address(self, address_type: str = \"global\") -&gt; str:\n    \"\"\"Get IPv6 address of eth interface.\n\n    :param address_type: ipv6 address type. defaults to \"global\".\n    :returns: IPv6 address of eth interface\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_eth_interface_ipv6_address(address_type)","title":"<code>address_type</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_hostname","title":"get_hostname  <code>abstractmethod</code>","text":"<pre><code>get_hostname() -&gt; str\n</code></pre> <p>Get the hostname of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>hostname of the device</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_hostname(self) -&gt; str:\n    \"\"\"Get the hostname of the device.\n\n    :return: hostname of the device\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_ipv4addr","title":"get_interface_ipv4addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv4addr(interface: str) -&gt; str\n</code></pre> <p>Return ipv4 address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv4 of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv4 is not found</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv4addr(self, interface: str) -&gt; str:\n    \"\"\"Return ipv4 address of the interface.\n\n    :param interface: interface name\n    :return: IPv4 of the interface\n    :raises BoardfarmException: in case IPv4 is not found\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_ipv4addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_ipv6addr","title":"get_interface_ipv6addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Return ipv4 address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv6 of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv6 is not found</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Return ipv4 address of the interface.\n\n    :param interface: interface name\n    :return: IPv6 of the interface\n    :raises BoardfarmException: in case IPv6 is not found\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_macaddr","title":"get_interface_macaddr  <code>abstractmethod</code>","text":"<pre><code>get_interface_macaddr(interface: str) -&gt; str\n</code></pre> <p>Get the interface MAC address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>mac address of the interface</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_interface_macaddr(self, interface: str) -&gt; str:\n    \"\"\"Get the interface MAC address.\n\n    :param interface: interface name\n    :type interface: str\n    :return: mac address of the interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_macaddr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_mask","title":"get_interface_mask  <code>abstractmethod</code>","text":"<pre><code>get_interface_mask(interface: str) -&gt; str\n</code></pre> <p>Get the subnet mask of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>str</code> <p>subnet mask of interface</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_interface_mask(self, interface: str) -&gt; str:\n    \"\"\"Get the subnet mask of the interface.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: subnet mask of interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_mask(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_mtu_size","title":"get_interface_mtu_size  <code>abstractmethod</code>","text":"<pre><code>get_interface_mtu_size(interface: str) -&gt; int\n</code></pre> <p>Get the MTU size of the interface in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>int</code> <p>size of the MTU in bytes</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_interface_mtu_size(self, interface: str) -&gt; int:\n    \"\"\"Get the MTU size of the interface in bytes.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: size of the MTU in bytes\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_interface_mtu_size(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_iperf_logs","title":"get_iperf_logs  <code>abstractmethod</code>","text":"<pre><code>get_iperf_logs(log_file: str) -&gt; str\n</code></pre> <p>Read the file output for traffic flow.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>iperf log file path</p> required <p>Returns:</p> Type Description <code>str</code> <p>traffic flow logs</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_iperf_logs(self, log_file: str) -&gt; str:\n    \"\"\"Read the file output for traffic flow.\n\n    :param log_file: iperf log file path\n    :type log_file: str\n    :return: traffic flow logs\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_iperf_logs(log_file)","title":"<code>log_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_network_statistics","title":"get_network_statistics  <code>abstractmethod</code>","text":"<pre><code>get_network_statistics() -&gt; (\n    dict[str, Any] | list[dict[str, Any]] | Iterator[dict[str, Any]]\n)\n</code></pre> <p>Execute netstat command to get the port status.</p> <p>Returns:</p> Type Description <code>Union[dict[str, Any], list[dict[str, Any]], Iterator[dict[str, Any]]]</code> <p>parsed output of netstat command</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_network_statistics(\n    self,\n) -&gt; dict[str, Any] | list[dict[str, Any]] | Iterator[dict[str, Any]]:\n    \"\"\"Execute netstat command to get the port status.\n\n    :return: parsed output of netstat command\n    :rtype: Union[dict[str, Any], list[dict[str, Any]], Iterator[dict[str, Any]]]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_process_id","title":"get_process_id  <code>abstractmethod</code>","text":"<pre><code>get_process_id(process_name: str) -&gt; list[str] | None\n</code></pre> <p>Return the process id to the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the process</p> required <p>Returns:</p> Type Description <code>list[str] | None</code> <p>process id if the process exist, else None</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef get_process_id(self, process_name: str) -&gt; list[str] | None:\n    \"\"\"Return the process id to the device.\n\n    :param process_name: name of the process\n    :type process_name: str\n    :return: process id if the process exist, else None\n    :rtype: list[str] | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.get_process_id(process_name)","title":"<code>process_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.hping_flood","title":"hping_flood  <code>abstractmethod</code>","text":"<pre><code>hping_flood(\n    protocol: str,\n    target: str,\n    packet_count: str,\n    extra_args: str | None = None,\n    pkt_interval: str = \"\",\n) -&gt; str\n</code></pre> <p>Validate SYN, UDP and ICMP flood operation.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>mode, for ex 'S': syn-flood '1': ping-flood (icmp) '2': udp</p> required <code>str</code> <p>target IP addr</p> required <code>str</code> <p>number of packets to be transmitted.</p> required <code>str | None</code> <p>extra arguments to be passed, defaults to None</p> <code>None</code> <code>str</code> <p>wait for X microseconds before sending next packet uX, defaults to \"\", uX for X microseconds, for example -i u1000</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef hping_flood(\n    self,\n    protocol: str,\n    target: str,\n    packet_count: str,\n    extra_args: str | None = None,\n    pkt_interval: str = \"\",\n) -&gt; str:\n    \"\"\"Validate SYN, UDP and ICMP flood operation.\n\n    :param protocol: mode, for ex 'S': syn-flood '1': ping-flood (icmp) '2': udp\n    :type protocol: str\n    :param target: target IP addr\n    :type target: str\n    :param packet_count: number of packets to be transmitted.\n    :type packet_count: str\n    :param extra_args: extra arguments to be passed, defaults to None\n    :type extra_args: str\n    :param pkt_interval: wait for X microseconds before sending next packet uX,\n        defaults to \"\", uX for X microseconds, for example -i u1000\n    :type pkt_interval: str\n    :return: command output\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.hping_flood(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.hping_flood(target)","title":"<code>target</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.hping_flood(packet_count)","title":"<code>packet_count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.hping_flood(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.hping_flood(pkt_interval)","title":"<code>pkt_interval</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.http_get","title":"http_get  <code>abstractmethod</code>","text":"<pre><code>http_get(url: str, timeout: int, options: str) -&gt; HTTPResult\n</code></pre> <p>Peform http get and return parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>url to get the response</p> required <code>int</code> <p>connection timeout for the curl command in seconds</p> required <code>str</code> <p>additional curl options</p> required <p>Returns:</p> Type Description <code>HTTPResult</code> <p>parsed http response</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef http_get(self, url: str, timeout: int, options: str) -&gt; HTTPResult:\n    \"\"\"Peform http get and return parsed result.\n\n    :param url: url to get the response\n    :type url: str\n    :param timeout: connection timeout for the curl command in seconds\n    :type timeout: int\n    :param options: additional curl options\n    :type options: str\n    :return: parsed http response\n    :rtype: HTTPResult\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.http_get(url)","title":"<code>url</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.http_get(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.http_get(options)","title":"<code>options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.is_connect_to_board_via_reverse_ssh_successful","title":"is_connect_to_board_via_reverse_ssh_successful  <code>abstractmethod</code>","text":"<pre><code>is_connect_to_board_via_reverse_ssh_successful(\n    rssh_username: str, rssh_password: str | None, reverse_ssh_port: str\n) -&gt; bool\n</code></pre> <p>Perform reverse SSH from jump server to CPE.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>username of the cpe</p> required <code>str | None</code> <p>password to connect</p> required <code>str</code> <p>the port number</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the RSSH is successful, false otherwise</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef is_connect_to_board_via_reverse_ssh_successful(\n    self,\n    rssh_username: str,\n    rssh_password: str | None,\n    reverse_ssh_port: str,\n) -&gt; bool:\n    \"\"\"Perform reverse SSH from jump server to CPE.\n\n    :param rssh_username: username of the cpe\n    :type rssh_username: str\n    :param rssh_password: password to connect\n    :type rssh_password: Optional[str]\n    :param reverse_ssh_port: the port number\n    :type reverse_ssh_port: str\n    :return: True if the RSSH is successful, false otherwise\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.is_connect_to_board_via_reverse_ssh_successful(rssh_username)","title":"<code>rssh_username</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.is_connect_to_board_via_reverse_ssh_successful(rssh_password)","title":"<code>rssh_password</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.is_connect_to_board_via_reverse_ssh_successful(reverse_ssh_port)","title":"<code>reverse_ssh_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.is_link_up","title":"is_link_up  <code>abstractmethod</code>","text":"<pre><code>is_link_up(interface: str, pattern: str = 'BROADCAST,MULTICAST,UP') -&gt; bool\n</code></pre> <p>Return the link status.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name, defaults to \"BROADCAST,MULTICAST,UP\"</p> required <code>str</code> <p>interface state</p> <code>'BROADCAST,MULTICAST,UP'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the link is up</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef is_link_up(\n    self,\n    interface: str,\n    pattern: str = \"BROADCAST,MULTICAST,UP\",\n) -&gt; bool:\n    \"\"\"Return the link status.\n\n    :param interface: interface name, defaults to \"BROADCAST,MULTICAST,UP\"\n    :type interface: str\n    :param pattern: interface state\n    :type pattern: str\n    :return: True if the link is up\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.is_link_up(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.is_link_up(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.kill_process","title":"kill_process  <code>abstractmethod</code>","text":"<pre><code>kill_process(pid: int, signal: int) -&gt; None\n</code></pre> <p>Kill the running process based on the process id.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>process id</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef kill_process(self, pid: int, signal: int) -&gt; None:\n    \"\"\"Kill the running process based on the process id.\n\n    :param pid: process id\n    :type pid: int\n    :type signal: signal number to terminate the process\n    :type signal: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.kill_process(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap","title":"nmap  <code>abstractmethod</code>","text":"<pre><code>nmap(\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict\n</code></pre> <p>Perform nmap operation on linux device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address on which nmap is performed</p> required <code>str</code> <p>type of ip eg: ipv4/ipv6</p> required <code>str | int | None</code> <p>destination port on ip, defaults to None</p> <code>None</code> <code>str | None</code> <p>specific protocol to follow eg: tcp(-sT)/udp(-sU), defaults to None</p> <code>None</code> <code>int | None</code> <p>number of port scan probe retransmissions, defaults to None</p> <code>None</code> <code>int | None</code> <p>Send packets no slower than per second, defaults to None</p> <code>None</code> <code>str | None</code> <p>other options for a nmap command, defaults to None</p> <code>None</code> <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict</code> <p>response of nmap command in xml/dict format</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>Raises exception if ip type is invalid</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef nmap(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict:\n    \"\"\"Perform nmap operation on linux device.\n\n    :param ipaddr: ip address on which nmap is performed\n    :type ipaddr: str\n    :param ip_type: type of ip eg: ipv4/ipv6\n    :type ip_type: str\n    :param port: destination port on ip, defaults to None\n    :type port: Optional[Union[str, int]], optional\n    :param protocol: specific protocol to follow eg: tcp(-sT)/udp(-sU),\n        defaults to None\n    :type protocol: Optional[str], optional\n    :param max_retries: number of port scan probe retransmissions, defaults to None\n    :type max_retries: Optional[int], optional\n    :param min_rate: Send packets no slower than per second, defaults to None\n    :type min_rate: Optional[int], optional\n    :param opts: other options for a nmap command, defaults to None\n    :type opts: str, optional\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :raises BoardfarmException: Raises exception if ip type is invalid\n    :return: response of nmap command in xml/dict format\n    :rtype: dict\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(ipaddr)","title":"<code>ipaddr</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(min_rate)","title":"<code>min_rate</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(opts)","title":"<code>opts</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.nmap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ping","title":"ping  <code>abstractmethod</code>","text":"<pre><code>ping(\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict\n</code></pre> <p>Ping remote host.</p> <p>Return True if ping has 0% loss or parsed output in JSON if json_output=True flag is provided.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ping ip</p> required <code>int</code> <p>number of ping, defaults to 4</p> <code>4</code> <code>str | None</code> <p>ping via interface, defaults to None</p> <code>None</code> <code>str</code> <p>extra ping options, defaults to \"\"</p> <code>''</code> <code>int</code> <p>timeout, defaults to 50</p> <code>50</code> <code>bool</code> <p>return ping output in dictionary format, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>bool | dict</code> <p>ping output</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef ping(  # noqa: PLR0913\n    self,\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict:\n    \"\"\"Ping remote host.\n\n    Return True if ping has 0% loss\n    or parsed output in JSON if json_output=True flag is provided.\n\n    :param ping_ip: ping ip\n    :param ping_count: number of ping, defaults to 4\n    :param ping_interface: ping via interface, defaults to None\n    :param options: extra ping options, defaults to \"\"\n    :param timeout: timeout, defaults to 50\n    :param json_output: return ping output in dictionary format, defaults to False\n    :return: ping output\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ping(ping_ip)","title":"<code>ping_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ping(ping_count)","title":"<code>ping_count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ping(ping_interface)","title":"<code>ping_interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ping(options)","title":"<code>options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ping(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.ping(json_output)","title":"<code>json_output</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.release_dhcp","title":"release_dhcp  <code>abstractmethod</code>","text":"<pre><code>release_dhcp(interface: str) -&gt; None\n</code></pre> <p>Release IPv4 of the specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef release_dhcp(self, interface: str) -&gt; None:\n    \"\"\"Release IPv4 of the specified interface.\n\n    :param interface: interface name\n    :type interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.release_dhcp(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.scp_device_file_to_local","title":"scp_device_file_to_local  <code>abstractmethod</code>","text":"<pre><code>scp_device_file_to_local(local_path: str, source_path: str) -&gt; None\n</code></pre> <p>Copy a local file from a server using SCP.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local file path</p> required <code>str</code> <p>source path</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef scp_device_file_to_local(self, local_path: str, source_path: str) -&gt; None:\n    \"\"\"Copy a local file from a server using SCP.\n\n    :param local_path: local file path\n    :param source_path: source path\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.scp_device_file_to_local(local_path)","title":"<code>local_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.scp_device_file_to_local(source_path)","title":"<code>source_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_date","title":"set_date  <code>abstractmethod</code>","text":"<pre><code>set_date(opt: str, date_string: str) -&gt; bool\n</code></pre> <p>Set the device's date and time.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>value to be changed</p> required <code>str</code> <p>Option to set the date or time or day</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if set is successful</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef set_date(self, opt: str, date_string: str) -&gt; bool:\n    \"\"\"Set the device's date and time.\n\n    :param date_string: value to be changed\n    :type date_string: str\n    :param opt: Option to set the date or time or day\n    :type opt: str\n    :return: True if set is successful\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_date(date_string)","title":"<code>date_string</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_date(opt)","title":"<code>opt</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_default_gw","title":"set_default_gw  <code>abstractmethod</code>","text":"<pre><code>set_default_gw(ip_address: IPv4Address, interface: str) -&gt; None\n</code></pre> <p>Set given IP address as default gateway address for given interface.</p> <p>Parameters:</p> Name Type Description Default <code>IPv4Address</code> <p>gateway IP address</p> required <code>str</code> <p>interface name</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef set_default_gw(self, ip_address: IPv4Address, interface: str) -&gt; None:\n    \"\"\"Set given IP address as default gateway address for given interface.\n\n    :param ip_address: gateway IP address\n    :type ip_address: IPv4Address\n    :param interface: interface name\n    :type interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_default_gw(ip_address)","title":"<code>ip_address</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_default_gw(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_link_state","title":"set_link_state  <code>abstractmethod</code>","text":"<pre><code>set_link_state(interface: str, state: str) -&gt; None\n</code></pre> <p>Set link state.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <code>str</code> <p>desired state up or down</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef set_link_state(self, interface: str, state: str) -&gt; None:\n    \"\"\"Set link state.\n\n    :param interface: name of the interface\n    :type interface: str\n    :param state: desired state up or down\n    :type state: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_link_state(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_link_state(state)","title":"<code>state</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_static_ip","title":"set_static_ip  <code>abstractmethod</code>","text":"<pre><code>set_static_ip(interface: str, ip_address: IPv4Address, netmask: IPv4Address) -&gt; None\n</code></pre> <p>Set given static IP for the LAN.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <code>IPv4Address</code> <p>static IP address</p> required <code>IPv4Address</code> <p>netmask</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef set_static_ip(\n    self,\n    interface: str,\n    ip_address: IPv4Address,\n    netmask: IPv4Address,\n) -&gt; None:\n    \"\"\"Set given static IP for the LAN.\n\n    :param interface: interface name\n    :type interface: str\n    :param ip_address: static IP address\n    :type ip_address: IPv4Address\n    :param netmask: netmask\n    :type netmask: IPv4Address\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_static_ip(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_static_ip(ip_address)","title":"<code>ip_address</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.set_static_ip(netmask)","title":"<code>netmask</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_http_service","title":"start_http_service  <code>abstractmethod</code>","text":"<pre><code>start_http_service(port: str, ip_version: str) -&gt; str\n</code></pre> <p>Start HTTP service on given port number.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>port number</p> required <code>str</code> <p>ip version, 4 - IPv4, 6 - IPv6</p> required <p>Returns:</p> Type Description <code>str</code> <p>pid number of the http service</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef start_http_service(self, port: str, ip_version: str) -&gt; str:\n    \"\"\"Start HTTP service on given port number.\n\n    :param port: port number\n    :param ip_version: ip version, 4 - IPv4, 6 - IPv6\n    :return: pid number of the http service\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_http_service(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_http_service(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_tcpdump","title":"start_tcpdump  <code>abstractmethod</code>","text":"<pre><code>start_tcpdump(\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str\n</code></pre> <p>Start tcpdump capture on given interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>inteface name where packets to be captured</p> required <code>str | None</code> <p>port number, can be a range of ports(eg: 443 or 433-443)</p> required <code>str</code> <p>pcap file name, Defaults: pkt_capture.pcap</p> <code>'pkt_capture.pcap'</code> <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})</p> <code>None</code> <code>str | None</code> <p>additional filters</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>console ouput and tcpdump process id</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on failed to start tcpdump</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef start_tcpdump(\n    self,\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str:\n    \"\"\"Start tcpdump capture on given interface.\n\n    :param interface: inteface name where packets to be captured\n    :type interface: str\n    :param port: port number, can be a range of ports(eg: 443 or 433-443)\n    :type port: str\n    :param output_file: pcap file name, Defaults: pkt_capture.pcap\n    :type output_file: str\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n    :type filters: Optional[Dict]\n    :param additional_filters: additional filters\n    :type additional_filters: Optional[str]\n    :raises ValueError: on failed to start tcpdump\n    :return: console ouput and tcpdump process id\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_tcpdump(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_tcpdump(output_file)","title":"<code>output_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_tcpdump(additional_filters)","title":"<code>additional_filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_receiver","title":"start_traffic_receiver  <code>abstractmethod</code>","text":"<pre><code>start_traffic_receiver(\n    traffic_port: int,\n    bind_to_ip: str | None = None,\n    ip_version: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]\n</code></pre> <p>Start the server on a linux device to generate traffic using iperf3.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>server port to listen on</p> required <code>str | None</code> <p>bind to the interface associated with the address host, defaults to None</p> <code>None</code> <code>int | None</code> <p>4 or 6 as it uses only IPv4 or IPv6, defaults to None</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>the process id(pid) and log file path</p> <p>Raises:</p> Type Description <code>CodeError</code> <p>raises if unable to start server</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef start_traffic_receiver(\n    self,\n    traffic_port: int,\n    bind_to_ip: str | None = None,\n    ip_version: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]:\n    \"\"\"Start the server on a linux device to generate traffic using iperf3.\n\n    :param traffic_port: server port to listen on\n    :type traffic_port: int\n    :param bind_to_ip: bind to the interface associated with\n        the address host, defaults to None\n    :type bind_to_ip: str, optional\n    :param ip_version: 4 or 6 as it uses only IPv4 or IPv6, defaults to None\n    :type ip_version: int,\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :raises CodeError: raises if unable to start server\n    :return: the process id(pid) and log file path\n    :rtype: tuple[int, str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_receiver(traffic_port)","title":"<code>traffic_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_receiver(bind_to_ip)","title":"<code>bind_to_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_receiver(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_receiver(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender","title":"start_traffic_sender  <code>abstractmethod</code>","text":"<pre><code>start_traffic_sender(\n    host: str,\n    traffic_port: int,\n    bandwidth: int | None = None,\n    bind_to_ip: str | None = None,\n    direction: str | None = None,\n    ip_version: int | None = None,\n    udp_protocol: bool = False,\n    time: int = 10,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]\n</code></pre> <p>Start traffic on a linux client using iperf3.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>a host to run in client mode</p> required <code>int</code> <p>server port to connect to</p> required <code>int | None</code> <p>bandwidth(mbps) at which the traffic has to be generated, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the address host, defaults to None</p> <code>None</code> <code>str | None</code> <p><code>--reverse</code> to run in reverse mode (server sends, client receives) or <code>--bidir</code> to run in bidirectional mode, defaults to None</p> <code>None</code> <code>int | None</code> <p>4 or 6 as it uses only IPv4 or IPv6, defaults to None</p> <code>None</code> <code>bool</code> <p>use UDP rather than TCP, defaults to False</p> <code>False</code> <code>int</code> <p>time in seconds to transmit for, defaults to 10</p> <code>10</code> <code>int | None</code> <p>client port from where the traffic is getting started</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>the process id(pid) and log file path</p> <p>Raises:</p> Type Description <code>CodeError</code> <p>raises if unable to start server</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef start_traffic_sender(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    host: str,\n    traffic_port: int,\n    bandwidth: int | None = None,\n    bind_to_ip: str | None = None,\n    direction: str | None = None,\n    ip_version: int | None = None,\n    udp_protocol: bool = False,\n    time: int = 10,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]:\n    \"\"\"Start traffic on a linux client using iperf3.\n\n    :param host: a host to run in client mode\n    :type host: str\n    :param traffic_port: server port to connect to\n    :type traffic_port: int\n    :param bandwidth: bandwidth(mbps) at which the traffic\n        has to be generated, defaults to None\n    :type bandwidth: Optional[int], optional\n    :param bind_to_ip: bind to the interface associated with\n        the address host, defaults to None\n    :type bind_to_ip: Optional[str], optional\n    :param direction: `--reverse` to run in reverse mode\n        (server sends, client receives) or `--bidir` to run in\n        bidirectional mode, defaults to None\n    :type direction: Optional[str], optional\n    :param ip_version: 4 or 6 as it uses only IPv4 or IPv6, defaults to None\n    :type ip_version: int, optional\n    :param udp_protocol: use UDP rather than TCP, defaults to False\n    :type udp_protocol: bool\n    :param time: time in seconds to transmit for, defaults to 10\n    :type time: int\n    :param client_port: client port from where the traffic is getting started\n    :type client_port: int | None\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :raises CodeError: raises if unable to start server\n    :return: the process id(pid) and log file path\n    :rtype: tuple[int, str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(host)","title":"<code>host</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(traffic_port)","title":"<code>traffic_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(bandwidth)","title":"<code>bandwidth</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(bind_to_ip)","title":"<code>bind_to_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(direction)","title":"<code>direction</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(time)","title":"<code>time</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(client_port)","title":"<code>client_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.start_traffic_sender(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.stop_http_service","title":"stop_http_service  <code>abstractmethod</code>","text":"<pre><code>stop_http_service(port: str) -&gt; None\n</code></pre> <p>Stop http service running on given port.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>port number</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef stop_http_service(self, port: str) -&gt; None:\n    \"\"\"Stop http service running on given port.\n\n    :param port: port number\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.stop_http_service(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.stop_tcpdump","title":"stop_tcpdump  <code>abstractmethod</code>","text":"<pre><code>stop_tcpdump(process_id: str) -&gt; None\n</code></pre> <p>Stop tcpdump capture.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump process id</p> required Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef stop_tcpdump(self, process_id: str) -&gt; None:\n    \"\"\"Stop tcpdump capture.\n\n    :param process_id: tcpdump process id\n    :type process_id: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.stop_tcpdump(process_id)","title":"<code>process_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.stop_traffic","title":"stop_traffic  <code>abstractmethod</code>","text":"<pre><code>stop_traffic(pid: int | None = None) -&gt; bool\n</code></pre> <p>Stop the iPerf3 process for a specific PID or killall.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>process ID for a iPerf3 service either for reciever or sender, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if process is stopped else False</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef stop_traffic(self, pid: int | None = None) -&gt; bool:\n    \"\"\"Stop the iPerf3 process for a specific PID or killall.\n\n    :param pid: process ID for a iPerf3 service either for reciever or sender,\n        defaults to None\n    :type pid: int | None\n    :return: True if process is stopped else False\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.stop_traffic(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tcpdump_capture","title":"tcpdump_capture  <code>abstractmethod</code>","text":"<pre><code>tcpdump_capture(\n    fname: str, interface: str = \"any\", additional_args: str | None = None\n) -&gt; Generator[str]\n</code></pre> <p>Capture packets from specified interface.</p> <p>Packet capture using tcpdump utility at a specified interface.</p> <p>:yield: process id of tcpdump process</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file where packet captures will be stored</p> required <code>str</code> <p>name of the interface, defaults to \"any\"</p> <code>'any'</code> <code>str | None</code> <p>argument arguments to tcpdump executable</p> <code>None</code> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@contextmanager\n@abstractmethod\ndef tcpdump_capture(\n    self,\n    fname: str,\n    interface: str = \"any\",\n    additional_args: str | None = None,\n) -&gt; Generator[str]:\n    \"\"\"Capture packets from specified interface.\n\n    Packet capture using tcpdump utility at a specified interface.\n\n    :param fname: name of the file where packet captures will be stored\n    :param interface: name of the interface, defaults to \"any\"\n    :param additional_args: argument arguments to tcpdump executable\n    :yield: process id of tcpdump process\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tcpdump_capture(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tcpdump_capture(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tcpdump_capture(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tshark_read_pcap","title":"tshark_read_pcap  <code>abstractmethod</code>","text":"<pre><code>tshark_read_pcap(\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str\n</code></pre> <p>Read packet captures from an existing file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file in which captures are saved</p> required <code>str | None</code> <p>additional arguments for tshark command</p> <code>None</code> <code>int</code> <p>time out for tshark command to be executed, defaults to 30</p> <code>30</code> <code>bool</code> <p>If True remove the packet capture file after reading it</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>return tshark read command console output</p> Source code in <code>boardfarm3/templates/wan.py</code> <pre><code>@abstractmethod\ndef tshark_read_pcap(\n    self,\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str:\n    \"\"\"Read packet captures from an existing file.\n\n    :param fname: name of the file in which captures are saved\n    :param additional_args: additional arguments for tshark command\n    :param timeout: time out for tshark command to be executed, defaults to 30\n    :param rm_pcap: If True remove the packet capture file after reading it\n    :return: return tshark read command console output\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tshark_read_pcap(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tshark_read_pcap(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tshark_read_pcap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wan.WAN.tshark_read_pcap(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan","title":"wlan","text":"<p>Boardfarm WLAN device template.</p> <p>Classes:</p> Name Description <code>WLAN</code> <p>Boardfarm WLAN device template.</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN","title":"WLAN","text":"<p>Boardfarm WLAN device template.</p> <p>Methods:</p> Name Description <code>change_wifi_region</code> <p>Change the region of the wifi.</p> <code>delete_file</code> <p>Delete the file from the device.</p> <code>dhcp_release_wlan_iface</code> <p>DHCP release the wifi interface.</p> <code>disable_ipv6</code> <p>Disable ipv6 on the connected client interface.</p> <code>disable_monitor_mode</code> <p>Disable monitor mode on WLAN interface.</p> <code>disable_wifi</code> <p>Disabling the wifi interface.</p> <code>disconnect_wpa</code> <p>Disconnect the wpa supplicant initialisation.</p> <code>enable_ipv6</code> <p>Enable ipv6 on the connected client interface.</p> <code>enable_monitor_mode</code> <p>Enable monitor mode on WLAN interface.</p> <code>enable_wifi</code> <p>Enable the wifi interface.</p> <code>get_date</code> <p>Get the system date and time.</p> <code>get_hostname</code> <p>Get the hostname of the device.</p> <code>get_interface_ipv4addr</code> <p>Return ipv4 address of the interface.</p> <code>get_interface_ipv6addr</code> <p>Return ipv4 address of the interface.</p> <code>get_interface_macaddr</code> <p>Get the interface MAC address.</p> <code>get_interface_mask</code> <p>Get the subnet mask of the interface.</p> <code>get_interface_mtu_size</code> <p>Get the MTU size of the interface in bytes.</p> <code>get_iperf_logs</code> <p>Read the file output for traffic flow.</p> <code>get_process_id</code> <p>Return the process id to the device.</p> <code>is_monitor_mode_enabled</code> <p>Check if monitor mode is enabled on WLAN interface.</p> <code>is_wlan_connected</code> <p>Verify wifi is in the connected state.</p> <code>iwlist_supported_channels</code> <p>List of wifi client support channels.</p> <code>kill_process</code> <p>Kill the running process based on the process id.</p> <code>list_wifi_ssids</code> <p>Scan for available WiFi SSIDs.</p> <code>nmap</code> <p>Perform nmap operation on linux device.</p> <code>ping</code> <p>Ping remote host.</p> <code>release_dhcp</code> <p>Release IPv4 of the specified interface.</p> <code>release_ipv6</code> <p>Release IPv6 of the specified interface.</p> <code>renew_dhcp</code> <p>Renew IPv4 of the specified interface by restart of the IPv4 dhclient.</p> <code>renew_ipv6</code> <p>Renew IPv6 of the specified interface.</p> <code>reset_wifi_iface</code> <p>Disable and enable wifi interface.</p> <code>scp_device_file_to_local</code> <p>Copy a local file from a server using SCP.</p> <code>send_mldv2_report</code> <p>Send an MLDv2 report with desired multicast record.</p> <code>set_date</code> <p>Set the device's date and time.</p> <code>set_link_state</code> <p>Set link state.</p> <code>set_wlan_scan_channel</code> <p>Change wifi client scan channel.</p> <code>start_ipv4_wlan_client</code> <p>Restart ipv4 dhclient to obtain an IP.</p> <code>start_ipv6_wlan_client</code> <p>Restart ipv6 dhclient to obtain IP.</p> <code>start_tcpdump</code> <p>Start tcpdump capture on given interface.</p> <code>start_traffic_receiver</code> <p>Start the server on a linux device to generate traffic using iperf3.</p> <code>start_traffic_sender</code> <p>Start traffic on a linux client using iperf3.</p> <code>stop_tcpdump</code> <p>Stop tcpdump capture.</p> <code>stop_traffic</code> <p>Stop the iPerf3 process for a specific PID or killall.</p> <code>tcpdump_capture</code> <p>Capture packets from specified interface.</p> <code>tshark_read_pcap</code> <p>Read packet captures from an existing file.</p> <code>wifi_client_connect</code> <p>Scan for SSID and verify wifi connectivity.</p> <code>wifi_disconnect</code> <p>Disconnect wifi connectivity.</p> <p>Attributes:</p> Name Type Description <code>authentication</code> <code>str</code> <p>Wifi authentication through which wlan device should connect.</p> <code>band</code> <code>str</code> <p>Wifi band supported by the wlan device.</p> <code>console</code> <code>BoardfarmPexpect</code> <p>Returns WLAN console.</p> <code>http_proxy</code> <code>str</code> <p>SOCKS5 dante proxy address.</p> <code>iface_dut</code> <code>str</code> <p>Name of the interface that is connected to DUT.</p> <code>ipv4_addr</code> <code>str</code> <p>Return the IPv4 address on IFACE facing DUT.</p> <code>ipv6_addr</code> <code>str</code> <p>Return the IPv6 address on IFACE facing DUT.</p> <code>lan_gateway</code> <code>IPv4Address</code> <p>WLAN gateway address.</p> <code>lan_network</code> <code>IPv4Network</code> <p>IPv4 WLAN Network.</p> <code>multicast</code> <code>Multicast</code> <p>Return multicast component instance.</p> <code>network</code> <code>str</code> <p>Wifi network to which wlan device should connect.</p> <code>protocol</code> <code>str</code> <p>Wifi protocol using which wlan device should connect.</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.authentication","title":"authentication  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>authentication: str\n</code></pre> <p>Wifi authentication through which wlan device should connect.</p> <p>Returns:</p> Type Description <code>str</code> <p>WPA-PSK, WPA2, etc</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.band","title":"band  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>band: str\n</code></pre> <p>Wifi band supported by the wlan device.</p> <p>Returns:</p> Type Description <code>str</code> <p>type of band i.e. 2.4, 5, dual</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.console","title":"console  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>console: BoardfarmPexpect\n</code></pre> <p>Returns WLAN console.</p> <p>Returns:</p> Type Description <code>BoardfarmPexpect</code> <p>console</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.http_proxy","title":"http_proxy  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>http_proxy: str\n</code></pre> <p>SOCKS5 dante proxy address.</p> <p>Returns:</p> Type Description <code>str</code> <p>http://{proxy_ip}:{proxy_port}/</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.iface_dut","title":"iface_dut  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>iface_dut: str\n</code></pre> <p>Name of the interface that is connected to DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>interface</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ipv4_addr","title":"ipv4_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv4_addr: str\n</code></pre> <p>Return the IPv4 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv4 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ipv6_addr","title":"ipv6_addr  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>ipv6_addr: str\n</code></pre> <p>Return the IPv6 address on IFACE facing DUT.</p> <p>Returns:</p> Type Description <code>str</code> <p>IPv6 address in string format.</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.lan_gateway","title":"lan_gateway  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_gateway: IPv4Address\n</code></pre> <p>WLAN gateway address.</p> <p>Returns:</p> Type Description <code>IPv4Address</code> <p>Ipv4 wlan gateway address</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.lan_network","title":"lan_network  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lan_network: IPv4Network\n</code></pre> <p>IPv4 WLAN Network.</p> <p>Returns:</p> Type Description <code>IPv4Network</code> <p>IPv4 address network</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.multicast","title":"multicast  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>multicast: Multicast\n</code></pre> <p>Return multicast component instance.</p> <p>Returns:</p> Type Description <code>Multicast</code> <p>multicast component instance</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.network","title":"network  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>network: str\n</code></pre> <p>Wifi network to which wlan device should connect.</p> <p>Returns:</p> Type Description <code>str</code> <p>type of network i.e. private, guest, community</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.protocol","title":"protocol  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>protocol: str\n</code></pre> <p>Wifi protocol using which wlan device should connect.</p> <p>Returns:</p> Type Description <code>str</code> <p>802.11ac, 802.11, etc</p>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.change_wifi_region","title":"change_wifi_region  <code>abstractmethod</code>","text":"<pre><code>change_wifi_region(country: str) -&gt; None\n</code></pre> <p>Change the region of the wifi.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>region to be set</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef change_wifi_region(self, country: str) -&gt; None:\n    \"\"\"Change the region of the wifi.\n\n    :param country: region to be set\n    :type country: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.change_wifi_region(country)","title":"<code>country</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.delete_file","title":"delete_file  <code>abstractmethod</code>","text":"<pre><code>delete_file(filename: str) -&gt; None\n</code></pre> <p>Delete the file from the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file with absolute path</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef delete_file(self, filename: str) -&gt; None:\n    \"\"\"Delete the file from the device.\n\n    :param filename: name of the file with absolute path\n    :type filename: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.delete_file(filename)","title":"<code>filename</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.dhcp_release_wlan_iface","title":"dhcp_release_wlan_iface  <code>abstractmethod</code>","text":"<pre><code>dhcp_release_wlan_iface() -&gt; None\n</code></pre> <p>DHCP release the wifi interface.</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef dhcp_release_wlan_iface(self) -&gt; None:\n    \"\"\"DHCP release the wifi interface.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.disable_ipv6","title":"disable_ipv6  <code>abstractmethod</code>","text":"<pre><code>disable_ipv6() -&gt; None\n</code></pre> <p>Disable ipv6 on the connected client interface.</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef disable_ipv6(self) -&gt; None:\n    \"\"\"Disable ipv6 on the connected client interface.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.disable_monitor_mode","title":"disable_monitor_mode  <code>abstractmethod</code>","text":"<pre><code>disable_monitor_mode() -&gt; None\n</code></pre> <p>Disable monitor mode on WLAN interface.</p> <p>Set the type to managed</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef disable_monitor_mode(self) -&gt; None:\n    \"\"\"Disable monitor mode on WLAN interface.\n\n    Set the type to managed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.disable_wifi","title":"disable_wifi  <code>abstractmethod</code>","text":"<pre><code>disable_wifi() -&gt; None\n</code></pre> <p>Disabling the wifi interface.</p> <p>Set the interface link to \"down\"</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef disable_wifi(self) -&gt; None:\n    \"\"\"Disabling the wifi interface.\n\n    Set the interface link to \"down\"\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.disconnect_wpa","title":"disconnect_wpa  <code>abstractmethod</code>","text":"<pre><code>disconnect_wpa() -&gt; None\n</code></pre> <p>Disconnect the wpa supplicant initialisation.</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef disconnect_wpa(self) -&gt; None:\n    \"\"\"Disconnect the wpa supplicant initialisation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.enable_ipv6","title":"enable_ipv6  <code>abstractmethod</code>","text":"<pre><code>enable_ipv6() -&gt; None\n</code></pre> <p>Enable ipv6 on the connected client interface.</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef enable_ipv6(self) -&gt; None:\n    \"\"\"Enable ipv6 on the connected client interface.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.enable_monitor_mode","title":"enable_monitor_mode  <code>abstractmethod</code>","text":"<pre><code>enable_monitor_mode() -&gt; None\n</code></pre> <p>Enable monitor mode on WLAN interface.</p> <p>Set the type to monitor</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef enable_monitor_mode(self) -&gt; None:\n    \"\"\"Enable monitor mode on WLAN interface.\n\n    Set the type to monitor\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.enable_wifi","title":"enable_wifi  <code>abstractmethod</code>","text":"<pre><code>enable_wifi() -&gt; None\n</code></pre> <p>Enable the wifi interface.</p> <p>Set the interface link to \"up\"</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef enable_wifi(self) -&gt; None:\n    \"\"\"Enable the wifi interface.\n\n    Set the interface link to \"up\"\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_date","title":"get_date  <code>abstractmethod</code>","text":"<pre><code>get_date() -&gt; str | None\n</code></pre> <p>Get the system date and time.</p> <p>.. code-block:: python</p> <pre><code># example output\ndonderdag, mei 23, 2024 14:23:39\n</code></pre> <p>Returns:</p> Type Description <code>str | None</code> <p>date</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_date(self) -&gt; str | None:\n    \"\"\"Get the system date and time.\n\n    .. code-block:: python\n\n        # example output\n        donderdag, mei 23, 2024 14:23:39\n\n\n    :return: date\n    :rtype: str | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_hostname","title":"get_hostname  <code>abstractmethod</code>","text":"<pre><code>get_hostname() -&gt; str\n</code></pre> <p>Get the hostname of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>hostname of the device</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_hostname(self) -&gt; str:\n    \"\"\"Get the hostname of the device.\n\n    :return: hostname of the device\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_ipv4addr","title":"get_interface_ipv4addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv4addr(interface: str) -&gt; str\n</code></pre> <p>Return ipv4 address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv4 of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv4 is not found</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv4addr(self, interface: str) -&gt; str:\n    \"\"\"Return ipv4 address of the interface.\n\n    :param interface: interface name\n    :type interface: str\n    :raises BoardfarmException: in case IPv4 is not found\n    :return: IPv4 of the interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_ipv4addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_ipv6addr","title":"get_interface_ipv6addr  <code>abstractmethod</code>","text":"<pre><code>get_interface_ipv6addr(interface: str) -&gt; str\n</code></pre> <p>Return ipv4 address of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>IPv6 of the interface</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>in case IPv6 is not found</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_interface_ipv6addr(self, interface: str) -&gt; str:\n    \"\"\"Return ipv4 address of the interface.\n\n    :param interface: interface name\n    :type interface: str\n    :raises BoardfarmException: in case IPv6 is not found\n    :return: IPv6 of the interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_ipv6addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_macaddr","title":"get_interface_macaddr  <code>abstractmethod</code>","text":"<pre><code>get_interface_macaddr(interface: str) -&gt; str\n</code></pre> <p>Get the interface MAC address.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>mac address of the interface</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_interface_macaddr(self, interface: str) -&gt; str:\n    \"\"\"Get the interface MAC address.\n\n    :param interface: interface name\n    :type interface: str\n    :return: mac address of the interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_macaddr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_mask","title":"get_interface_mask  <code>abstractmethod</code>","text":"<pre><code>get_interface_mask(interface: str) -&gt; str\n</code></pre> <p>Get the subnet mask of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>str</code> <p>subnet mask of interface</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_interface_mask(self, interface: str) -&gt; str:\n    \"\"\"Get the subnet mask of the interface.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: subnet mask of interface\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_mask(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_mtu_size","title":"get_interface_mtu_size  <code>abstractmethod</code>","text":"<pre><code>get_interface_mtu_size(interface: str) -&gt; int\n</code></pre> <p>Get the MTU size of the interface in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <p>Returns:</p> Type Description <code>int</code> <p>size of the MTU in bytes</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_interface_mtu_size(self, interface: str) -&gt; int:\n    \"\"\"Get the MTU size of the interface in bytes.\n\n    :param interface: name of the interface\n    :type interface: str\n    :return: size of the MTU in bytes\n    :rtype: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_interface_mtu_size(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_iperf_logs","title":"get_iperf_logs  <code>abstractmethod</code>","text":"<pre><code>get_iperf_logs(log_file: str) -&gt; str\n</code></pre> <p>Read the file output for traffic flow.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>iperf log file path</p> required <p>Returns:</p> Type Description <code>str</code> <p>traffic flow logs</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_iperf_logs(self, log_file: str) -&gt; str:\n    \"\"\"Read the file output for traffic flow.\n\n    :param log_file: iperf log file path\n    :type log_file: str\n    :return: traffic flow logs\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_iperf_logs(log_file)","title":"<code>log_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_process_id","title":"get_process_id  <code>abstractmethod</code>","text":"<pre><code>get_process_id(process_name: str) -&gt; list[str] | None\n</code></pre> <p>Return the process id to the device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the process</p> required <p>Returns:</p> Type Description <code>list[str] | None</code> <p>process id if the process exist, else None</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef get_process_id(self, process_name: str) -&gt; list[str] | None:\n    \"\"\"Return the process id to the device.\n\n    :param process_name: name of the process\n    :type process_name: str\n    :return: process id if the process exist, else None\n    :rtype: list[str] | None\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.get_process_id(process_name)","title":"<code>process_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.is_monitor_mode_enabled","title":"is_monitor_mode_enabled  <code>abstractmethod</code>","text":"<pre><code>is_monitor_mode_enabled() -&gt; bool\n</code></pre> <p>Check if monitor mode is enabled on WLAN interface.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Status of monitor mode</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef is_monitor_mode_enabled(self) -&gt; bool:\n    \"\"\"Check if monitor mode is enabled on WLAN interface.\n\n    :return: Status of monitor mode\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.is_wlan_connected","title":"is_wlan_connected  <code>abstractmethod</code>","text":"<pre><code>is_wlan_connected() -&gt; bool\n</code></pre> <p>Verify wifi is in the connected state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if wlan is connected, False otherwise</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef is_wlan_connected(self) -&gt; bool:\n    \"\"\"Verify wifi is in the connected state.\n\n    :return: True if wlan is connected, False otherwise\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.iwlist_supported_channels","title":"iwlist_supported_channels  <code>abstractmethod</code>","text":"<pre><code>iwlist_supported_channels(wifi_band: str) -&gt; list[str]\n</code></pre> <p>List of wifi client support channels.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>wifi frequency ['2.4' or '5']</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list of channel in wifi mode</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef iwlist_supported_channels(self, wifi_band: str) -&gt; list[str]:\n    \"\"\"List of wifi client support channels.\n\n    :param wifi_band: wifi frequency ['2.4' or '5']\n    :type wifi_band: str\n    :return: list of channel in wifi mode\n    :rtype: list[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.iwlist_supported_channels(wifi_band)","title":"<code>wifi_band</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.kill_process","title":"kill_process  <code>abstractmethod</code>","text":"<pre><code>kill_process(pid: int, signal: int) -&gt; None\n</code></pre> <p>Kill the running process based on the process id.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>process id</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef kill_process(self, pid: int, signal: int) -&gt; None:\n    \"\"\"Kill the running process based on the process id.\n\n    :param pid: process id\n    :type pid: int\n    :type signal: signal number to terminate the process\n    :type signal: int\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.kill_process(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.list_wifi_ssids","title":"list_wifi_ssids  <code>abstractmethod</code>","text":"<pre><code>list_wifi_ssids() -&gt; list[str]\n</code></pre> <p>Scan for available WiFi SSIDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of Wi-FI SSIDs</p> <p>Raises:</p> Type Description <code>CodeError</code> <p>WLAN card was blocked due to some process.</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef list_wifi_ssids(self) -&gt; list[str]:\n    \"\"\"Scan for available WiFi SSIDs.\n\n    :raises CodeError: WLAN card was blocked due to some process.\n    :return: List of Wi-FI SSIDs\n    :rtype: list[str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap","title":"nmap  <code>abstractmethod</code>","text":"<pre><code>nmap(\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict\n</code></pre> <p>Perform nmap operation on linux device.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ip address on which nmap is performed</p> required <code>str</code> <p>type of ip eg: ipv4/ipv6</p> required <code>str | int | None</code> <p>destination port on ip, defaults to None</p> <code>None</code> <code>str | None</code> <p>specific protocol to follow eg: tcp(-sT)/udp(-sU), defaults to None</p> <code>None</code> <code>int | None</code> <p>number of port scan probe retransmissions, defaults to None</p> <code>None</code> <code>int | None</code> <p>Send packets no slower than per second, defaults to None</p> <code>None</code> <code>str | None</code> <p>other options for a nmap command, defaults to None</p> <code>None</code> <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict</code> <p>response of nmap command in xml/dict format</p> <p>Raises:</p> Type Description <code>BoardfarmException</code> <p>Raises exception if ip type is invalid</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef nmap(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    ipaddr: str,\n    ip_type: str,\n    port: str | int | None = None,\n    protocol: str | None = None,\n    max_retries: int | None = None,\n    min_rate: int | None = None,\n    opts: str | None = None,\n    timeout: int = 30,\n) -&gt; dict:\n    \"\"\"Perform nmap operation on linux device.\n\n    :param ipaddr: ip address on which nmap is performed\n    :type ipaddr: str\n    :param ip_type: type of ip eg: ipv4/ipv6\n    :type ip_type: str\n    :param port: destination port on ip, defaults to None\n    :type port: Optional[Union[str, int]], optional\n    :param protocol: specific protocol to follow eg: tcp(-sT)/udp(-sU),\n        defaults to None\n    :type protocol: Optional[str], optional\n    :param max_retries: number of port scan probe retransmissions, defaults to None\n    :type max_retries: Optional[int], optional\n    :param min_rate: Send packets no slower than per second, defaults to None\n    :type min_rate: Optional[int], optional\n    :param opts: other options for a nmap command, defaults to None\n    :type opts: str, optional\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :raises BoardfarmException: Raises exception if ip type is invalid\n    :return: response of nmap command in xml/dict format\n    :rtype: dict\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(ipaddr)","title":"<code>ipaddr</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(min_rate)","title":"<code>min_rate</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(opts)","title":"<code>opts</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.nmap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ping","title":"ping  <code>abstractmethod</code>","text":"<pre><code>ping(\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict[str, Any]\n</code></pre> <p>Ping remote host.</p> <p>Return True if ping has 0% loss or parsed output in JSON if json_output=True flag is provided.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>ping IP</p> required <code>int</code> <p>number of ping, defaults to 4</p> <code>4</code> <code>str | None</code> <p>ping via interface, defaults to None</p> <code>None</code> <code>str</code> <p>extra ping options, defaults to \"\"</p> <code>''</code> <code>int</code> <p>timeout, defaults to 50</p> <code>50</code> <code>bool</code> <p>return ping output in dictionary format, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>bool | dict[str, Any]</code> <p>ping output</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef ping(  # noqa: PLR0913\n    self,\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    options: str = \"\",\n    timeout: int = 50,\n    json_output: bool = False,\n) -&gt; bool | dict[str, Any]:\n    \"\"\"Ping remote host.\n\n    Return True if ping has 0% loss\n    or parsed output in JSON if json_output=True flag is provided.\n\n    :param ping_ip: ping IP\n    :type ping_ip: str\n    :param ping_count: number of ping, defaults to 4\n    :type ping_count: int\n    :param ping_interface: ping via interface, defaults to None\n    :type ping_interface: str\n    :param options: extra ping options, defaults to \"\"\n    :type options: str\n    :param timeout: timeout, defaults to 50\n    :type timeout: int\n    :param json_output: return ping output in dictionary format, defaults to False\n    :type json_output: bool\n    :return: ping output\n    :rtype: bool | dict[str, Any]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ping(ping_ip)","title":"<code>ping_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ping(ping_count)","title":"<code>ping_count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ping(ping_interface)","title":"<code>ping_interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ping(options)","title":"<code>options</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ping(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.ping(json_output)","title":"<code>json_output</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.release_dhcp","title":"release_dhcp  <code>abstractmethod</code>","text":"<pre><code>release_dhcp(interface: str) -&gt; None\n</code></pre> <p>Release IPv4 of the specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef release_dhcp(self, interface: str) -&gt; None:\n    \"\"\"Release IPv4 of the specified interface.\n\n    :param interface: interface name\n    :type interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.release_dhcp(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.release_ipv6","title":"release_ipv6  <code>abstractmethod</code>","text":"<pre><code>release_ipv6(interface: str, stateless: bool = False) -&gt; None\n</code></pre> <p>Release IPv6 of the specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <code>bool</code> <p>run command with -S or -6 options. -6 by default</p> <code>False</code> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef release_ipv6(self, interface: str, stateless: bool = False) -&gt; None:\n    \"\"\"Release IPv6 of the specified interface.\n\n    :param interface: interface name\n    :type interface: str\n    :param stateless: run command with -S or -6 options. -6 by default\n    :type stateless: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.release_ipv6(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.release_ipv6(stateless)","title":"<code>stateless</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.renew_dhcp","title":"renew_dhcp  <code>abstractmethod</code>","text":"<pre><code>renew_dhcp(interface: str) -&gt; None\n</code></pre> <p>Renew IPv4 of the specified interface by restart of the IPv4 dhclient.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef renew_dhcp(self, interface: str) -&gt; None:\n    \"\"\"Renew IPv4 of the specified interface by restart of the IPv4 dhclient.\n\n    :param interface: interface name\n    :type interface: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.renew_dhcp(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.renew_ipv6","title":"renew_ipv6  <code>abstractmethod</code>","text":"<pre><code>renew_ipv6(interface: str, stateless: bool = False) -&gt; None\n</code></pre> <p>Renew IPv6 of the specified interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>interface name</p> required <code>bool</code> <p>run command with -S or -6 options. -6 by default</p> <code>False</code> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef renew_ipv6(self, interface: str, stateless: bool = False) -&gt; None:\n    \"\"\"Renew IPv6 of the specified interface.\n\n    :param interface: interface name\n    :type interface: str\n    :param stateless: run command with -S or -6 options. -6 by default\n    :type stateless: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.renew_ipv6(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.renew_ipv6(stateless)","title":"<code>stateless</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.reset_wifi_iface","title":"reset_wifi_iface  <code>abstractmethod</code>","text":"<pre><code>reset_wifi_iface() -&gt; None\n</code></pre> <p>Disable and enable wifi interface.</p> <p>i.e., set the interface link to \"down\" and then to \"up\" This calls the disable wifi and enable wifi methods</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef reset_wifi_iface(self) -&gt; None:\n    \"\"\"Disable and enable wifi interface.\n\n    i.e., set the interface link to \"down\" and then to \"up\"\n    This calls the disable wifi and enable wifi methods\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.scp_device_file_to_local","title":"scp_device_file_to_local  <code>abstractmethod</code>","text":"<pre><code>scp_device_file_to_local(local_path: str, source_path: str) -&gt; None\n</code></pre> <p>Copy a local file from a server using SCP.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>local file path</p> required <code>str</code> <p>source path</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef scp_device_file_to_local(self, local_path: str, source_path: str) -&gt; None:\n    \"\"\"Copy a local file from a server using SCP.\n\n    :param local_path: local file path\n    :param source_path: source path\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.scp_device_file_to_local(local_path)","title":"<code>local_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.scp_device_file_to_local(source_path)","title":"<code>source_path</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.send_mldv2_report","title":"send_mldv2_report  <code>abstractmethod</code>","text":"<pre><code>send_mldv2_report(mcast_group_record: MulticastGroupRecord, count: int) -&gt; None\n</code></pre> <p>Send an MLDv2 report with desired multicast record.</p> <p>Multicast source and group must be IPv6 addresses. Multicast sources need to be non-multicast addresses and group address needs to be a multicast address.</p> <p>Implementation relies on a custom send_mld_report script based on scapy.</p> <p>Parameters:</p> Name Type Description Default <code>MulticastGroupRecord</code> <p>MLDv2 multicast group record</p> required <code>int</code> <p>num of packets to send in 1s interval</p> required <p>Raises:</p> Type Description <code>CodeError</code> <p>if send_mld_report command fails</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef send_mldv2_report(\n    self, mcast_group_record: MulticastGroupRecord, count: int\n) -&gt; None:\n    \"\"\"Send an MLDv2 report with desired multicast record.\n\n    Multicast source and group must be IPv6 addresses.\n    Multicast sources need to be non-multicast addresses and\n    group address needs to be a multicast address.\n\n    Implementation relies on a custom send_mld_report\n    script based on scapy.\n\n    :param mcast_group_record: MLDv2 multicast group record\n    :type mcast_group_record: MulticastGroupRecord\n    :param count: num of packets to send in 1s interval\n    :type count: int\n    :raises CodeError: if send_mld_report command fails\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.send_mldv2_report(mcast_group_record)","title":"<code>mcast_group_record</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.send_mldv2_report(count)","title":"<code>count</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_date","title":"set_date  <code>abstractmethod</code>","text":"<pre><code>set_date(opt: str, date_string: str) -&gt; bool\n</code></pre> <p>Set the device's date and time.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>value to be changed</p> required <code>str</code> <p>Option to set the date or time or day</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if set is successful</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef set_date(self, opt: str, date_string: str) -&gt; bool:\n    \"\"\"Set the device's date and time.\n\n    :param date_string: value to be changed\n    :type date_string: str\n    :param opt: Option to set the date or time or day\n    :type opt: str\n    :return: True if set is successful\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_date(date_string)","title":"<code>date_string</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_date(opt)","title":"<code>opt</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_link_state","title":"set_link_state  <code>abstractmethod</code>","text":"<pre><code>set_link_state(interface: str, state: str) -&gt; None\n</code></pre> <p>Set link state.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the interface</p> required <code>str</code> <p>desired state up or down</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef set_link_state(self, interface: str, state: str) -&gt; None:\n    \"\"\"Set link state.\n\n    :param interface: name of the interface\n    :type interface: str\n    :param state: desired state up or down\n    :type state: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_link_state(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_link_state(state)","title":"<code>state</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_wlan_scan_channel","title":"set_wlan_scan_channel  <code>abstractmethod</code>","text":"<pre><code>set_wlan_scan_channel(channel: str) -&gt; None\n</code></pre> <p>Change wifi client scan channel.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>wifi channel</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef set_wlan_scan_channel(self, channel: str) -&gt; None:\n    \"\"\"Change wifi client scan channel.\n\n    :param channel: wifi channel\n    :type channel: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.set_wlan_scan_channel(channel)","title":"<code>channel</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_ipv4_wlan_client","title":"start_ipv4_wlan_client  <code>abstractmethod</code>","text":"<pre><code>start_ipv4_wlan_client() -&gt; bool\n</code></pre> <p>Restart ipv4 dhclient to obtain an IP.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if renew is success else False</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef start_ipv4_wlan_client(self) -&gt; bool:\n    \"\"\"Restart ipv4 dhclient to obtain an IP.\n\n    :return: True if renew is success else False\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_ipv6_wlan_client","title":"start_ipv6_wlan_client  <code>abstractmethod</code>","text":"<pre><code>start_ipv6_wlan_client() -&gt; None\n</code></pre> <p>Restart ipv6 dhclient to obtain IP.</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef start_ipv6_wlan_client(self) -&gt; None:\n    \"\"\"Restart ipv6 dhclient to obtain IP.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_tcpdump","title":"start_tcpdump  <code>abstractmethod</code>","text":"<pre><code>start_tcpdump(\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str\n</code></pre> <p>Start tcpdump capture on given interface.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>inteface name where packets to be captured</p> required <code>str | None</code> <p>port number, can be a range of ports(eg: 443 or 433-443)</p> required <code>str</code> <p>pcap file name, Defaults: pkt_capture.pcap</p> <code>'pkt_capture.pcap'</code> <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})</p> <code>None</code> <code>str | None</code> <p>additional filters</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>console ouput and tcpdump process id</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>on failed to start tcpdump</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef start_tcpdump(\n    self,\n    interface: str,\n    port: str | None,\n    output_file: str = \"pkt_capture.pcap\",\n    filters: dict | None = None,\n    additional_filters: str | None = \"\",\n) -&gt; str:\n    \"\"\"Start tcpdump capture on given interface.\n\n    :param interface: inteface name where packets to be captured\n    :type interface: str\n    :param port: port number, can be a range of ports(eg: 443 or 433-443)\n    :type port: str\n    :param output_file: pcap file name, Defaults: pkt_capture.pcap\n    :type output_file: str\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n    :type filters: Optional[Dict]\n    :param additional_filters: additional filters\n    :type additional_filters: Optional[str]\n    :raises ValueError: on failed to start tcpdump\n    :return: console ouput and tcpdump process id\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_tcpdump(port)","title":"<code>port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_tcpdump(output_file)","title":"<code>output_file</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_tcpdump(additional_filters)","title":"<code>additional_filters</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_receiver","title":"start_traffic_receiver  <code>abstractmethod</code>","text":"<pre><code>start_traffic_receiver(\n    traffic_port: int,\n    bind_to_ip: str | None = None,\n    ip_version: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]\n</code></pre> <p>Start the server on a linux device to generate traffic using iperf3.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>server port to listen on</p> required <code>str | None</code> <p>bind to the interface associated with the address host, defaults to None</p> <code>None</code> <code>int | None</code> <p>4 or 6 as it uses only IPv4 or IPv6, defaults to None</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>the process id(pid) and log file path</p> <p>Raises:</p> Type Description <code>CodeError</code> <p>raises if unable to start server</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef start_traffic_receiver(\n    self,\n    traffic_port: int,\n    bind_to_ip: str | None = None,\n    ip_version: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]:\n    \"\"\"Start the server on a linux device to generate traffic using iperf3.\n\n    :param traffic_port: server port to listen on\n    :type traffic_port: int\n    :param bind_to_ip: bind to the interface associated with\n        the address host, defaults to None\n    :type bind_to_ip: str, optional\n    :param ip_version: 4 or 6 as it uses only IPv4 or IPv6, defaults to None\n    :type ip_version: int, optional\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :raises CodeError: raises if unable to start server\n    :return: the process id(pid) and log file path\n    :rtype: tuple[int, str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_receiver(traffic_port)","title":"<code>traffic_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_receiver(bind_to_ip)","title":"<code>bind_to_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_receiver(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_receiver(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender","title":"start_traffic_sender  <code>abstractmethod</code>","text":"<pre><code>start_traffic_sender(\n    host: str,\n    traffic_port: int,\n    bandwidth: int | None = None,\n    bind_to_ip: str | None = None,\n    direction: str | None = None,\n    ip_version: int | None = None,\n    udp_protocol: bool = False,\n    time: int = 10,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]\n</code></pre> <p>Start traffic on a linux client using iperf3.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>a host to run in client mode</p> required <code>int</code> <p>server port to connect to</p> required <code>int | None</code> <p>bandwidth(mbps) at which the traffic has to be generated, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the address host, defaults to None</p> <code>None</code> <code>str | None</code> <p><code>--reverse</code> to run in reverse mode (server sends, client receives) or <code>--bidir</code> to run in bidirectional mode, defaults to None</p> <code>None</code> <code>int | None</code> <p>4 or 6 as it uses only IPv4 or IPv6, defaults to None</p> <code>None</code> <code>bool</code> <p>use UDP rather than TCP, defaults to False</p> <code>False</code> <code>int</code> <p>time in seconds to transmit for, defaults to 10</p> <code>10</code> <code>int | None</code> <p>client port from where the traffic is getting started</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>the process id(pid) and log file path</p> <p>Raises:</p> Type Description <code>CodeError</code> <p>raises if unable to start server</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef start_traffic_sender(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    self,\n    host: str,\n    traffic_port: int,\n    bandwidth: int | None = None,\n    bind_to_ip: str | None = None,\n    direction: str | None = None,\n    ip_version: int | None = None,\n    udp_protocol: bool = False,\n    time: int = 10,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; tuple[int, str]:\n    \"\"\"Start traffic on a linux client using iperf3.\n\n    :param host: a host to run in client mode\n    :type host: str\n    :param traffic_port: server port to connect to\n    :type traffic_port: int\n    :param bandwidth: bandwidth(mbps) at which the traffic\n        has to be generated, defaults to None\n    :type bandwidth: Optional[int], optional\n    :param bind_to_ip: bind to the interface associated with\n        the address host, defaults to None\n    :type bind_to_ip: Optional[str], optional\n    :param direction: `--reverse` to run in reverse mode\n        (server sends, client receives) or `--bidir` to run in\n        bidirectional mode, defaults to None\n    :type direction: Optional[str], optional\n    :param ip_version: 4 or 6 as it uses only IPv4 or IPv6, defaults to None\n    :type ip_version: int, optional\n    :param udp_protocol: use UDP rather than TCP, defaults to False\n    :type udp_protocol: bool\n    :param time: time in seconds to transmit for, defaults to 10\n    :type time: int\n    :param client_port: client port from where the traffic is getting started\n    :type client_port: int | None\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :raises CodeError: raises if unable to start server\n    :return: the process id(pid) and log file path\n    :rtype: tuple[int, str]\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(host)","title":"<code>host</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(traffic_port)","title":"<code>traffic_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(bandwidth)","title":"<code>bandwidth</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(bind_to_ip)","title":"<code>bind_to_ip</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(direction)","title":"<code>direction</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(time)","title":"<code>time</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(client_port)","title":"<code>client_port</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.start_traffic_sender(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.stop_tcpdump","title":"stop_tcpdump  <code>abstractmethod</code>","text":"<pre><code>stop_tcpdump(process_id: str) -&gt; None\n</code></pre> <p>Stop tcpdump capture.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>tcpdump process id</p> required Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef stop_tcpdump(self, process_id: str) -&gt; None:\n    \"\"\"Stop tcpdump capture.\n\n    :param process_id: tcpdump process id\n    :type process_id: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.stop_tcpdump(process_id)","title":"<code>process_id</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.stop_traffic","title":"stop_traffic  <code>abstractmethod</code>","text":"<pre><code>stop_traffic(pid: int | None = None) -&gt; bool\n</code></pre> <p>Stop the iPerf3 process for a specific PID or killall.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>process ID for a iPerf3 service either for reciever or sender, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if process is stopped else False</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef stop_traffic(self, pid: int | None = None) -&gt; bool:\n    \"\"\"Stop the iPerf3 process for a specific PID or killall.\n\n    :param pid: process ID for a iPerf3 service either for reciever or sender,\n        defaults to None\n    :type pid: int | None\n    :return: True if process is stopped else False\n    :rtype: bool\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.stop_traffic(pid)","title":"<code>pid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tcpdump_capture","title":"tcpdump_capture  <code>abstractmethod</code>","text":"<pre><code>tcpdump_capture(\n    fname: str, interface: str = \"any\", additional_args: str | None = None\n) -&gt; Generator[str]\n</code></pre> <p>Capture packets from specified interface.</p> <p>Packet capture using tcpdump utility at a specified interface.</p> <p>:yield: process id of tcpdump process</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file where packet captures will be stored</p> required <code>str</code> <p>name of the interface, defaults to \"any\"</p> <code>'any'</code> <code>str | None</code> <p>argument arguments to tcpdump executable</p> <code>None</code> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@contextmanager\n@abstractmethod\ndef tcpdump_capture(\n    self,\n    fname: str,\n    interface: str = \"any\",\n    additional_args: str | None = None,\n) -&gt; Generator[str]:\n    \"\"\"Capture packets from specified interface.\n\n    Packet capture using tcpdump utility at a specified interface.\n\n    :param fname: name of the file where packet captures will be stored\n    :param interface: name of the interface, defaults to \"any\"\n    :param additional_args: argument arguments to tcpdump executable\n    :yield: process id of tcpdump process\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tcpdump_capture(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tcpdump_capture(interface)","title":"<code>interface</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tcpdump_capture(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tshark_read_pcap","title":"tshark_read_pcap  <code>abstractmethod</code>","text":"<pre><code>tshark_read_pcap(\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str\n</code></pre> <p>Read packet captures from an existing file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>name of the file in which captures are saved</p> required <code>str | None</code> <p>additional arguments for tshark command</p> <code>None</code> <code>int</code> <p>time out for tshark command to be executed, defaults to 30</p> <code>30</code> <code>bool</code> <p>If True remove the packet capture file after reading it</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>return tshark read command console output</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef tshark_read_pcap(\n    self,\n    fname: str,\n    additional_args: str | None = None,\n    timeout: int = 30,\n    rm_pcap: bool = False,\n) -&gt; str:\n    \"\"\"Read packet captures from an existing file.\n\n    :param fname: name of the file in which captures are saved\n    :type fname: str\n    :param additional_args: additional arguments for tshark command\n    :type additional_args: str\n    :param timeout: time out for tshark command to be executed, defaults to 30\n    :type timeout: int\n    :param rm_pcap: If True remove the packet capture file after reading it\n    :type rm_pcap: bool\n    :return: return tshark read command console output\n    :rtype: str\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tshark_read_pcap(fname)","title":"<code>fname</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tshark_read_pcap(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tshark_read_pcap(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.tshark_read_pcap(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.wifi_client_connect","title":"wifi_client_connect  <code>abstractmethod</code>","text":"<pre><code>wifi_client_connect(\n    ssid_name: str,\n    password: str | None = None,\n    security_mode: str | None = None,\n    bssid: str | None = None,\n) -&gt; None\n</code></pre> <p>Scan for SSID and verify wifi connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>SSID name</p> required <code>str | None</code> <p>wifi password, defaults to None</p> <code>None</code> <code>str | None</code> <p>Security mode for the wifi, defaults to None</p> <code>None</code> <code>str | None</code> <p>BSSID of the desired network. Used to differentialte between 2.4/5 GHz networks with same SSID</p> <code>None</code> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef wifi_client_connect(\n    self,\n    ssid_name: str,\n    password: str | None = None,\n    security_mode: str | None = None,\n    bssid: str | None = None,\n) -&gt; None:\n    \"\"\"Scan for SSID and verify wifi connectivity.\n\n    :param ssid_name: SSID name\n    :type ssid_name: str\n    :param password: wifi password, defaults to None\n    :type password: str, optional\n    :param security_mode: Security mode for the wifi, defaults to None\n    :type security_mode: str, optional\n    :param bssid: BSSID of the desired network.\n        Used to differentialte between 2.4/5 GHz networks with same SSID\n    :type bssid: str, optional\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.wifi_client_connect(ssid_name)","title":"<code>ssid_name</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.wifi_client_connect(password)","title":"<code>password</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.wifi_client_connect(security_mode)","title":"<code>security_mode</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.wifi_client_connect(bssid)","title":"<code>bssid</code>","text":""},{"location":"reference/templates/#boardfarm3.templates.wlan.WLAN.wifi_disconnect","title":"wifi_disconnect  <code>abstractmethod</code>","text":"<pre><code>wifi_disconnect() -&gt; None\n</code></pre> <p>Disconnect wifi connectivity.</p> Source code in <code>boardfarm3/templates/wlan.py</code> <pre><code>@abstractmethod\ndef wifi_disconnect(self) -&gt; None:\n    \"\"\"Disconnect wifi connectivity.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/use_cases/","title":"Use Cases","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases","title":"use_cases","text":"<p>Use cases to interact with devices.</p> <p>Modules:</p> Name Description <code>cpe</code> <p>Use Cases to check the performance of CPE.</p> <code>device_getters</code> <p>Device getters use cases.</p> <code>device_utilities</code> <p>Miscellaneous Use Cases to interact with devices.</p> <code>dhcp</code> <p>Boardfarm LGI DHCP IPv4 Use Cases.</p> <code>image_comparison</code> <p>Compare images.</p> <code>iperf</code> <p>Common Iperf use cases.</p> <code>multicast</code> <p>Multicast Use Cases.</p> <code>networking</code> <p>Common Networking use cases.</p> <code>ripv2</code> <p>RIPv2 Use Cases library.</p> <code>voice</code> <p>Voice use cases library.</p> <code>wifi</code> <p>Wi-Fi Use Cases library.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe","title":"cpe","text":"<p>Use Cases to check the performance of CPE.</p> <p>Functions:</p> Name Description <code>board_reset_via_console</code> <p>Reset board via console.</p> <code>create_upnp_rule</code> <p>Create UPnP rule on the device.</p> <code>delete_upnp_rule</code> <p>Delete UPnP rule on the device.</p> <code>disable_logs</code> <p>Disable logs for the specified component on the CPE.</p> <code>enable_logs</code> <p>Enable logs for the specified component on the CPE.</p> <code>factory_reset</code> <p>Perform factory reset CPE via given method.</p> <code>get_cpe_provisioning_mode</code> <p>Get the provisioning mode of the board.</p> <code>get_cpu_usage</code> <p>Return the current CPU usage of CPE.</p> <code>get_memory_usage</code> <p>Return the memory usage of CPE.</p> <code>get_seconds_uptime</code> <p>Return board uptime in seconds.</p> <code>is_ntp_synchronized</code> <p>Get the NTP synchronization status.</p> <code>is_tr069_agent_running</code> <p>Check if TR069 agent is running or not.</p> <code>read_tcpdump</code> <p>Read the tcpdump packets and delete the capture file afterwards.</p> <code>tcpdump</code> <p>Contextmanager to perform tcpdump on the board.</p> <code>transfer_file_via_scp</code> <p>Copy files and directories between the board and the remote host.</p> <code>upload_file_to_tftp</code> <p>Transfer file onto tftp server.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.board_reset_via_console","title":"board_reset_via_console","text":"<pre><code>board_reset_via_console(board: CPE) -&gt; None\n</code></pre> <p>Reset board via console.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Reboot from console.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>The board instance</p> required Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def board_reset_via_console(board: CPE) -&gt; None:\n    \"\"\"Reset board via console.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Reboot from console.\n\n    :param board: The board instance\n    :type board: CPE\n    \"\"\"\n    board.sw.reset(method=\"sw\")\n    board.sw.wait_for_boot()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.board_reset_via_console(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.create_upnp_rule","title":"create_upnp_rule","text":"<pre><code>create_upnp_rule(\n    device: LAN, int_port: str, ext_port: str, protocol: str, url: str | None = None\n) -&gt; str\n</code></pre> <p>Create UPnP rule on the device.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Create UPnP rule through cli.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN</code> <p>LAN device instance</p> required <code>str</code> <p>internal port for UPnP</p> required <code>str</code> <p>external port for UPnP</p> required <code>str</code> <p>protocol to be used</p> required <code>str | None</code> <p>url to be used</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>output of UPnP add port command</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def create_upnp_rule(\n    device: LAN, int_port: str, ext_port: str, protocol: str, url: str | None = None\n) -&gt; str:\n    \"\"\"Create UPnP rule on the device.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Create UPnP rule through cli.\n\n    :param device: LAN device instance\n    :type device: LAN\n    :param int_port: internal port for UPnP\n    :type int_port: str\n    :param ext_port: external port for UPnP\n    :type ext_port: str\n    :param protocol: protocol to be used\n    :type protocol: str\n    :param url: url to be used\n    :type url: str | None\n    :return: output of UPnP add port command\n    :rtype: str\n    \"\"\"\n    if url is None:\n        url = _UPNP_URL.safe_substitute(IP=device.get_default_gateway())\n    return device.create_upnp_rule(int_port, ext_port, protocol, url)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.create_upnp_rule(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.create_upnp_rule(int_port)","title":"<code>int_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.create_upnp_rule(ext_port)","title":"<code>ext_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.create_upnp_rule(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.create_upnp_rule(url)","title":"<code>url</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.delete_upnp_rule","title":"delete_upnp_rule","text":"<pre><code>delete_upnp_rule(device: LAN, ext_port: str, protocol: str, url: str | None) -&gt; str\n</code></pre> <p>Delete UPnP rule on the device.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Delete UPnP rule through cli.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN</code> <p>LAN device instance</p> required <code>str</code> <p>external port for UPnP</p> required <code>str</code> <p>protocol to be used</p> required <code>str | None</code> <p>url to be used</p> required <p>Returns:</p> Type Description <code>str</code> <p>output of UPnP delete port command</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def delete_upnp_rule(device: LAN, ext_port: str, protocol: str, url: str | None) -&gt; str:\n    \"\"\"Delete UPnP rule on the device.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Delete UPnP rule through cli.\n\n    :param device: LAN device instance\n    :type device: LAN\n    :param ext_port: external port for UPnP\n    :type ext_port: str\n    :param protocol: protocol to be used\n    :type protocol: str\n    :param url: url to be used\n    :type url: str | None\n    :return: output of UPnP delete port command\n    :rtype: str\n    \"\"\"\n    if url is None:\n        url = _UPNP_URL.safe_substitute(IP=device.get_default_gateway())\n    return device.delete_upnp_rule(ext_port, protocol, url)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.delete_upnp_rule(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.delete_upnp_rule(ext_port)","title":"<code>ext_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.delete_upnp_rule(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.delete_upnp_rule(url)","title":"<code>url</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.disable_logs","title":"disable_logs","text":"<pre><code>disable_logs(board: CPE, component: str) -&gt; None\n</code></pre> <p>Disable logs for the specified component on the CPE.</p> <p>.. note::     - The component can be one of \"voice\" and \"pacm\" for mv2p     - The component can be one of \"voice\", \"docsis\", \"common_components\",         \"gw\", \"vfe\", \"vendor_cbn\", \"pacm\" for mv1</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>The board instance</p> required <code>str</code> <p>The component for which logs have to disabled.</p> required Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def disable_logs(board: CPE, component: str) -&gt; None:\n    \"\"\"Disable logs for the specified component on the CPE.\n\n    .. note::\n        - The component can be one of \"voice\" and \"pacm\" for mv2p\n        - The component can be one of \"voice\", \"docsis\", \"common_components\",\n            \"gw\", \"vfe\", \"vendor_cbn\", \"pacm\" for mv1\n\n    :param board: The board instance\n    :type board: CPE\n    :param component: The component for which logs have to disabled.\n    :type component: str\n    \"\"\"\n    board.sw.enable_logs(component=component, flag=\"disable\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.disable_logs(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.disable_logs(component)","title":"<code>component</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.enable_logs","title":"enable_logs","text":"<pre><code>enable_logs(board: CPE, component: str) -&gt; None\n</code></pre> <p>Enable logs for the specified component on the CPE.</p> <p>.. note::     - The component can be one of \"voice\" and \"pacm\" for mv2p     - The component can be one of \"voice\", \"docsis\", \"common_components\",         \"gw\", \"vfe\", \"vendor_cbn\", \"pacm\" for mv1</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>The board instance</p> required <code>str</code> <p>The component for which logs have to be enabled.</p> required Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def enable_logs(board: CPE, component: str) -&gt; None:\n    \"\"\"Enable logs for the specified component on the CPE.\n\n    .. note::\n        - The component can be one of \"voice\" and \"pacm\" for mv2p\n        - The component can be one of \"voice\", \"docsis\", \"common_components\",\n            \"gw\", \"vfe\", \"vendor_cbn\", \"pacm\" for mv1\n\n    :param board: The board instance\n    :type board: CPE\n    :param component: The component for which logs have to be enabled.\n    :type component: str\n    \"\"\"\n    board.sw.enable_logs(component=component, flag=\"enable\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.enable_logs(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.enable_logs(component)","title":"<code>component</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.factory_reset","title":"factory_reset","text":"<pre><code>factory_reset(board: CPE, method: None | str = None) -&gt; bool\n</code></pre> <p>Perform factory reset CPE via given method.</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>The board instance.</p> required <code>None | str</code> <p>Factory reset method</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True on successful factory reset</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def factory_reset(board: CPE, method: None | str = None) -&gt; bool:\n    \"\"\"Perform factory reset CPE via given method.\n\n    :param board: The board instance.\n    :type board: CPE\n    :param method: Factory reset method\n    :type method: None | str\n    :return: True on successful factory reset\n    :rtype: bool\n    \"\"\"\n    return board.sw.factory_reset(method)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.factory_reset(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.factory_reset(method)","title":"<code>method</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_cpe_provisioning_mode","title":"get_cpe_provisioning_mode","text":"<pre><code>get_cpe_provisioning_mode(board: CPE) -&gt; str\n</code></pre> <p>Get the provisioning mode of the board.</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>The board object, from which the provisioning mode is fetched.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The provisioning mode of the board.</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def get_cpe_provisioning_mode(board: CPE) -&gt; str:\n    \"\"\"Get the provisioning mode of the board.\n\n    :param board: The board object, from which the provisioning mode is fetched.\n    :type board: CPE\n    :return: The provisioning mode of the board.\n    :rtype: str\n    \"\"\"\n    return board.sw.get_provision_mode()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_cpe_provisioning_mode(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_cpu_usage","title":"get_cpu_usage","text":"<pre><code>get_cpu_usage(board: CPE) -&gt; float\n</code></pre> <p>Return the current CPU usage of CPE.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Return the current CPU usage of CPE.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>CPE device instance</p> required <p>Returns:</p> Type Description <code>float</code> <p>current CPU usage of the CPE</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def get_cpu_usage(board: CPE) -&gt; float:\n    \"\"\"Return the current CPU usage of CPE.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Return the current CPU usage of CPE.\n\n    :param board: CPE device instance\n    :type board: CPE\n    :return: current CPU usage of the CPE\n    :rtype: float\n    \"\"\"\n    return board.sw.get_load_avg()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_cpu_usage(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_memory_usage","title":"get_memory_usage","text":"<pre><code>get_memory_usage(board: CPE) -&gt; dict[str, int]\n</code></pre> <p>Return the memory usage of CPE.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Return the memory usage of CPE.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>CPE device instance</p> required <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>current memory utilization of the CPE</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def get_memory_usage(board: CPE) -&gt; dict[str, int]:\n    \"\"\"Return the memory usage of CPE.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Return the memory usage of CPE.\n\n    :param board: CPE device instance\n    :type board: CPE\n    :return: current memory utilization of the CPE\n    :rtype: dict[str, int]\n    \"\"\"\n    return board.sw.get_memory_utilization()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_memory_usage(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_seconds_uptime","title":"get_seconds_uptime","text":"<pre><code>get_seconds_uptime(board: CPE) -&gt; float\n</code></pre> <p>Return board uptime in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>The board instance</p> required <p>Returns:</p> Type Description <code>float</code> <p>board uptime in seconds</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def get_seconds_uptime(board: CPE) -&gt; float:\n    \"\"\"Return board uptime in seconds.\n\n    :param board: The board instance\n    :type board: CPE\n    :return: board uptime in seconds\n    :rtype: float\n    \"\"\"\n    return board.sw.get_seconds_uptime()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.get_seconds_uptime(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.is_ntp_synchronized","title":"is_ntp_synchronized","text":"<pre><code>is_ntp_synchronized(board: CPE) -&gt; bool\n</code></pre> <p>Get the NTP synchronization status.</p> <p>Sample block of the output</p> <p>.. code-block:: python</p> <pre><code>[\n    {\n        \"remote\": \"2001:dead:beef:\",\n        \"refid\": \".XFAC.\",\n        \"st\": 16,\n        \"t\": \"u\",\n        \"when\": 65,\n        \"poll\": 18,\n        \"reach\": 0,\n        \"delay\": 0.0,\n        \"offset\": 0.0,\n        \"jitter\": 0.0,\n        \"state\": \"*\",\n    }\n]\n</code></pre> <p>This Use Case validates the 'state' from the parsed output and returns bool based on the value present in it. The meaning of the indicators are given below,</p> <p>'*' - synchronized candidate '#' - selected but not synchronized '+' - candidate to be selected [x/-/ /./None] - discarded candidate</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>CPE device instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if NTP is synchronized, false otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the output has more than one list item</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def is_ntp_synchronized(board: CPE) -&gt; bool:\n    \"\"\"Get the NTP synchronization status.\n\n    Sample block of the output\n\n    .. code-block:: python\n\n        [\n            {\n                \"remote\": \"2001:dead:beef:\",\n                \"refid\": \".XFAC.\",\n                \"st\": 16,\n                \"t\": \"u\",\n                \"when\": 65,\n                \"poll\": 18,\n                \"reach\": 0,\n                \"delay\": 0.0,\n                \"offset\": 0.0,\n                \"jitter\": 0.0,\n                \"state\": \"*\",\n            }\n        ]\n\n    This Use Case validates the 'state' from the parsed output and returns bool based on\n    the value present in it. The meaning of the indicators are given below,\n\n    '*' - synchronized candidate\n    '#' - selected but not synchronized\n    '+' - candidate to be selected\n    [x/-/ /./None] - discarded candidate\n\n    :param board: CPE device instance\n    :type board: CPE\n    :raises ValueError: when the output has more than one list item\n    :return: True if NTP is synchronized, false otherwise\n    :rtype: bool\n    \"\"\"\n    ntp_output = board.sw.get_ntp_sync_status()\n    if len(ntp_output) == 0:\n        msg = \"No NTP server available to the device\"\n        raise ValueError(msg)\n    if len(ntp_output) &gt; _TOO_MANY_NTPS:\n        msg = \"Unclear NTP status. There is more than one NTP server present\"\n        raise ValueError(msg)\n    return ntp_output[0][\"state\"] == \"*\"\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.is_ntp_synchronized(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.is_tr069_agent_running","title":"is_tr069_agent_running","text":"<pre><code>is_tr069_agent_running(board: CPE) -&gt; bool\n</code></pre> <p>Check if TR069 agent is running or not.</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>The board instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if agent is running, false otherwise</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def is_tr069_agent_running(board: CPE) -&gt; bool:\n    \"\"\"Check if TR069 agent is running or not.\n\n    :param board: The board instance\n    :type board: CPE\n    :return: True if agent is running, false otherwise\n    :rtype: bool\n    \"\"\"\n    return board.sw.is_tr069_connected()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.is_tr069_agent_running(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.read_tcpdump","title":"read_tcpdump","text":"<pre><code>read_tcpdump(\n    fname: str, board: CPE, protocol: str = \"\", opts: str = \"\", rm_pcap: bool = True\n) -&gt; str\n</code></pre> <p>Read the tcpdump packets and delete the capture file afterwards.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>filename or the complete path of the pcap file</p> required <code>CPE</code> <p>CPE device instance</p> required <code>str</code> <p>protocol to filter, defaults to \"\"</p> <code>''</code> <code>str</code> <p>defaults to \"\"</p> <code>''</code> <code>bool</code> <p>defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>output of tcpdump read command</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def read_tcpdump(\n    fname: str,\n    board: CPE,\n    protocol: str = \"\",\n    opts: str = \"\",\n    rm_pcap: bool = True,\n) -&gt; str:\n    \"\"\"Read the tcpdump packets and delete the capture file afterwards.\n\n    :param fname: filename or the complete path of the pcap file\n    :type fname: str\n    :param board: CPE device instance\n    :type board: CPE\n    :param protocol: protocol to filter, defaults to \"\"\n    :type protocol: str\n    :param opts: defaults to \"\"\n    :type opts: str\n    :param rm_pcap: defaults to True\n    :type rm_pcap: bool\n    :return: output of tcpdump read command\n    :rtype: str\n    \"\"\"\n    return board.sw.nw_utility.read_tcpdump(\n        fname,\n        protocol=protocol,\n        opts=opts,\n        rm_pcap=rm_pcap,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.read_tcpdump(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.read_tcpdump(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.read_tcpdump(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.read_tcpdump(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.read_tcpdump(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.tcpdump","title":"tcpdump","text":"<pre><code>tcpdump(\n    fname: str, interface: str, board: CPE, filters: dict | None = None\n) -&gt; Generator[str]\n</code></pre> <p>Contextmanager to perform tcpdump on the board.</p> <p>Start <code>tcpdump</code> on the board console and kill it outside its scope</p> <p>:yield: yields the process id of the tcp capture started</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>the filename or the complete path of the resource</p> required <code>str</code> <p>interface name on which the tcp traffic will listen to</p> required <code>CPE</code> <p>CPE device instance</p> required <code>dict | None</code> <p>filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})</p> <code>None</code> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>@contextmanager\ndef tcpdump(\n    fname: str,\n    interface: str,\n    board: CPE,\n    filters: dict | None = None,\n) -&gt; Generator[str]:\n    \"\"\"Contextmanager to perform tcpdump on the board.\n\n    Start ``tcpdump`` on the board console and kill it outside its scope\n\n    :param fname: the filename or the complete path of the resource\n    :type fname: str\n    :param interface: interface name on which the tcp traffic will listen to\n    :type interface: str\n    :param board: CPE device instance\n    :type board: CPE\n    :param filters: filters as key value pair(eg: {\"-v\": \"\", \"-c\": \"4\"})\n    :type filters: dict | None\n    :yield: yields the process id of the tcp capture started\n    :rtype: Generator[str, None, None]\n    \"\"\"\n    pid: str = \"\"\n    try:\n        pid = board.sw.nw_utility.start_tcpdump(fname, interface, filters=filters)\n        yield pid\n    finally:\n        board.sw.nw_utility.stop_tcpdump(pid)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.tcpdump(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.tcpdump(interface)","title":"<code>interface</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.tcpdump(board)","title":"<code>board</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp","title":"transfer_file_via_scp","text":"<pre><code>transfer_file_via_scp(\n    source_dev: CPE,\n    source_file: str,\n    dest_file: str,\n    dest_host: LAN | WAN,\n    action: Literal[\"download\", \"upload\"],\n    port: int | str = 22,\n    ipv6: bool = False,\n) -&gt; None\n</code></pre> <p>Copy files and directories between the board and the remote host.</p> <p>Copy is made over SSH.</p> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>CPE device instance</p> required <code>str</code> <p>path on the board</p> required <code>str</code> <p>path on the remote host</p> required <code>LAN | WAN</code> <p>the remote host instance</p> required <code>int | str</code> <p>host port</p> <code>22</code> <code>Literal['download', 'upload']</code> <p>scp action to perform i.e upload, download</p> required <code>bool</code> <p>whether scp should be done to IPv4 or IPv6, defaults to IPv4</p> <code>False</code> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def transfer_file_via_scp(  # pylint: disable=protected-access  # noqa: PLR0913\n    source_dev: CPE,\n    source_file: str,\n    dest_file: str,\n    dest_host: LAN | WAN,\n    action: Literal[\"download\", \"upload\"],\n    port: int | str = 22,\n    ipv6: bool = False,\n) -&gt; None:\n    \"\"\"Copy files and directories between the board and the remote host.\n\n    Copy is made over SSH.\n\n    :param source_dev: CPE device instance\n    :type source_dev: CPE\n    :param source_file: path on the board\n    :type source_file: str\n    :param dest_file: path on the remote host\n    :type dest_file: str\n    :param dest_host: the remote host instance\n    :type dest_host: LAN | WAN\n    :param port: host port\n    :type port: int | str\n    :param action: scp action to perform i.e upload, download\n    :type action: Literal[\"download\", \"upload\"]\n    :param port: host port, defaults to 22\n    :type port: str\n    :param ipv6: whether scp should be done to IPv4 or IPv6, defaults to IPv4\n    :type ipv6: bool\n    \"\"\"\n    (src, dst) = (\n        (source_file, dest_file) if action == \"upload\" else (dest_file, source_file)\n    )\n    # TODO: private members should not be used, BOARDFARM-5040\n    username = dest_host._username  # type: ignore[union-attr]  # noqa: SLF001\n    password = dest_host._password  # type: ignore[union-attr]  # noqa: SLF001\n    ip_addr = (\n        dest_host.get_interface_ipv6addr(dest_host.iface_dut)\n        if ipv6\n        else dest_host.get_interface_ipv4addr(dest_host.iface_dut)\n    )\n    source_dev.sw.nw_utility.scp(ip_addr, port, username, password, src, dst, action)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp(source_dev)","title":"<code>source_dev</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp(source_file)","title":"<code>source_file</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp(dest_file)","title":"<code>dest_file</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp(dest_host)","title":"<code>dest_host</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp(action)","title":"<code>action</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.transfer_file_via_scp(ipv6)","title":"<code>ipv6</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.upload_file_to_tftp","title":"upload_file_to_tftp","text":"<pre><code>upload_file_to_tftp(\n    source_dev: CPE,\n    source_file: str,\n    tftp_server: LAN | WAN,\n    path_on_tftpserver: str,\n    ipv6: bool = False,\n    timeout: int = 60,\n) -&gt; None\n</code></pre> <p>Transfer file onto tftp server.</p> <p>.. hint:: This Use Case helps to copy files from board to tftp servre</p> <pre><code>- can be used after a tcpdump on board\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>CPE</code> <p>CPE device instance</p> required <code>str</code> <p>Path on the board</p> required <code>LAN | WAN</code> <p>the remote tftp server instance</p> required <code>str</code> <p>Path on the tftp server</p> required <code>bool</code> <p>if scp should be done to ipv4 or ipv6, defaults to ipv4</p> <code>False</code> <code>int</code> <p>timeout value for the usecase</p> <code>60</code> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>when file not found</p> Source code in <code>boardfarm3/use_cases/cpe.py</code> <pre><code>def upload_file_to_tftp(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_dev: CPE,\n    source_file: str,\n    tftp_server: LAN | WAN,\n    path_on_tftpserver: str,\n    ipv6: bool = False,\n    timeout: int = 60,\n) -&gt; None:\n    \"\"\"Transfer file onto tftp server.\n\n    .. hint:: This Use Case helps to copy files from board to tftp servre\n\n        - can be used after a tcpdump on board\n\n    :param source_dev: CPE device instance\n    :type source_dev: CPE\n    :param source_file: Path on the board\n    :type source_file: str\n    :param tftp_server: the remote tftp server instance\n    :type tftp_server: LAN | WAN\n    :param path_on_tftpserver: Path on the tftp server\n    :type path_on_tftpserver: str\n    :param ipv6: if scp should be done to ipv4 or ipv6, defaults to ipv4\n    :type ipv6: bool\n    :param timeout: timeout value for the usecase\n    :type timeout: int\n    :raises UseCaseFailure: when file not found\n    \"\"\"\n    serv_tftp_folder = \"/tftpboot\"\n    server_ip_addr = (\n        tftp_server.get_interface_ipv6addr(tftp_server.iface_dut)\n        if ipv6\n        else tftp_server.get_interface_ipv4addr(tftp_server.iface_dut)\n    )\n    _, filename = os.path.split(source_file)\n    file_location_on_server = f\"{serv_tftp_folder}/{filename}\"\n    tftp_server.console.execute_command(\n        f\"chmod 777 {serv_tftp_folder}\", timeout=timeout\n    )\n    source_dev.sw.nw_utility.tftp(\n        server_ip_addr, source_file, filename, timeout=timeout\n    )\n    # move file to given tftp location and perform check of transfer\n    mv_command = f\"mv {file_location_on_server} {path_on_tftpserver}\"\n    output = tftp_server.console.execute_command(mv_command, timeout=timeout)\n    if \"No such file or directory\" in output:\n        msg = f\"file not found {output}\"\n        raise UseCaseFailure(msg)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.upload_file_to_tftp(source_dev)","title":"<code>source_dev</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.upload_file_to_tftp(source_file)","title":"<code>source_file</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.upload_file_to_tftp(tftp_server)","title":"<code>tftp_server</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.upload_file_to_tftp(path_on_tftpserver)","title":"<code>path_on_tftpserver</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.upload_file_to_tftp(ipv6)","title":"<code>ipv6</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.cpe.upload_file_to_tftp(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.device_getters","title":"device_getters","text":"<p>Device getters use cases.</p> <p>Functions:</p> Name Description <code>device_getter</code> <p>Provide device of type 'device_type'.</p> <code>get_lan_clients</code> <p>Return a list of LAN clients based on given count.</p> <code>get_wan_clients</code> <p>Return a list of WAN clients based on given count.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.device_getters.device_getter","title":"device_getter","text":"<pre><code>device_getter(device_type: type[T]) -&gt; T\n</code></pre> <p>Provide device of type 'device_type'.</p> <p>Parameters:</p> Name Type Description Default <code>type[T]</code> <p>Type of device to get</p> required <p>Returns:</p> Type Description <code>T</code> <p>Instance of device</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no device of given type is available or if more than 1 device of given type is available</p> Source code in <code>boardfarm3/use_cases/device_getters.py</code> <pre><code>def device_getter(device_type: type[T]) -&gt; T:\n    \"\"\"Provide device of type 'device_type'.\n\n    :param device_type: Type of device to get\n    :return: Instance of device\n    :raises ValueError: if no device of given type is available or\n        if more than 1 device of given type is available\n    \"\"\"\n    devs = get_device_manager().get_devices_by_type(device_type)\n\n    if len(devs) &lt; 1:\n        msg = f\"There are no {device_type} devices available\"\n        raise ValueError(msg)\n    if len(devs) &gt; 1:\n        msg = f\"More than 1 {device_type} devices found\"\n        raise ValueError(msg)\n    return devs[next(iter(devs))]\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.device_getters.device_getter(device_type)","title":"<code>device_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.device_getters.get_lan_clients","title":"get_lan_clients","text":"<pre><code>get_lan_clients(count: int) -&gt; list[LAN]\n</code></pre> <p>Return a list of LAN clients based on given count.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>number of LAN clients</p> required <p>Returns:</p> Type Description <code>List[LAN]</code> <p>list of LAN clients</p> <p>Raises:</p> Type Description <code>DeviceNotFound</code> <p>if count of LAN devices is invalid</p> Source code in <code>boardfarm3/use_cases/device_getters.py</code> <pre><code>def get_lan_clients(count: int) -&gt; list[LAN]:\n    \"\"\"Return a list of LAN clients based on given count.\n\n    :param count: number of LAN clients\n    :type count: int\n    :return: list of LAN clients\n    :rtype: List[LAN]\n    :raises DeviceNotFound: if count of LAN devices is invalid\n    \"\"\"\n    lan_devices = get_device_manager().get_devices_by_type(\n        LAN,  # type: ignore[type-abstract]\n    )\n    if not 0 &lt; count &lt;= len(lan_devices):\n        msg = f\"Invalid count provided. Only {len(lan_devices)} LAN clients available\"\n        raise DeviceNotFound(msg)\n    return list(lan_devices.values())[:count]\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.device_getters.get_lan_clients(count)","title":"<code>count</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.device_getters.get_wan_clients","title":"get_wan_clients","text":"<pre><code>get_wan_clients(count: int) -&gt; list[WAN]\n</code></pre> <p>Return a list of WAN clients based on given count.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>number of WAN clients</p> required <p>Returns:</p> Type Description <code>List[WAN]</code> <p>list of WAN clients</p> <p>Raises:</p> Type Description <code>DeviceNotFound</code> <p>if count of WAN devices is invalid</p> Source code in <code>boardfarm3/use_cases/device_getters.py</code> <pre><code>def get_wan_clients(count: int) -&gt; list[WAN]:\n    \"\"\"Return a list of WAN clients based on given count.\n\n    :param count: number of WAN clients\n    :type count: int\n    :return: list of WAN clients\n    :rtype: List[WAN]\n    :raises DeviceNotFound: if count of WAN devices is invalid\n    \"\"\"\n    wan_devices = get_device_manager().get_devices_by_type(\n        WAN,  # type: ignore[type-abstract]\n    )\n    if not 0 &lt; count &lt;= len(wan_devices):\n        msg = f\"Invalid count provided. Only {len(wan_devices)} WAN clients available\"\n        raise DeviceNotFound(msg)\n    return list(wan_devices.values())[:count]\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.device_getters.get_wan_clients(count)","title":"<code>count</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.device_utilities","title":"device_utilities","text":"<p>Miscellaneous Use Cases to interact with devices.</p> <p>General tasks such as reading and setting device's date and time.</p> <p>Functions:</p> Name Description <code>get_device_date</code> <p>Get the device's date and time.</p> <code>set_device_date</code> <p>Set the dut date and time from device console.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.device_utilities.get_device_date","title":"get_device_date","text":"<pre><code>get_device_date(device: LAN | WAN | WLAN | CPE) -&gt; str | None\n</code></pre> <p>Get the device's date and time.</p> <p>.. code-block:: python</p> <pre><code># example output\n\"Friday, May 24, 2024 10:43:11\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN | CPE</code> <p>device from which the date and time needs to be fetched</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>date from device console</p> Source code in <code>boardfarm3/use_cases/device_utilities.py</code> <pre><code>def get_device_date(device: LAN | WAN | WLAN | CPE) -&gt; str | None:\n    \"\"\"Get the device's date and time.\n\n    .. code-block:: python\n\n        # example output\n        \"Friday, May 24, 2024 10:43:11\"\n\n    :param device: device from which the date and time needs to be fetched\n    :type device: Union[DebianLAN, DebianWAN, DebianWifi, BoardTemplate]\n    :return: date from device console\n    :rtype: str | None\n    \"\"\"\n    if isinstance(device, CPE):\n        return device.sw.get_date()\n    return device.get_date()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.device_utilities.get_device_date(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.device_utilities.set_device_date","title":"set_device_date","text":"<pre><code>set_device_date(device: LAN | WAN | WLAN | CPE, date: str) -&gt; None\n</code></pre> <p>Set the dut date and time from device console.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN | CPE</code> <p>device on which the date and time needs to be set</p> required <code>str</code> <p>value to be changed eg: Tue Dec 20 2022, 12:40:23 UTC, etc</p> required <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>fails the usecase if the date is not set properly</p> Source code in <code>boardfarm3/use_cases/device_utilities.py</code> <pre><code>def set_device_date(device: LAN | WAN | WLAN | CPE, date: str) -&gt; None:\n    \"\"\"Set the dut date and time from device console.\n\n    :param device: device on which the date and time needs to be set\n    :type device: Union[DebianLAN, DebianWAN, DebianWifi, BoardTemplate]\n    :param date: value to be changed eg: Tue Dec 20 2022, 12:40:23 UTC, etc\n    :type date: str\n    :raises UseCaseFailure: fails the usecase if the date is not set properly\n    :rtype: str\n    \"\"\"\n    if isinstance(device, CPE):\n        out = device.sw.set_date(date)\n    else:\n        out = device.set_date(\"-s\", date)\n    if not out:\n        msg = f\"Can't set the date '{date}' on '{device}'\"\n        raise UseCaseFailure(msg)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.device_utilities.set_device_date(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.device_utilities.set_device_date(date)","title":"<code>date</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp","title":"dhcp","text":"<p>Boardfarm LGI DHCP IPv4 Use Cases.</p> <p>Classes:</p> Name Description <code>DHCPTraceData</code> <p>Provides a DHCPTraceData data class.</p> <p>Functions:</p> Name Description <code>configure_dhcp_inform</code> <p>Configure dhclient.conf to send DHCPINFORM messages.</p> <code>configure_dhcp_option125</code> <p>Configure device's vendor-specific suboptions in DHCP option 125.</p> <code>dhcp_renew_ipv4</code> <p>Release and renew IPv4 in the device and return IPv4.</p> <code>dhcp_renew_stateful_ipv6</code> <p>Release and renew stateful IPv6 in the device and return IPv6.</p> <code>dhcp_renew_stateless_ipv6</code> <p>Release and renew stateless IPv6 in the device and return IPv6.</p> <code>get_all_dhcp_options</code> <p>Get all the DHCP options in a DHCP packet.</p> <code>get_all_dhcpv6_options</code> <p>Get all the DHCPv6 options in a DHCPv6 packet.</p> <code>get_dhcp_option_details</code> <p>Get all required option details when option is provided.</p> <code>get_dhcp_packet_by_message</code> <p>Get the DHCP packets for the particular message from the pcap file.</p> <code>get_dhcp_suboption_details</code> <p>Get all required sub option details when option &amp; sub option are provided.</p> <code>get_dhcpv6_packet_by_message</code> <p>Get the DHCPv6 packets for the particular message from the pcap file.</p> <code>parse_dhcp_trace</code> <p>Read and filter the DHCP packets from the pcap file and returns the DHCP packets.</p> <code>parse_dhcpv6_trace</code> <p>Read and filter the DHCPv6 packets from the pcap file.</p> <code>remove_dhcp_inform_config</code> <p>Remove the DHCPINFORM related configuration on dhclient.conf.</p> <code>remove_dhcp_option125</code> <p>Remove the information in DHCP option 125.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.DHCPTraceData","title":"DHCPTraceData  <code>dataclass</code>","text":"<pre><code>DHCPTraceData(\n    source: IPAddresses,\n    destination: IPAddresses,\n    dhcp_packet: RecursiveDict,\n    dhcp_message_type: int,\n)\n</code></pre> <p>Provides a DHCPTraceData data class.</p> <p>Holds source, destination, dhcp_packet and dhcp_message_type.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.configure_dhcp_inform","title":"configure_dhcp_inform","text":"<pre><code>configure_dhcp_inform(client: LAN | WAN) -&gt; None\n</code></pre> <p>Configure dhclient.conf to send DHCPINFORM messages.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>Device where dhclient.conf needs to be configured for DHCPINFORM,=,</p> required Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def configure_dhcp_inform(client: LAN | WAN) -&gt; None:\n    \"\"\"Configure dhclient.conf to send DHCPINFORM messages.\n\n    :param client: Device where dhclient.conf needs to be configured for DHCPINFORM,=,\n    :type client: LAN | WAN\n    \"\"\"\n    msg_type = \"send dhcp-message-type 8;\"\n    out = client.console.execute_command(f\"egrep '{msg_type}' /etc/dhcp/dhclient.conf\")\n    if not re.search(msg_type, out):\n        # following statement is unreachable, according to mypy\n        # however if you try with out = \"\" you can execute this branch\n        # pylint:disable-next=line-too-long\n        client.console.execute_command(\"cat&gt;&gt;/etc/dhcp/dhclient.conf&lt;&lt;EOF\")  # type:ignore[unreachable]\n        client.console.execute_command(msg_type)\n        client.console.execute_command(\"EOF\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.configure_dhcp_inform(client)","title":"<code>client</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.configure_dhcp_option125","title":"configure_dhcp_option125","text":"<pre><code>configure_dhcp_option125(client: LAN | WAN) -&gt; None\n</code></pre> <p>Configure device's vendor-specific suboptions in DHCP option 125.</p> <p>This function modifies the device's <code>dhclient.conf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>Linux device to be configured.</p> required Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def configure_dhcp_option125(client: LAN | WAN) -&gt; None:\n    \"\"\"Configure device's vendor-specific suboptions in DHCP option 125.\n\n    This function modifies the device's `dhclient.conf`.\n\n    :param client: Linux device to be configured.\n    :type client: LAN | WAN\n    \"\"\"\n    # this is an copy/paste of BFv2 boardfarm/lib/dhcpoption.py\n    out = client.console.execute_command(\n        \"egrep 'request option-125' /etc/dhcp/dhclient.conf\"\n    )\n    if not re.search(\"request option-125,\", out):\n        # unreachable seems to be a false positive by MyPy\n        client.console.execute_command(  # type:ignore[unreachable]\n            \"sed -i -e \"\n            \"'s|request |\\\\noption option-125 code 125 = string;\\\\n\\\\nrequest option-125, |' \"\n            \"/etc/dhcp/dhclient.conf\"\n        )\n        # details of Text for HexaDecimal value as\n        # Enterprise code (3561) 00:00:0D:E9 length  (22)16\n        # code 01  length 06  (BFVER0) 42:46:56:45:52:30\n        # code 03  length 06  (BFCLAN)  42:46:43:4c:41:4e\n        mac = client.get_interface_macaddr(client.iface_dut)\n        value = \"VAAU\" + \"\".join(mac.split(\":\")[0:4]).upper()\n        encoded_name = str.encode(value)\n        hex_name = iter(binascii.hexlify(encoded_name).decode(\"utf-8\"))\n        code_02 = \":\".join([f\"{j}{k}\" for j, k in zip(hex_name, hex_name)])\n        len_02 = hex(len(value)).replace(\"0x\", \"\").zfill(2)\n        total_len = hex(18 + len(value)).replace(\"0x\", \"\").zfill(2)\n        option_125 = (\n            f\"00:00:0D:E9:{total_len}:01:06:44:38:42:36:42:37:02:\"\n            f\"{len_02}:{code_02}:03:06:42:46:43:4c:41:4e\"\n        )\n        client.execute_command(\"cat &gt;&gt; /etc/dhcp/dhclient.conf &lt;&lt; EOF\")\n        client.execute_command(f\"send option-125 = {option_125};\")\n        client.execute_command(\"\")\n        client.execute_command(\"EOF\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.configure_dhcp_option125(client)","title":"<code>client</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.dhcp_renew_ipv4","title":"dhcp_renew_ipv4","text":"<pre><code>dhcp_renew_ipv4(host: LAN | WLAN) -&gt; IPv4Address\n</code></pre> <p>Release and renew IPv4 in the device and return IPv4.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Trigger DHCP DISCOVER for the LAN Client IPv4 acquisition\n- Verify the IP acquisition on LAN devices\n- Check if the LAN Client connected to CPE obtains both IPv4 and IPv6 address\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN</code> <p>host where the IP has to be renewed</p> required <p>Returns:</p> Type Description <code>IPv4Address</code> <p>IPv4 address of the device</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def dhcp_renew_ipv4(host: LAN | WLAN) -&gt; IPv4Address:\n    \"\"\"Release and renew IPv4 in the device and return IPv4.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Trigger DHCP DISCOVER for the LAN Client IPv4 acquisition\n        - Verify the IP acquisition on LAN devices\n        - Check if the LAN Client connected to CPE obtains both IPv4 and IPv6 address\n\n    :param host: host where the IP has to be renewed\n    :type host: LAN | WLAN\n    :return: IPv4 address of the device\n    :rtype: IPv4Address\n    \"\"\"\n    host.release_dhcp(host.iface_dut)\n    host.renew_dhcp(host.iface_dut)\n    return IPv4Address(host.get_interface_ipv4addr(host.iface_dut))\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.dhcp_renew_ipv4(host)","title":"<code>host</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.dhcp_renew_stateful_ipv6","title":"dhcp_renew_stateful_ipv6","text":"<pre><code>dhcp_renew_stateful_ipv6(host: LAN | WLAN) -&gt; IPv6Address\n</code></pre> <p>Release and renew stateful IPv6 in the device and return IPv6.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Initiate the IPv6 acquisition from LAN Ethernet client\n- Initiate the IPv6 process from LAN Ethernet client\n- Release and renew IPv6 address on LAN client\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN</code> <p>host where the IP has to be renewed</p> required <p>Returns:</p> Type Description <code>IPv6Address</code> <p>IPv6 address of the device</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def dhcp_renew_stateful_ipv6(host: LAN | WLAN) -&gt; IPv6Address:\n    \"\"\"Release and renew stateful IPv6 in the device and return IPv6.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Initiate the IPv6 acquisition from LAN Ethernet client\n        - Initiate the IPv6 process from LAN Ethernet client\n        - Release and renew IPv6 address on LAN client\n\n    :param host: host where the IP has to be renewed\n    :type host: LAN | WLAN\n    :return: IPv6 address of the device\n    :rtype: IPv6Address\n    \"\"\"\n    host.release_ipv6(host.iface_dut)\n    host.renew_ipv6(host.iface_dut)\n    return IPv6Address(host.get_interface_ipv6addr(host.iface_dut))\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.dhcp_renew_stateful_ipv6(host)","title":"<code>host</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.dhcp_renew_stateless_ipv6","title":"dhcp_renew_stateless_ipv6","text":"<pre><code>dhcp_renew_stateless_ipv6(host: LAN | WLAN) -&gt; IPv6Address\n</code></pre> <p>Release and renew stateless IPv6 in the device and return IPv6.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Initiate the IPv6 stateless acquisition from LAN Ethernet client\n- Initiate the IPv6 stateless  process from LAN Ethernet client\n- Release and renew stateless IPv6 address on LAN client\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN</code> <p>host where the IP has to be renewed</p> required <p>Returns:</p> Type Description <code>IPv6Address</code> <p>IPv6 address of the device</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def dhcp_renew_stateless_ipv6(host: LAN | WLAN) -&gt; IPv6Address:\n    \"\"\"Release and renew stateless IPv6 in the device and return IPv6.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Initiate the IPv6 stateless acquisition from LAN Ethernet client\n        - Initiate the IPv6 stateless  process from LAN Ethernet client\n        - Release and renew stateless IPv6 address on LAN client\n\n    :param host: host where the IP has to be renewed\n    :type host: LAN | WLAN\n    :return: IPv6 address of the device\n    :rtype: IPv6Address\n    \"\"\"\n    host.release_ipv6(host.iface_dut, stateless=True)\n    host.set_link_state(host.iface_dut, \"down\")\n    host.set_link_state(host.iface_dut, \"up\")\n    host.renew_ipv6(host.iface_dut, stateless=True)\n    sleep(10)\n    return IPv6Address(host.get_interface_ipv6addr(host.iface_dut))\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.dhcp_renew_stateless_ipv6(host)","title":"<code>host</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_all_dhcp_options","title":"get_all_dhcp_options","text":"<pre><code>get_all_dhcp_options(packet: DHCPTraceData) -&gt; RecursiveDict\n</code></pre> <p>Get all the DHCP options in a DHCP packet.</p> <p>Parameters:</p> Name Type Description Default <code>DHCPTraceData</code> <p>desired packet from DHCP trace (only one packet)</p> required <p>Returns:</p> Type Description <code>RecursiveDict</code> <p>all the DHCP options</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def get_all_dhcp_options(packet: DHCPTraceData) -&gt; RecursiveDict:\n    \"\"\"Get all the DHCP options in a DHCP packet.\n\n    :param packet: desired packet from DHCP trace (only one packet)\n    :type packet: DHCPTraceData\n    :return: all the DHCP options\n    :rtype: RecursiveDict\n    \"\"\"\n    return {\n        key: value\n        for key, value in packet.dhcp_packet.items()\n        if \"dhcp.option.type\" in key\n    }\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_all_dhcp_options(packet)","title":"<code>packet</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_all_dhcpv6_options","title":"get_all_dhcpv6_options","text":"<pre><code>get_all_dhcpv6_options(packet: DHCPV6TraceData) -&gt; DHCPV6Options\n</code></pre> <p>Get all the DHCPv6 options in a DHCPv6 packet.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- DHCPv6 includes the [] option\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>DHCPV6TraceData</code> <p>desired packet from DHCPv6 trace (only one packet)</p> required <p>Returns:</p> Type Description <code>DHCPV6Options</code> <p>all the DHCPv6 options</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def get_all_dhcpv6_options(packet: DHCPV6TraceData) -&gt; DHCPV6Options:\n    \"\"\"Get all the DHCPv6 options in a DHCPv6 packet.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - DHCPv6 includes the [] option\n\n\n    :param packet: desired packet from DHCPv6 trace (only one packet)\n    :type packet: DHCPV6TraceData\n    :return: all the DHCPv6 options\n    :rtype: DHCPV6Options\n    \"\"\"\n    if packet.dhcpv6_message_type in [12, 13]:\n        out = dict(packet.dhcpv6_packet[\"Relay Message\"][\"DHCPv6\"].items())\n    else:\n        out = dict(packet.dhcpv6_packet.items())\n    return DHCPV6Options(out)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_all_dhcpv6_options(packet)","title":"<code>packet</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_option_details","title":"get_dhcp_option_details","text":"<pre><code>get_dhcp_option_details(packet: DHCPTraceData, option: int) -&gt; RecursiveDict\n</code></pre> <p>Get all required option details when option is provided.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify packet capture has option\n- Verify [] is present in DHCP [] message\n- Verify all the Mandatory_Fields are available in DHCP message\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>DHCPTraceData</code> <p>the packet data structure</p> required <code>int</code> <p>DHCP option</p> required <p>Returns:</p> Type Description <code>RecursiveDict</code> <p>option Dict along with suboptions</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>on failing to find the option</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def get_dhcp_option_details(packet: DHCPTraceData, option: int) -&gt; RecursiveDict:\n    \"\"\"Get all required option details when option is provided.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify packet capture has option\n        - Verify [] is present in DHCP [] message\n        - Verify all the Mandatory_Fields are available in DHCP message\n\n    :param packet: the packet data structure\n    :type packet: DHCPTraceData\n    :param option: DHCP option\n    :type option: int\n    :raises UseCaseFailure: on failing to find the option\n    :return: option Dict along with suboptions\n    :rtype: RecursiveDict\n    \"\"\"\n    option_data = get_all_dhcp_options(packet)\n    # pylint: disable=too-many-nested-blocks\n    try:\n        for key, value in option_data.items():\n            if value == str(option):\n                if re.search(r\"_\\d\", key) is None:\n                    out = option_data[key + \"_tree\"]\n                else:\n                    out = option_data[\n                        key.split(\"_\")[0]\n                        + \"_tree_\"\n                        + key.split(\"_\")[len(key.split(\"_\")) - 1]\n                    ]\n                    break\n    except KeyError as exception:\n        msg = f\"Failed to find option {option!s}\"\n        raise UseCaseFailure(msg) from exception\n    return out\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_option_details(packet)","title":"<code>packet</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_option_details(option)","title":"<code>option</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_packet_by_message","title":"get_dhcp_packet_by_message","text":"<pre><code>get_dhcp_packet_by_message(\n    trace: list[DHCPTraceData], message_type: str\n) -&gt; list[DHCPTraceData]\n</code></pre> <p>Get the DHCP packets for the particular message from the pcap file.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Following messages are exchanged\n- Discover, Offer, Request and Ack messages\n- DHCP messages are exchanged\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>list[DHCPTraceData]</code> <p>sequence of DHCP packets filtered from captured pcap file and stored in DHCPTraceData</p> required <code>str</code> <p>DHCP message according to RFC2132 and could be any of:  * DHCPDISCOVER, * DHCPOFFER, * DHCPREQUEST, * DHCPDECLINE, * DHCPACK, * DHCPACK, * DHCPRELEASE, * DHCPINFORM</p> required <p>Returns:</p> Type Description <code>List[DHCPTraceData]</code> <p>Sequence of DHCP packets filtered with the message type</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def get_dhcp_packet_by_message(\n    trace: list[DHCPTraceData],\n    message_type: str,\n) -&gt; list[DHCPTraceData]:\n    \"\"\"Get the DHCP packets for the particular message from the pcap file.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Following messages are exchanged\n        - Discover, Offer, Request and Ack messages\n        - DHCP messages are exchanged\n\n    :param trace: sequence of DHCP packets filtered from captured pcap file\n                  and stored in DHCPTraceData\n    :type trace: List[DHCPTraceData]\n    :param message_type: DHCP message according to RFC2132 and could be any of:\n\n        * DHCPDISCOVER,\n        * DHCPOFFER,\n        * DHCPREQUEST,\n        * DHCPDECLINE,\n        * DHCPACK,\n        * DHCPACK,\n        * DHCPRELEASE,\n        * DHCPINFORM\n\n    :type message_type: str\n    :return: Sequence of DHCP packets filtered with the message type\n    :rtype: List[DHCPTraceData]\n    \"\"\"\n    dhcp_message_dict = {\n        \"DHCPDISCOVER\": 1,\n        \"DHCPOFFER\": 2,\n        \"DHCPREQUEST\": 3,\n        \"DHCPDECLINE\": 4,\n        \"DHCPACK\": 5,\n        \"DHCPNAK\": 6,\n        \"DHCPRELEASE\": 7,\n        \"DHCPINFORM\": 8,\n    }\n    return list[DHCPTraceData](\n        [\n            packet\n            for packet in trace\n            if dhcp_message_dict.get(message_type) == packet.dhcp_message_type\n        ],\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_packet_by_message(trace)","title":"<code>trace</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_packet_by_message(message_type)","title":"<code>message_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_suboption_details","title":"get_dhcp_suboption_details","text":"<pre><code>get_dhcp_suboption_details(\n    packet: DHCPTraceData, option: int, suboption: int\n) -&gt; RecursiveDict\n</code></pre> <p>Get all required sub option details when option &amp; sub option are provided.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- DHCP option [] suboptions\n- Verify [] suboptions are present in DHCP\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>DHCPTraceData</code> <p>the packet data structure</p> required <code>int</code> <p>DHCP option</p> required <code>int</code> <p>DHCP sub option</p> required <p>Returns:</p> Type Description <code>RecursiveDict</code> <p>suboption dictionary</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>on failing to find the suboption</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def get_dhcp_suboption_details(\n    packet: DHCPTraceData,\n    option: int,\n    suboption: int,\n) -&gt; RecursiveDict:\n    \"\"\"Get all required sub option details when option &amp; sub option are provided.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - DHCP option [] suboptions\n        - Verify [] suboptions are present in DHCP\n\n    :param packet: the packet data structure\n    :type packet: DHCPTraceData\n    :param option: DHCP option\n    :type option: int\n    :param suboption: DHCP sub option\n    :type suboption: int\n    :raises UseCaseFailure: on failing to find the suboption\n    :return: suboption dictionary\n    :rtype: RecursiveDict\n    \"\"\"\n    option_key_dict = {125: \"dhcp.option.vi.enterprise_tree\"}\n    sub_option_data = get_dhcp_option_details(packet, option)\n    out = {}\n    if option in option_key_dict:\n        sub_options = sub_option_data[option_key_dict[option]]\n    else:\n        sub_options = sub_option_data\n    # pylint: disable=too-many-nested-blocks\n    try:\n        for key, value in sub_options.items():\n            if \"suboption\" in key and value == str(suboption):\n                if re.search(r\"_\\d\", key) is None:\n                    out = sub_options[key + \"_tree\"]\n                else:\n                    out = sub_options[\n                        key.split(\"_\")[0]\n                        + \"_tree_\"\n                        + key.split(\"_\")[len(key.split(\"_\")) - 1]\n                    ]\n                    break\n        if not out:\n            msg = (\n                f\"Failed to fetch suboption {suboption} for option {option} in\"\n                f\" \\n{sub_options}\"\n            )\n            raise UseCaseFailure(msg)\n    except KeyError as exception:\n        msg = f\"Failed to find suboption {suboption!s} \"\n        raise UseCaseFailure(msg) from exception\n    return out\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_suboption_details(packet)","title":"<code>packet</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_suboption_details(option)","title":"<code>option</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcp_suboption_details(suboption)","title":"<code>suboption</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcpv6_packet_by_message","title":"get_dhcpv6_packet_by_message","text":"<pre><code>get_dhcpv6_packet_by_message(\n    trace: list[DHCPV6TraceData], message_type: str\n) -&gt; list[DHCPV6TraceData]\n</code></pre> <p>Get the DHCPv6 packets for the particular message from the pcap file.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Following messages are exchanged DHCPv6\n- Discover, Offer, Request and Ack DHCPv6 messages\n- DHCPv6 messages are exchanged\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>list[DHCPV6TraceData]</code> <p>sequence of DHCPv6 packets filtered from captured pcap file and stored in DHCPV6TraceData</p> required <code>str</code> <p>DHCP message according to RFC3315 and could be any of:  * SOLICIT, * ADVERTISE, * REQUEST, * CONFIRM, * RENEW, * REBIND, * REPLY, * RELEASE, * DECLINE, * RECONFIGURE, * INFORMATION-REQUEST, * RELAY-FORW, * RELAY-REPL</p> required <p>Returns:</p> Type Description <code>List[DHCPV6TraceData]</code> <p>Sequence of DHCPv6 packets filtered with the message type</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def get_dhcpv6_packet_by_message(\n    trace: list[DHCPV6TraceData],\n    message_type: str,\n) -&gt; list[DHCPV6TraceData]:\n    \"\"\"Get the DHCPv6 packets for the particular message from the pcap file.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Following messages are exchanged DHCPv6\n        - Discover, Offer, Request and Ack DHCPv6 messages\n        - DHCPv6 messages are exchanged\n\n    :param trace: sequence of DHCPv6 packets filtered from captured pcap file\n                  and stored in DHCPV6TraceData\n    :type trace: List[DHCPV6TraceData]\n    :param message_type: DHCP message according to RFC3315 and could be any of:\n\n        * SOLICIT,\n        * ADVERTISE,\n        * REQUEST,\n        * CONFIRM,\n        * RENEW,\n        * REBIND,\n        * REPLY,\n        * RELEASE,\n        * DECLINE,\n        * RECONFIGURE,\n        * INFORMATION-REQUEST,\n        * RELAY-FORW,\n        * RELAY-REPL\n\n    :type message_type: str\n    :return: Sequence of DHCPv6 packets filtered with the message type\n    :rtype: List[DHCPV6TraceData]\n    \"\"\"\n    dhcpv6_message_dict = {\n        \"SOLICIT\": 1,\n        \"ADVERTISE\": 2,\n        \"REQUEST\": 3,\n        \"CONFIRM\": 4,\n        \"RENEW\": 5,\n        \"REBIND\": 6,\n        \"REPLY\": 7,\n        \"RELEASE\": 8,\n        \"DECLINE\": 9,\n        \"RECONFIGURE\": 10,\n        \"INFORMATION-REQUEST\": 11,\n        \"RELAY-FORW\": 12,\n        \"RELAY-REPLY\": 13,\n    }\n    return [\n        packet\n        for packet in trace\n        if dhcpv6_message_dict.get(message_type) == packet.dhcpv6_message_type\n    ]\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcpv6_packet_by_message(trace)","title":"<code>trace</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.get_dhcpv6_packet_by_message(message_type)","title":"<code>message_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcp_trace","title":"parse_dhcp_trace","text":"<pre><code>parse_dhcp_trace(\n    on_which_device: LAN | WAN | Provisioner | LTS, fname: str, timeout: int = 30\n) -&gt; list[DHCPTraceData]\n</code></pre> <p>Read and filter the DHCP packets from the pcap file and returns the DHCP packets.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify from the packet capture\n- Verify that the following messages are exchanged\n- Check that [] messages are exchanged\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | Provisioner | LTS</code> <p>Object of the device class where tcpdump is captured</p> required <code>str</code> <p>Name of the captured pcap file</p> required <code>int</code> <p>time out for <code>tshark read</code> to be executed, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>List[DHCPTraceData]</code> <p>Sequence of DHCP packets filtered from captured pcap file</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>on DHCP parse issue</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def parse_dhcp_trace(\n    on_which_device: LAN | WAN | Provisioner | LTS,\n    fname: str,\n    timeout: int = 30,\n) -&gt; list[DHCPTraceData]:\n    \"\"\"Read and filter the DHCP packets from the pcap file and returns the DHCP packets.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify from the packet capture\n        - Verify that the following messages are exchanged\n        - Check that [] messages are exchanged\n\n    :param on_which_device: Object of the device class where tcpdump is captured\n    :type on_which_device: LAN | WAN | Provisioner | CMTS\n    :param fname: Name of the captured pcap file\n    :type fname: str\n    :param timeout: time out for ``tshark read`` to be executed, defaults to 30\n    :type timeout: int\n    :raises UseCaseFailure: on DHCP parse issue\n    :return: Sequence of DHCP packets filtered from captured pcap file\n    :rtype: List[DHCPTraceData]\n    \"\"\"\n    try:\n        out = on_which_device.tshark_read_pcap(\n            fname=fname,\n            additional_args=\"-Y bootp -T json\",\n            timeout=timeout,\n        )\n        output: list[DHCPTraceData] = []\n        data = \"[\" + out.split(\"[\", 1)[-1].replace(\"\\r\\n\", \"\")\n\n        # replacing bootp to dhcp as the devices still use older tshark versions\n        replaced_data = data.replace(\"bootp\", \"dhcp\")\n        decoder = JSONDecoder(\n            object_pairs_hook=_manage_duplicates,  # type: ignore [arg-type]\n        )\n        obj = decoder.decode(replaced_data)\n        output = [\n            DHCPTraceData(\n                IPAddresses(\n                    element[\"_source\"][\"layers\"][\"ip\"][\"ip.src\"],\n                    None,\n                    None,\n                ),\n                IPAddresses(\n                    element[\"_source\"][\"layers\"][\"ip\"][\"ip.dst\"],\n                    None,\n                    None,\n                ),\n                element[\"_source\"][\"layers\"][\"dhcp\"],\n                int(\n                    element[\"_source\"][\"layers\"][\"dhcp\"][\"dhcp.option.type_tree\"][\n                        \"dhcp.option.dhcp\"\n                    ],\n                ),\n            )\n            for element in obj\n        ]\n    except Exception as exception:\n        msg = f\"Failed to parse DHCP packets due to {exception} \"\n        raise UseCaseFailure(msg) from exception\n    return output\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcp_trace(on_which_device)","title":"<code>on_which_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcp_trace(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcp_trace(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcpv6_trace","title":"parse_dhcpv6_trace","text":"<pre><code>parse_dhcpv6_trace(\n    on_which_device: LAN | WAN | Provisioner | LTS,\n    fname: str,\n    timeout: int = 30,\n    additional_args: str = \"dhcpv6\",\n) -&gt; list[DHCPV6TraceData]\n</code></pre> <p>Read and filter the DHCPv6 packets from the pcap file.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Check that the following messages are exchanged [] DHCPv6\n- Verify from the packet capture that DHCPv6\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | Provisioner | LTS</code> <p>Object of the device class where tcpdump is captured</p> required <code>str</code> <p>Name of the captured pcap file</p> required <code>int</code> <p>time out for <code>tshark</code> command to be executed, defaults to 30</p> <code>30</code> <code>str</code> <p>additional arguments for tshark command to display filtered output, defaults to dhcpv6</p> <code>'dhcpv6'</code> <p>Returns:</p> Type Description <code>List[DHCPV6TraceData]</code> <p>sequence of DHCPv6 packets filtered from captured pcap file</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>on failure to parse DHCPv6 data</p> Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def parse_dhcpv6_trace(\n    on_which_device: LAN | WAN | Provisioner | LTS,\n    fname: str,\n    timeout: int = 30,\n    additional_args: str = \"dhcpv6\",\n) -&gt; list[DHCPV6TraceData]:\n    \"\"\"Read and filter the DHCPv6 packets from the pcap file.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Check that the following messages are exchanged [] DHCPv6\n        - Verify from the packet capture that DHCPv6\n\n    :param on_which_device: Object of the device class where tcpdump is captured\n    :type on_which_device: LAN | WAN | Provisioner | CMTS\n    :param fname: Name of the captured pcap file\n    :type fname: str\n    :param timeout: time out for ``tshark`` command to be executed, defaults to 30\n    :type timeout: int\n    :param additional_args: additional arguments for tshark command to\n                            display filtered output, defaults to dhcpv6\n    :type additional_args: str\n    :raises UseCaseFailure: on failure to parse DHCPv6 data\n    :return: sequence of DHCPv6 packets filtered from captured pcap file\n    :rtype: List[DHCPV6TraceData]\n    \"\"\"\n    output: list[DHCPV6TraceData] = []\n    key_list: list[str] = []\n    val_list: list[str | dict] = []\n    out = on_which_device.tshark_read_pcap(\n        fname=fname, additional_args=f\"-Y '{additional_args}' -T json\", timeout=timeout\n    )\n    data = \"[\" + out.split(\"[\", 1)[-1].replace(\"\\r\\n\", \"\")\n    try:\n        obj = JSONDecoder(\n            object_pairs_hook=_manage_duplicates,  # type: ignore [arg-type]\n        ).decode(data)\n    except JSONDecodeError as exception:\n        msg = f\"Failed to parse JSON due to {exception} \"\n        raise UseCaseFailure(msg) from exception\n    try:\n        for element in obj:\n            # condition for mv3 eth packets because the packets are\n            # not wrapped under Relay message.\n            # the below logic updates the dhcp packet dict to have\n            # the consistent format across gateways\n            if \"Relay Message\" not in element[\"_source\"][\"layers\"][\"dhcpv6\"]:\n                pkt_dict = element[\"_source\"][\"layers\"][\"dhcpv6\"]\n                dhcp_dict = _parse_options(pkt_dict, key_list, val_list)\n                _update_trace_data(output, dhcp_dict, element)\n            else:\n                _update_trace_data(\n                    output, element[\"_source\"][\"layers\"][\"dhcpv6\"], element\n                )\n        return output  # noqa: TRY300\n\n    except KeyError as exception:\n        msg = f\"Failed due to missing key {exception} in dictionary\"\n        raise UseCaseFailure(msg) from exception\n    except TypeError as exception:\n        msg = f\"Failed due to type error: {exception}\"\n        raise UseCaseFailure(msg) from exception\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcpv6_trace(on_which_device)","title":"<code>on_which_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcpv6_trace(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcpv6_trace(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.parse_dhcpv6_trace(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.remove_dhcp_inform_config","title":"remove_dhcp_inform_config","text":"<pre><code>remove_dhcp_inform_config(client: LAN | WAN) -&gt; None\n</code></pre> <p>Remove the DHCPINFORM related configuration on dhclient.conf.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>Device from where the configuration needs to be removed.</p> required Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def remove_dhcp_inform_config(client: LAN | WAN) -&gt; None:\n    \"\"\"Remove the DHCPINFORM related configuration on dhclient.conf.\n\n    :param client: Device from where the configuration needs to be removed.\n    :type client: LAN | WAN\n    \"\"\"\n    client.console.execute_command(\n        \"sed -i '/dhcp-message-type 8/d' /etc/dhcp/dhclient.conf\"\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.remove_dhcp_inform_config(client)","title":"<code>client</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.remove_dhcp_option125","title":"remove_dhcp_option125","text":"<pre><code>remove_dhcp_option125(client: LAN | WAN) -&gt; None\n</code></pre> <p>Remove the information in DHCP option 125.</p> <p>This function modifies the Linux device's <code>dhclient.conf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>Linux device to be configured.</p> required Source code in <code>boardfarm3/use_cases/dhcp.py</code> <pre><code>def remove_dhcp_option125(client: LAN | WAN) -&gt; None:\n    \"\"\"Remove the information in DHCP option 125.\n\n    This function modifies the Linux device's `dhclient.conf`.\n\n    :param client: Linux device to be configured.\n    :type client: LAN | WAN\n    \"\"\"\n    # this is an copy/paste of BFv2 boardfarm/lib/dhcpoption.py\n    client.console.execute_command(\n        \"sed -i -e 's|request option-125,|request |' /etc/dhcp/dhclient.conf\"\n    )\n    client.console.execute_command(\"sed -i '/option-125/d' /etc/dhcp/dhclient.conf\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.dhcp.remove_dhcp_option125(client)","title":"<code>client</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.image_comparison","title":"image_comparison","text":"<p>Compare images.</p> <p>Functions:</p> Name Description <code>compare_images</code> <p>Compare 2 images and return the similarity score.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.image_comparison.compare_images","title":"compare_images","text":"<pre><code>compare_images(\n    first_image: Path,\n    second_image: Path,\n    ignore_areas: list[tuple[int, int, int, int]] | None,\n    show_images: bool = False,\n) -&gt; dict[str, float64]\n</code></pre> <p>Compare 2 images and return the similarity score.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>Usually the original image (usually a png)</p> required <code>Path</code> <p>The new image (with same size as the first image)</p> required <code>list[tuple[int, int, int, int]] | None</code> <p>A list of coordinates for the zones (rectangles) to be ignored during the comparison (xtop, ytop, xbottom, ybottom) 1 tuple is one rectangle.  (xtop, ytop) |-----------------| |                 | |                 | |-----------------|(xbottom,ybottom)</p> required <code>bool</code> <p>shows the images, NOT TO BE USED in CI, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>np.float64</code> <p>the similarity Score of the original images if there is no ignore_areas otherwise returns the masked images similarity score</p> Source code in <code>boardfarm3/use_cases/image_comparison.py</code> <pre><code>def compare_images(  # noqa: PLR0915  # pylint: disable=too-many-locals,too-many-statements\n    first_image: Path,\n    second_image: Path,\n    ignore_areas: list[tuple[int, int, int, int]] | None,\n    show_images: bool = False,\n) -&gt; dict[str, np.float64]:\n    \"\"\"Compare 2 images and return the similarity score.\n\n    :param first_image: Usually the original image (usually a png)\n    :type first_image: Path\n    :param second_image: The new image (with same size as the first image)\n    :type second_image: Path\n    :param ignore_areas: A list of coordinates for the zones (rectangles) to be\n                         ignored during the comparison (xtop, ytop, xbottom, ybottom)\n                         1 tuple is one rectangle.\n\n                         (xtop, ytop)\n                              |-----------------|\n                              |                 |\n                              |                 |\n                              |-----------------|(xbottom,ybottom)\n\n    :type ignore_areas: list[tuple[int, int, int, int, int]] | None\n    :param show_images: shows the images, NOT TO BE USED in CI, defaults to False\n    :type show_images: bool\n    :return: the similarity Score of the original images if there is no ignore_areas\n             otherwise returns the masked images similarity score\n    :rtype: np.float64\n    \"\"\"\n    masked_score = None\n    first = cv2.imread(str(first_image.absolute().resolve()))\n    second = cv2.imread(str(second_image.absolute().resolve()))\n    first_masked = None\n    second_masked = None\n\n    # this needed for the structural_similarity comparison\n    first_gray = cv2.cvtColor(first, cv2.COLOR_BGR2GRAY)\n    second_gray = cv2.cvtColor(second, cv2.COLOR_BGR2GRAY)\n\n    # this is the % of similarity between the 2 original images (i.e. unmasked)\n    # NB: the images MUST BE of the SAME SIZE!!!!\n    unmasked_score, unmasked_diff = structural_similarity(  # type: ignore[no-untyped-call]\n        first_gray,\n        second_gray,\n        full=True,\n    )\n    msg = f\"Unmasked Similarity Score: {unmasked_score * 100:.3f}%\"\n    _LOGGER.info(msg)\n    diff = unmasked_diff = (unmasked_diff * 255).astype(\"uint8\")\n\n    # same as above but on the masked images (if any areas are to be ignored)\n    if ignore_areas:\n        # these are the same images with the areas to be ignored blacked out\n        first_masked = _build_mask(first, ignore_areas)\n        second_masked = _build_mask(second, ignore_areas)\n        masked_score, masked_diff = structural_similarity(  # type: ignore[no-untyped-call]\n            cv2.cvtColor(first_masked, cv2.COLOR_BGR2GRAY),\n            cv2.cvtColor(second_masked, cv2.COLOR_BGR2GRAY),\n            full=True,\n        )\n        msg = f\"Masked Similarity Score: {masked_score * 100:.3f}%\"\n        _LOGGER.info(msg)\n\n        # The diff image contains the actual image differences between the two images\n        # and is represented as a floating point data type so we must convert the array\n        # to 8-bit unsigned integers in the range [0,255] before we can use it with OpenCV\n        diff = (masked_diff * 255).astype(\"uint8\")\n\n    # Threshold the difference image, followed by finding contours to\n    # obtain the regions that differ between the two images\n    thresh = cv2.threshold(\n        unmasked_diff,\n        0,\n        255,\n        cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU,\n    )[1]\n    contours = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    if len(contours) == 2:  # noqa: PLR2004, SIM108\n        contours = contours[0]  # type: ignore[assignment]\n    else:\n        contours = contours[1]  # type: ignore[assignment, unreachable]\n\n    # Highlight differences\n    mask = np.zeros(first.shape, dtype=\"uint8\")\n    filled = second.copy()\n\n    for c in contours:\n        area = cv2.contourArea(c)  # type: ignore[arg-type]\n        if area &gt; 100:  # noqa: PLR2004\n            x, y, w, h = cv2.boundingRect(c)  # type: ignore[arg-type]\n            cv2.rectangle(first, (x, y), (x + w, y + h), (36, 255, 12), 2)\n            cv2.rectangle(second, (x, y), (x + w, y + h), (36, 255, 12), 2)\n            cv2.drawContours(mask, [c], 0, (0, 255, 0), -1)  # type: ignore[list-item]\n            cv2.drawContours(filled, [c], 0, (0, 255, 0), -1)  # type: ignore[list-item]\n\n    cv2.imwrite(_append_qualifier(first_image, \"contour\"), first)\n    cv2.imwrite(_append_qualifier(second_image, \"contour\"), second)\n    cv2.imwrite(_append_qualifier(second_image, \"diff\"), diff)\n    cv2.imwrite(_append_qualifier(second_image, \"mask\"), mask)\n    cv2.imwrite(_append_qualifier(second_image, \"filled\"), filled)\n    if first_masked is not None:\n        cv2.imwrite(_append_qualifier(first_image, \"masked\"), first_masked)\n    if second_masked is not None:\n        cv2.imwrite(_append_qualifier(second_image, \"masked\"), second_masked)\n\n    # NB: cv2.waitKey() is interactive and shold not be used in CI environments\n    # but you knew that already \ud83d\ude01!\n    if show_images:\n        cv2.imshow(\"first\", first)\n        cv2.imshow(\"second\", second)\n        cv2.imshow(\"diff\", diff)\n        cv2.imshow(\"mask\", mask)\n        cv2.imshow(\"filled\", filled)\n        if first_masked is not None:\n            cv2.imshow(\"first_masked\", first_masked)\n        if second_masked is not None:\n            cv2.imshow(\"second_masked\", second_masked)\n        cv2.waitKey()\n\n    return (\n        round(unmasked_score * 100, 3)\n        if masked_score is None\n        else round(masked_score * 100, 3)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.image_comparison.compare_images(first_image)","title":"<code>first_image</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.image_comparison.compare_images(second_image)","title":"<code>second_image</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.image_comparison.compare_images(ignore_areas)","title":"<code>ignore_areas</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.image_comparison.compare_images(show_images)","title":"<code>show_images</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf","title":"iperf","text":"<p>Common Iperf use cases.</p> <p>Functions:</p> Name Description <code>get_iperf_logs</code> <p>Check logs and returns traffic flow.</p> <code>parse_iperf_logs</code> <p>Parse iperf logs and return bitrate, transfer etc.</p> <code>set_device_interface_state</code> <p>Toggle the interface based on the action passed.</p> <code>start_iperf_ipv4</code> <p>Initiate IPv4 downstream traffic from source device to destination device.</p> <code>start_iperf_ipv4_bidirectional</code> <p>Initiate IPv4 bidirectional traffic from source device to destination device.</p> <code>start_iperf_ipv4_downstream</code> <p>Initiate IPv4 downstream traffic from source device to destination device.</p> <code>start_iperf_ipv6</code> <p>Initiate IPv6 downstream traffic from source device to destination device.</p> <code>start_iperf_ipv6_bidirectional</code> <p>Initiate IPv6 bidirectional traffic from source device to destination device.</p> <code>start_iperf_ipv6_downstream</code> <p>Initiate IPv6 downstream traffic from source device to destination device.</p> <code>stop_iperf_traffic</code> <p>Stop the iPerf3 processes on sender as well as receiver.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.get_iperf_logs","title":"get_iperf_logs","text":"<pre><code>get_iperf_logs(iperf_data: IPerf3TrafficGenerator) -&gt; dict\n</code></pre> <p>Check logs and returns traffic flow.</p> <p>Parameters:</p> Name Type Description Default <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator, holds sender and reciever info.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>traffic logs of both server and client.</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def get_iperf_logs(iperf_data: IPerf3TrafficGenerator) -&gt; dict:\n    \"\"\"Check logs and returns traffic flow.\n\n    :param iperf_data: IPerf3TrafficGenerator, holds sender and reciever info.\n    :type iperf_data: IPerf3TrafficGenerator\n    :return: traffic logs of both server and client.\n    :rtype: dict\n    \"\"\"\n    server_logs = iperf_data.traffic_receiver.get_iperf_logs(iperf_data.server_log_file)\n    client_logs = iperf_data.traffic_sender.get_iperf_logs(iperf_data.client_log_file)\n    return {\"client_logs\": client_logs, \"server_logs\": server_logs}\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.get_iperf_logs(iperf_data)","title":"<code>iperf_data</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.parse_iperf_logs","title":"parse_iperf_logs","text":"<pre><code>parse_iperf_logs(\n    iperf_logs: str, is_client_log: bool = False, udp_only: bool | None = None\n) -&gt; dict[str, str]\n</code></pre> <p>Parse iperf logs and return bitrate, transfer etc.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>client or server logs</p> required <code>bool</code> <p>True if client logs to be prased, defaults to False</p> <code>False</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict with throughput, transfer, interval values.</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>If unable to parse output</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def parse_iperf_logs(\n    iperf_logs: str, is_client_log: bool = False, udp_only: bool | None = None\n) -&gt; dict[str, str]:\n    \"\"\"Parse iperf logs and return bitrate, transfer etc.\n\n    :param iperf_logs: client or server logs\n    :type iperf_logs: str\n    :param is_client_log: True if client logs to be prased, defaults to False\n    :type is_client_log: bool\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :raises UseCaseFailure: If unable to parse output\n    :return: dict with throughput, transfer, interval values.\n    :rtype: dict[str, str]\n    \"\"\"\n    if udp_only:\n        search_pattern = \"\"\n    else:\n        search_pattern = r\"[\\d]+\\s+sender\" if is_client_log else \"receiver\"\n    if matching_object := re.search(\n        r\"([\\d.]+-[\\d.]+)\\s+sec\\s+([\\d.]+\\s+\\w?Bytes)\\s+([\\d.]+\\s+\\w?bits/sec)\\s+\"\n        f\"{search_pattern}\",\n        iperf_logs,\n    ):\n        interval, transfer, bitrate = matching_object.groups()\n        return {\"Interval\": interval, \"Transfer\": transfer, \"Bitrate\": bitrate}\n    msg = \"Sender / Receiver data not found in the output.\"  # type:ignore[unreachable]\n    raise UseCaseFailure(msg)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.parse_iperf_logs(iperf_logs)","title":"<code>iperf_logs</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.parse_iperf_logs(is_client_log)","title":"<code>is_client_log</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.parse_iperf_logs(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.set_device_interface_state","title":"set_device_interface_state","text":"<pre><code>set_device_interface_state(\n    device: LAN | WAN | WLAN, interface: str, action: Literal[\"up\", \"down\"]\n) -&gt; None\n</code></pre> <p>Toggle the interface based on the action passed.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>str</code> <p>name of the interface</p> required <code>Literal['up', 'down']</code> <p>up or down</p> required Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def set_device_interface_state(\n    device: LAN | WAN | WLAN,\n    interface: str,\n    action: Literal[\"up\", \"down\"],\n) -&gt; None:\n    \"\"\"Toggle the interface based on the action passed.\n\n    :param device: device instance\n    :type device: LAN | WAN | WLAN\n    :param interface: name of the interface\n    :type interface: str\n    :param action: up or down\n    :type action: Literal[\"up\", \"down\"]\n    \"\"\"\n    device.set_link_state(interface, action)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.set_device_interface_state(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.set_device_interface_state(interface)","title":"<code>interface</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.set_device_interface_state(action)","title":"<code>action</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4","title":"start_iperf_ipv4","text":"<pre><code>start_iperf_ipv4(\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    direction: str | None = None,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator\n</code></pre> <p>Initiate IPv4 downstream traffic from source device to destination device.</p> <p>Starts the iPerf3 server on a traffic receiver and triggers the IPv4 only traffic from source device.</p> <p>if unable to start traffic sender, stops the process for receiver</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an iPerf server on LAN/WAN host\n- Start an iPerf client on LAN/WAN host\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>int</code> <p>source port to listen on/connect to</p> required <code>int</code> <p>time in seconds to transmit</p> required <code>bool</code> <p>use UDP rather than TCP</p> required <code>str | None</code> <p><code>--reverse</code> to run in reverse mode (server sends, client receives) defaults to None</p> <code>None</code> <code>int | None</code> <p>destination port to listen on/connect to</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the client address, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the host address, defaults to None</p> <code>None</code> <code>str | None</code> <p>IPv4 address used for iPerf traffic, defaults to None</p> <code>None</code> <code>int | None</code> <p>client port from where the traffic is getting started</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator data class that holds sender/receiver devices, their process ids and log file details</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def start_iperf_ipv4(  # pylint: disable=too-many-arguments,R0914  # noqa: PLR0913\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    direction: str | None = None,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator:\n    \"\"\"Initiate IPv4 downstream traffic from source device to destination device.\n\n    Starts the iPerf3 server on a traffic receiver and triggers the IPv4 only\n    traffic from source device.\n\n    if unable to start traffic sender, stops the process for receiver\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an iPerf server on LAN/WAN host\n        - Start an iPerf client on LAN/WAN host\n\n    :param source_device: device instance\n    :type source_device: LAN | WAN | WLAN\n    :param destination_device: device instance\n    :type destination_device: LAN | WAN | WLAN\n    :param source_port: source port to listen on/connect to\n    :type source_port: int\n    :param time: time in seconds to transmit\n    :type time: int\n    :param udp_protocol: use UDP rather than TCP\n    :type udp_protocol: bool\n    :param direction: `--reverse` to run in reverse mode (server sends, client receives)\n        defaults to None\n    :type direction: str | None\n    :param destination_port: destination port to listen on/connect to\n    :type destination_port: int | None\n    :param bind_sender_ip: bind to the interface associated with the\n        client address, defaults to None\n    :type bind_sender_ip: str | None\n    :param bind_receiver_ip: bind to the interface associated with the\n        host address, defaults to None\n    :type bind_receiver_ip: str | None\n    :param destination_ip: IPv4 address used for iPerf traffic, defaults to None\n    :type destination_ip: str | None\n    :param client_port: client port from where the traffic is getting started\n    :type client_port: int | None\n    :param udp_only: to be used if protocol is UDP only,\n        backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :return: IPerf3TrafficGenerator data class that holds\n        sender/receiver devices, their process ids and log\n        file details\n    :rtype: IPerf3TrafficGenerator\n    \"\"\"\n    dest_ip = (\n        destination_device.get_interface_ipv4addr(destination_device.iface_dut)\n        if destination_ip is None\n        else destination_ip\n    )\n    destination_port = source_port if destination_port is None else destination_port\n    dest_pid, server_log_file = destination_device.start_traffic_receiver(\n        destination_port, bind_to_ip=bind_receiver_ip, ip_version=4, udp_only=udp_only\n    )\n    try:\n        source_pid, client_log_file = source_device.start_traffic_sender(\n            dest_ip,\n            source_port,\n            bind_to_ip=bind_sender_ip,\n            ip_version=4,\n            udp_protocol=udp_protocol,\n            time=time,\n            direction=direction,\n            client_port=client_port,\n            udp_only=udp_only,\n        )\n    # handles scenario where server started but unable to start traffic sender(client)\n    # IPerf3TrafficGenerator is sent with empty pid for receiver, so that sender's\n    # process can be killed by test case.\n    except CodeError:\n        source_pid = None\n        client_log_file = \"\"\n        stop_iperf_traffic(\n            IPerf3TrafficGenerator(\n                source_device, source_pid, destination_device, dest_pid\n            )\n        )\n    return IPerf3TrafficGenerator(\n        source_device,\n        source_pid,\n        destination_device,\n        dest_pid,\n        server_log_file,\n        client_log_file,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(source_port)","title":"<code>source_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(time)","title":"<code>time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(direction)","title":"<code>direction</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(destination_port)","title":"<code>destination_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(bind_sender_ip)","title":"<code>bind_sender_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(bind_receiver_ip)","title":"<code>bind_receiver_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(destination_ip)","title":"<code>destination_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(client_port)","title":"<code>client_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional","title":"start_iperf_ipv4_bidirectional","text":"<pre><code>start_iperf_ipv4_bidirectional(\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator\n</code></pre> <p>Initiate IPv4 bidirectional traffic from source device to destination device.</p> <p>Executes the initiate_v4_traffic Use Case in bidirectional mode.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an iPerf server on LAN/WAN host\n- Start an iPerf client on LAN/WAN host\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>int</code> <p>source port to listen on/connect to</p> required <code>int</code> <p>time in seconds to transmit</p> required <code>bool</code> <p>use UDP rather than TCP</p> required <code>int | None</code> <p>destination port to listen on/connect to</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the client address, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the host address, defaults to None</p> <code>None</code> <code>str | None</code> <p>IPv4 address used for iPerf traffic, defaults to None</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator data class that holds sender/receiver devices, their process ids and log file details</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def start_iperf_ipv4_bidirectional(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator:\n    \"\"\"Initiate IPv4 bidirectional traffic from source device to destination device.\n\n    Executes the initiate_v4_traffic Use Case in bidirectional mode.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an iPerf server on LAN/WAN host\n        - Start an iPerf client on LAN/WAN host\n\n    :param source_device: device instance\n    :type source_device: LAN | WAN | WLAN\n    :param destination_device: device instance\n    :type destination_device: LAN | WAN | WLAN\n    :param source_port: source port to listen on/connect to\n    :type source_port: int\n    :param time: time in seconds to transmit\n    :type time: int\n    :param udp_protocol: use UDP rather than TCP\n    :type udp_protocol: bool\n    :param destination_port: destination port to listen on/connect to\n    :type destination_port: int | None\n    :param bind_sender_ip: bind to the interface associated with the\n        client address, defaults to None\n    :type bind_sender_ip: str | None\n    :param bind_receiver_ip: bind to the interface associated with the\n        host address, defaults to None\n    :type bind_receiver_ip: str | None\n    :param destination_ip: IPv4 address used for iPerf traffic, defaults to None\n    :type destination_ip: str | None\n    :param udp_only: to be used if protocol is UDP only,\n            backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :return: IPerf3TrafficGenerator data class that holds\n        sender/receiver devices, their process ids and log\n        file details\n    :rtype: IPerf3TrafficGenerator\n    \"\"\"\n    return start_iperf_ipv4(\n        source_device=source_device,\n        destination_device=destination_device,\n        direction=\"--bidir\",\n        source_port=source_port,\n        time=time,\n        udp_protocol=udp_protocol,\n        destination_port=destination_port,\n        bind_sender_ip=bind_sender_ip,\n        bind_receiver_ip=bind_receiver_ip,\n        destination_ip=destination_ip,\n        udp_only=udp_only,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(source_port)","title":"<code>source_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(time)","title":"<code>time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(destination_port)","title":"<code>destination_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(bind_sender_ip)","title":"<code>bind_sender_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(bind_receiver_ip)","title":"<code>bind_receiver_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(destination_ip)","title":"<code>destination_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_bidirectional(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream","title":"start_iperf_ipv4_downstream","text":"<pre><code>start_iperf_ipv4_downstream(\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator\n</code></pre> <p>Initiate IPv4 downstream traffic from source device to destination device.</p> <p>Executes the initiate_v4_traffic Use Case in downstream mode.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an iPerf server on LAN/WAN host\n- Start an iPerf client on LAN/WAN host\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>int</code> <p>source port to listen on/connect to</p> required <code>int</code> <p>time in seconds to transmit</p> required <code>bool</code> <p>use UDP rather than TCP</p> required <code>int | None</code> <p>destination port to listen on/connect to</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the client address, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the host address, defaults to None</p> <code>None</code> <code>str | None</code> <p>IPv4 address used for iPerf traffic, defaults to None</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator data class that holds sender/receiver devices, their process ids and log file details</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def start_iperf_ipv4_downstream(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator:\n    \"\"\"Initiate IPv4 downstream traffic from source device to destination device.\n\n    Executes the initiate_v4_traffic Use Case in downstream mode.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an iPerf server on LAN/WAN host\n        - Start an iPerf client on LAN/WAN host\n\n    :param source_device: device instance\n    :type source_device: LAN | WAN | WLAN\n    :param destination_device: device instance\n    :type destination_device: LAN | WAN | WLAN\n    :param source_port: source port to listen on/connect to\n    :type source_port: int\n    :param time: time in seconds to transmit\n    :type time: int\n    :param udp_protocol: use UDP rather than TCP\n    :type udp_protocol: bool\n    :param destination_port: destination port to listen on/connect to\n    :type destination_port: int | None\n    :param bind_sender_ip: bind to the interface associated with the\n        client address, defaults to None\n    :type bind_sender_ip: str | None\n    :param bind_receiver_ip: bind to the interface associated with the\n        host address, defaults to None\n    :type bind_receiver_ip: str | None\n    :param destination_ip: IPv4 address used for iPerf traffic, defaults to None\n    :type destination_ip: str | None\n    :param udp_only: to be used if protocol is UDP only,\n            backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :return: IPerf3TrafficGenerator data class that holds\n        sender/receiver devices, their process ids and log\n        file details\n    :rtype: IPerf3TrafficGenerator\n    \"\"\"\n    return start_iperf_ipv4(\n        source_device=source_device,\n        destination_device=destination_device,\n        direction=\"--reverse\",\n        source_port=source_port,\n        time=time,\n        udp_protocol=udp_protocol,\n        destination_port=destination_port,\n        bind_sender_ip=bind_sender_ip,\n        bind_receiver_ip=bind_receiver_ip,\n        destination_ip=destination_ip,\n        udp_only=udp_only,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(source_port)","title":"<code>source_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(time)","title":"<code>time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(destination_port)","title":"<code>destination_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(bind_sender_ip)","title":"<code>bind_sender_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(bind_receiver_ip)","title":"<code>bind_receiver_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(destination_ip)","title":"<code>destination_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv4_downstream(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6","title":"start_iperf_ipv6","text":"<pre><code>start_iperf_ipv6(\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    direction: str | None = None,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator\n</code></pre> <p>Initiate IPv6 downstream traffic from source device to destination device.</p> <p>Starts the iPerf3 server on a traffic receiver and triggers the IPv6 only traffic from source device.</p> <p>if unable to start traffic sender, stops the process for receiver</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an iPerf server on LAN/WAN host\n- Start an iPerf client on LAN/WAN host\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>LAN | WAN | WLAN</code> <p>device instance</p> required <code>int</code> <p>source port to listen on/connect to</p> required <code>int</code> <p>time in seconds to transmit</p> required <code>bool</code> <p>use UDP rather than TCP</p> required <code>Literal['--reverse', '--bidir']</code> <p><code>--reverse</code> to run in reverse mode (server sends, client receives) defaults to None</p> <code>None</code> <code>int | None</code> <p>destination port to listen on/connect to</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the client address, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the host address, defaults to None</p> <code>None</code> <code>str | None</code> <p>IPv6 address used for iPerf traffic, defaults to None</p> <code>None</code> <code>int | None</code> <p>client port from where the traffic is getting started</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator data class that holds sender/receiver devices, their process ids and log file details</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def start_iperf_ipv6(  # pylint: disable=too-many-arguments,R0914  # noqa: PLR0913\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    direction: str | None = None,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    client_port: int | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator:\n    \"\"\"Initiate IPv6 downstream traffic from source device to destination device.\n\n    Starts the iPerf3 server on a traffic receiver and triggers the IPv6 only\n    traffic from source device.\n\n    if unable to start traffic sender, stops the process for receiver\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an iPerf server on LAN/WAN host\n        - Start an iPerf client on LAN/WAN host\n\n    :param source_device: device instance\n    :type source_device: LAN | WAN | WLAN\n    :param destination_device: device instance\n    :type destination_device: LAN | WAN | WLAN\n    :type direction: Literal[\"--reverse\", \"--bidir\"]\n    :param source_port: source port to listen on/connect to\n    :type source_port: int\n    :param time: time in seconds to transmit\n    :type time: int\n    :param udp_protocol: use UDP rather than TCP\n    :type udp_protocol: bool\n    :param direction: `--reverse` to run in reverse mode (server sends, client receives)\n        defaults to None\n    :type direction: str | None\n    :param destination_port: destination port to listen on/connect to\n    :type destination_port: int | None\n    :param bind_sender_ip: bind to the interface associated with the\n        client address, defaults to None\n    :type bind_sender_ip: str | None\n    :param bind_receiver_ip: bind to the interface associated with the\n        host address, defaults to None\n    :type bind_receiver_ip: str | None\n    :param destination_ip: IPv6 address used for iPerf traffic, defaults to None\n    :type destination_ip: str | None\n    :param client_port: client port from where the traffic is getting started\n    :type client_port: int | None\n    :param udp_only: to be used if protocol is UDP only,\n            backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :return: IPerf3TrafficGenerator data class that holds\n        sender/receiver devices, their process ids and log\n        file details\n    :rtype: IPerf3TrafficGenerator\n    \"\"\"\n    dest_ip6 = (\n        destination_device.get_interface_ipv6addr(destination_device.iface_dut)\n        if destination_ip is None\n        else destination_ip\n    )\n    destination_port = source_port if destination_port is None else destination_port\n    dest_pid, server_log_file = destination_device.start_traffic_receiver(\n        destination_port, bind_to_ip=bind_receiver_ip, ip_version=6, udp_only=udp_only\n    )\n    try:\n        source_pid, client_log_file = source_device.start_traffic_sender(\n            dest_ip6,\n            source_port,\n            bind_to_ip=bind_sender_ip,\n            ip_version=6,\n            udp_protocol=udp_protocol,\n            time=time,\n            direction=direction,\n            client_port=client_port,\n            udp_only=udp_only,\n        )\n    # handles scenario where server started but unable to start traffic sender(client)\n    # IPerf3TrafficGenerator is sent with empty pid for receiver, so that sender's\n    # process can be killed by test case.\n    except CodeError:\n        source_pid = None\n        client_log_file = \"\"\n        stop_iperf_traffic(\n            IPerf3TrafficGenerator(\n                source_device, source_pid, destination_device, dest_pid\n            )\n        )\n    return IPerf3TrafficGenerator(\n        source_device,\n        source_pid,\n        destination_device,\n        dest_pid,\n        server_log_file,\n        client_log_file,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(source_port)","title":"<code>source_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(time)","title":"<code>time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(direction)","title":"<code>direction</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(destination_port)","title":"<code>destination_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(bind_sender_ip)","title":"<code>bind_sender_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(bind_receiver_ip)","title":"<code>bind_receiver_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(destination_ip)","title":"<code>destination_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(client_port)","title":"<code>client_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional","title":"start_iperf_ipv6_bidirectional","text":"<pre><code>start_iperf_ipv6_bidirectional(\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator\n</code></pre> <p>Initiate IPv6 bidirectional traffic from source device to destination device.</p> <p>Executes the initiate_v6_traffic Use Case in bidirectional mode.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an iPerf server on LAN/WAN host\n- Start an iPerf client on LAN/WAN host\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance for iperf client</p> required <code>LAN | WAN | WLAN</code> <p>device instance for iPerf server</p> required <code>int</code> <p>server port to listen on/connect to</p> required <code>int</code> <p>time in seconds to transmit</p> required <code>bool</code> <p>use UDP rather than TCP</p> required <code>int | None</code> <p>destination port to listen on/connect to, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the client address,, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the host address, defaults to None</p> <code>None</code> <code>str | None</code> <p>IPv6 address used for iPerf traffic, defaults to None</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator data class that holds sender/receiver devices, their process ids and log file details</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def start_iperf_ipv6_bidirectional(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator:\n    \"\"\"Initiate IPv6 bidirectional traffic from source device to destination device.\n\n    Executes the initiate_v6_traffic Use Case in bidirectional mode.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an iPerf server on LAN/WAN host\n        - Start an iPerf client on LAN/WAN host\n\n    :param source_device: device instance for iperf client\n    :type source_device: LAN | WAN | WLAN\n    :param destination_device: device instance for iPerf server\n    :type destination_device: LAN | WAN | WLAN\n    :param source_port: server port to listen on/connect to\n    :type source_port: int\n    :param time: time in seconds to transmit\n    :type time: int\n    :param udp_protocol: use UDP rather than TCP\n    :type udp_protocol: bool\n    :param destination_port: destination port to listen on/connect to, defaults to None\n    :type destination_port: int | None\n    :param bind_sender_ip: bind to the interface associated with the\n        client address,, defaults to None\n    :type bind_sender_ip: str | None\n    :param bind_receiver_ip: bind to the interface associated with the\n        host address, defaults to None\n    :type bind_receiver_ip: str | None,\n    :param destination_ip: IPv6 address used for iPerf traffic, defaults to None\n    :type destination_ip: str | None\n    :param udp_only: to be used if protocol is UDP only,\n            backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :return: IPerf3TrafficGenerator data class that holds\n        sender/receiver devices, their process ids and log\n        file details\n    :rtype: IPerf3TrafficGenerator\n    \"\"\"\n    return start_iperf_ipv6(\n        source_device=source_device,\n        destination_device=destination_device,\n        direction=\"--bidir\",\n        source_port=source_port,\n        time=time,\n        udp_protocol=udp_protocol,\n        destination_port=destination_port,\n        bind_sender_ip=bind_sender_ip,\n        bind_receiver_ip=bind_receiver_ip,\n        destination_ip=destination_ip,\n        udp_only=udp_only,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(source_port)","title":"<code>source_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(time)","title":"<code>time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(destination_port)","title":"<code>destination_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(bind_sender_ip)","title":"<code>bind_sender_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(bind_receiver_ip)","title":"<code>bind_receiver_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(destination_ip)","title":"<code>destination_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_bidirectional(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream","title":"start_iperf_ipv6_downstream","text":"<pre><code>start_iperf_ipv6_downstream(\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator\n</code></pre> <p>Initiate IPv6 downstream traffic from source device to destination device.</p> <p>Executes the initiate_v6_traffic Use Case with downstream mode.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an iPerf server on LAN/WAN host\n- Start an iPerf client on LAN/WAN host\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device instance for iperf client</p> required <code>LAN | WAN | WLAN</code> <p>device instance for iPerf server</p> required <code>int</code> <p>server port to listen on/connect to</p> required <code>int</code> <p>time in seconds to transmit</p> required <code>bool</code> <p>use UDP rather than TCP</p> required <code>int | None</code> <p>destination port to listen on/connect to, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the client address,, defaults to None</p> <code>None</code> <code>str | None</code> <p>bind to the interface associated with the host address, defaults to None</p> <code>None</code> <code>str | None</code> <p>IPv6 address used for iPerf traffic, defaults to None</p> <code>None</code> <code>bool | None</code> <p>to be used if protocol is UDP only, backward compatibility with iperf version 2</p> <code>None</code> <p>Returns:</p> Type Description <code>IPerf3TrafficGenerator</code> <p>IPerf3TrafficGenerator data class that holds sender/receiver devices, their process ids and log file details</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def start_iperf_ipv6_downstream(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WAN | WLAN,\n    destination_device: LAN | WAN | WLAN,\n    source_port: int,\n    time: int,\n    udp_protocol: bool,\n    destination_port: int | None = None,\n    bind_sender_ip: str | None = None,\n    bind_receiver_ip: str | None = None,\n    destination_ip: str | None = None,\n    udp_only: bool | None = None,\n) -&gt; IPerf3TrafficGenerator:\n    \"\"\"Initiate IPv6 downstream traffic from source device to destination device.\n\n    Executes the initiate_v6_traffic Use Case with downstream mode.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an iPerf server on LAN/WAN host\n        - Start an iPerf client on LAN/WAN host\n\n    :param source_device: device instance for iperf client\n    :type source_device: LAN | WAN | WLAN\n    :param destination_device: device instance for iPerf server\n    :type destination_device: LAN | WAN | WLAN\n    :param source_port: server port to listen on/connect to\n    :type source_port: int\n    :param time: time in seconds to transmit\n    :type time: int\n    :param udp_protocol: use UDP rather than TCP\n    :type udp_protocol: bool\n    :param destination_port: destination port to listen on/connect to, defaults to None\n    :type destination_port: int | None\n    :param bind_sender_ip: bind to the interface associated with the\n        client address,, defaults to None\n    :type bind_sender_ip: str | None\n    :param bind_receiver_ip: bind to the interface associated with the\n        host address, defaults to None\n    :type bind_receiver_ip: str | None,\n    :param destination_ip: IPv6 address used for iPerf traffic, defaults to None\n    :type destination_ip: str | None\n    :param udp_only: to be used if protocol is UDP only,\n            backward compatibility with iperf version 2\n    :type udp_only: bool, optional\n    :return: IPerf3TrafficGenerator data class that holds\n        sender/receiver devices, their process ids and log\n        file details\n    :rtype: IPerf3TrafficGenerator\n    \"\"\"\n    return start_iperf_ipv6(\n        source_device=source_device,\n        destination_device=destination_device,\n        direction=\"--reverse\",\n        source_port=source_port,\n        time=time,\n        udp_protocol=udp_protocol,\n        destination_port=destination_port,\n        bind_sender_ip=bind_sender_ip,\n        bind_receiver_ip=bind_receiver_ip,\n        destination_ip=destination_ip,\n        udp_only=udp_only,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(source_port)","title":"<code>source_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(time)","title":"<code>time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(udp_protocol)","title":"<code>udp_protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(destination_port)","title":"<code>destination_port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(bind_sender_ip)","title":"<code>bind_sender_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(bind_receiver_ip)","title":"<code>bind_receiver_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(destination_ip)","title":"<code>destination_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.start_iperf_ipv6_downstream(udp_only)","title":"<code>udp_only</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.stop_iperf_traffic","title":"stop_iperf_traffic","text":"<pre><code>stop_iperf_traffic(iperf_generator: IPerf3TrafficGenerator) -&gt; None\n</code></pre> <p>Stop the iPerf3 processes on sender as well as receiver.</p> <p>Parameters:</p> Name Type Description Default <code>IPerf3TrafficGenerator</code> <p>data class that holds sender/receiver devices and their process IDs</p> required <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>when either iPerf3 server or client PID can't be killed</p> Source code in <code>boardfarm3/use_cases/iperf.py</code> <pre><code>def stop_iperf_traffic(iperf_generator: IPerf3TrafficGenerator) -&gt; None:\n    \"\"\"Stop the iPerf3 processes on sender as well as receiver.\n\n    :param iperf_generator: data class that holds sender/receiver devices and\n        their process IDs\n    :type iperf_generator: IPerf3TrafficGenerator\n    :raises UseCaseFailure: when either iPerf3 server or client PID can't be killed\n    \"\"\"\n    sender = (\n        iperf_generator.traffic_sender.stop_traffic(iperf_generator.sender_pid)\n        if iperf_generator.traffic_sender and iperf_generator.sender_pid\n        else None\n    )\n\n    receiver = (\n        iperf_generator.traffic_receiver.stop_traffic(iperf_generator.receiver_pid)\n        if iperf_generator.traffic_receiver and iperf_generator.receiver_pid\n        else None\n    )\n\n    if (iperf_generator.sender_pid and not sender) or (\n        iperf_generator.receiver_pid and not receiver\n    ):\n        msg = (\n            \"Either Sender(Client) or Receiver(Server) process cannot be killed:\",\n            f\"{sender=} - {receiver=}\",\n        )\n        raise UseCaseFailure(msg)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.iperf.stop_iperf_traffic(iperf_generator)","title":"<code>iperf_generator</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast","title":"multicast","text":"<p>Multicast Use Cases.</p> <p>This will include connecting to a multicast stream via iPerf, ip-mroute or smcroute.</p> <p>Functions:</p> Name Description <code>join_iperf_multicast_asm_group</code> <p>Start an iPerf server binding to a multicast address in background.</p> <code>join_iperf_multicast_ssm_group</code> <p>Start an iPerf server binding to a multicast address in background.</p> <code>kill_all_iperf</code> <p>Kill all iPerf sessions on target devices.</p> <code>leave_iperf_multicast_group</code> <p>Send IGMP leave to stop receiving multicast traffic.</p> <code>parse_mcast_trace</code> <p>Compare captured PCAP file against an expected sequence of packets.</p> <code>start_iperf_multicast_stream</code> <p>Start an iPerf client sending data on multicast address in background.</p> <code>tcpdump</code> <p>Start packet capture using tcpdump and kill the process at the end.</p> <code>wait_for_multicast_stream_to_end</code> <p>Wait for all multicast streams to end.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_asm_group","title":"join_iperf_multicast_asm_group","text":"<pre><code>join_iperf_multicast_asm_group(\n    on_which_device: IperfDevice, multicast_group_addr: str, port: int\n) -&gt; IPerfSession\n</code></pre> <p>Start an iPerf server binding to a multicast address in background.</p> <p>This Use Case is applicable for ASM (any-source multicast) channels (*,G)</p> <p>Session will have the following parameters by default:     - 1s interval between periodic bandwidth, jitter,       and loss reports.</p> <p>The Use Case will return an iPerf Session object holding following info: - Target device class object on which iperf command is executed - PID of the iPerf session - Multicast group address - Multicast port - CSV output file of the iperf session</p> <p>.. note::</p> <pre><code>- CSV output file can only be accessed once you leave the multicast group.\n</code></pre> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an Ethernet LAN client to request CPE for\n  IPv4 ASM traffic from WAN multicast server\n- Start client to join/subscribe any source multicast channel (S,G)\n  by sending IGMPv3 report\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>IperfDevice</code> <p>Object of the device that joins the mcast group</p> required <code>str</code> <p>multicast stream's group IP address to join</p> required <code>int</code> <p>multicast stream's port number</p> required <p>Returns:</p> Type Description <code>IPerfSession</code> <p>object holding data on the iPerf Session</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>if there is a multicat stream.</p> Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>def join_iperf_multicast_asm_group(\n    on_which_device: IperfDevice,\n    multicast_group_addr: str,\n    port: int,\n) -&gt; IPerfSession:\n    r\"\"\"Start an iPerf server binding to a multicast address in background.\n\n    This Use Case is applicable for ASM (any-source multicast) channels (\\*,G)\n\n    Session will have the following parameters by default:\n        - 1s interval between periodic bandwidth, jitter,\n          and loss reports.\n\n    The Use Case will return an iPerf Session object holding\n    following info:\n    - Target device class object on which iperf command is executed\n    - PID of the iPerf session\n    - Multicast group address\n    - Multicast port\n    - CSV output file of the iperf session\n\n    .. note::\n\n        - CSV output file can only be accessed once you leave the multicast group.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an Ethernet LAN client to request CPE for\n          IPv4 ASM traffic from WAN multicast server\n        - Start client to join/subscribe any source multicast channel (S,G)\n          by sending IGMPv3 report\n\n    :param on_which_device: Object of the device that joins the mcast group\n    :type on_which_device: IperfDevice\n    :param multicast_group_addr: multicast stream's group IP address to join\n    :type multicast_group_addr: str\n    :param port: multicast stream's port number\n    :type port: int\n    :return: object holding data on the iPerf Session\n    :rtype: IPerfSession\n    :raises UseCaseFailure: if there is a multicat stream.\n    \"\"\"\n    dev = on_which_device\n    ipv6_flag = \"\"\n\n    if isinstance(ip_address(multicast_group_addr), IPv6Address):\n        ipv6_flag = \"-V\"\n\n    # Cannot have any iperf session running for the same mul\n    if _is_multicast_stream_active(dev, multicast_group_addr, port):\n        msg = (\n            f\"{dev} already has an iperf session with \"\n            f\"port {port} and multicast address {multicast_group_addr}\"\n        )\n        raise UseCaseFailure(msg)\n\n    fname = f\"mclient_{port}.txt\"\n\n    # run iperf, format result as CSV\n    dev.console.execute_command(\n        f\"iperf {ipv6_flag} -s -f m -u -U -p {port} \"\n        f\"-B {multicast_group_addr} \"\n        f\"-i 1 -y C &gt; {fname} &amp;\"\n    )\n\n    pid = dev.console.execute_command(\n        f\"pgrep iperf -a | grep {port} | awk '{{print$1}}'\"\n    )\n    return IPerfSession(on_which_device, pid, multicast_group_addr, port, fname)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_asm_group(on_which_device)","title":"<code>on_which_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_asm_group(multicast_group_addr)","title":"<code>multicast_group_addr</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_asm_group(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_ssm_group","title":"join_iperf_multicast_ssm_group","text":"<pre><code>join_iperf_multicast_ssm_group(\n    on_which_device: IperfDevice,\n    multicast_source_addr: str,\n    multicast_group_addr: str,\n    port: int,\n) -&gt; IPerfSession\n</code></pre> <p>Start an iPerf server binding to a multicast address in background.</p> <p>This Use Case is applicable for SSM (source-specific multicast) channels (S,G)</p> <p>Session will have the following parameters by default:     - 1s interval between periodic bandwidth, jitter,       and loss reports.</p> <p>The Use Case will return an iPerf Session object holding following info: - Target device class object on which iperf command is executed - PID of the iperf session - Multicast group address - Multicast port - CSV output file of the iPerf session</p> <p>.. note::</p> <pre><code>- The multicast source will always be a WAN device.\n- CSV output file can only be accessed once you leave the multicast group.\n</code></pre> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start an Ethernet LAN client to request CPE for\n  IPv4 SSM traffic from WAN multicast server\n- Start client to join/subscribe a specific source and Group (S,G)\n  channel by sending IGMPv3 report\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>IperfDevice</code> <p>Object of the device that joins the mcast group</p> required <code>str</code> <p>WAN IP address used to run the mcast stream</p> required <code>str</code> <p>multicast stream's group IP address to join</p> required <code>int</code> <p>multicast stream's port number</p> required <p>Returns:</p> Type Description <code>IPerfSession</code> <p>object holding data on the iPerf Session</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>if there is a multicat stream.</p> Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>def join_iperf_multicast_ssm_group(\n    on_which_device: IperfDevice,\n    multicast_source_addr: str,\n    multicast_group_addr: str,\n    port: int,\n) -&gt; IPerfSession:\n    \"\"\"Start an iPerf server binding to a multicast address in background.\n\n    This Use Case is applicable for SSM (source-specific multicast) channels (S,G)\n\n    Session will have the following parameters by default:\n        - 1s interval between periodic bandwidth, jitter,\n          and loss reports.\n\n    The Use Case will return an iPerf Session object holding\n    following info:\n    - Target device class object on which iperf command is executed\n    - PID of the iperf session\n    - Multicast group address\n    - Multicast port\n    - CSV output file of the iPerf session\n\n    .. note::\n\n        - The multicast source will always be a WAN device.\n        - CSV output file can only be accessed once you leave the multicast group.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start an Ethernet LAN client to request CPE for\n          IPv4 SSM traffic from WAN multicast server\n        - Start client to join/subscribe a specific source and Group (S,G)\n          channel by sending IGMPv3 report\n\n    :param on_which_device: Object of the device that joins the mcast group\n    :type on_which_device: IperfDevice\n    :param multicast_source_addr: WAN IP address used to run the mcast stream\n    :type multicast_source_addr: str\n    :param multicast_group_addr: multicast stream's group IP address to join\n    :type multicast_group_addr: str\n    :param port: multicast stream's port number\n    :type port: int\n    :return: object holding data on the iPerf Session\n    :rtype: IPerfSession\n    :raises UseCaseFailure: if there is a multicat stream.\n    \"\"\"\n    dev = on_which_device\n    ipv6_flag = \"\"\n\n    if isinstance(ip_address(multicast_source_addr), IPv6Address) and isinstance(\n        ip_address(multicast_group_addr), IPv6Address\n    ):\n        ipv6_flag = \"-V\"\n\n    # Cannot have any iperf session running for the same mul\n    if _is_multicast_stream_active(dev, multicast_group_addr, port):\n        msg = (\n            f\"{dev} already has an iperf session with \"\n            f\"port {port} and multicast address {multicast_group_addr}\"\n        )\n        raise UseCaseFailure(msg)\n\n    fname = f\"mclient_{port}.txt\"\n\n    # run iperf, format result as CSV\n    dev.console.execute_command(\n        f\"iperf {ipv6_flag} -s -f m -u -U -p {port} \"\n        f\"-B {multicast_group_addr} --ssm-host {multicast_source_addr} \"\n        f\"-i 1 -y C &gt; {fname} &amp;\"\n    )\n\n    pid = dev.console.execute_command(\n        f\"pgrep iperf -a | grep {port} | awk '{{print$1}}'\"\n    )\n    return IPerfSession(on_which_device, pid, multicast_group_addr, port, fname)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_ssm_group(on_which_device)","title":"<code>on_which_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_ssm_group(multicast_source_addr)","title":"<code>multicast_source_addr</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_ssm_group(multicast_group_addr)","title":"<code>multicast_group_addr</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.join_iperf_multicast_ssm_group(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.kill_all_iperf","title":"kill_all_iperf","text":"<pre><code>kill_all_iperf(device_list: list[IperfDevice]) -&gt; None\n</code></pre> <p>Kill all iPerf sessions on target devices.</p> <p>This should be called for cleaning purposes.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Kill all iPerf session on target devices.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>list[IperfDevice]</code> <p>list of target devices</p> required Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>def kill_all_iperf(device_list: list[IperfDevice]) -&gt; None:\n    \"\"\"Kill all iPerf sessions on target devices.\n\n    This should be called for cleaning purposes.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Kill all iPerf session on target devices.\n\n    :param device_list: list of target devices\n    :type device_list: list[IPerfDevice]\n    \"\"\"\n    for device in device_list:\n        device.multicast.kill_all_iperf_sessions()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.kill_all_iperf(device_list)","title":"<code>device_list</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.leave_iperf_multicast_group","title":"leave_iperf_multicast_group","text":"<pre><code>leave_iperf_multicast_group(session: IPerfSession) -&gt; IPerfResult\n</code></pre> <p>Send IGMP leave to stop receiving multicast traffic.</p> <p>This is achieved by stopping the iPerf server bounded to a multicast channel ASM/SSM.</p> <p>Executes a kill -15  on target device. In case of IGMPv3, will send a block old sources membership report. <p>Parameters:</p> Name Type Description Default <code>IPerfSession</code> <p>Session object created during the join</p> required <p>Returns:</p> Type Description <code>IPerfResult</code> <p>iPerf result</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>If the device fails to leave the multicast group.</p> Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>def leave_iperf_multicast_group(session: IPerfSession) -&gt; IPerfResult:\n    \"\"\"Send IGMP leave to stop receiving multicast traffic.\n\n    This is achieved by stopping the iPerf server bounded\n    to a multicast channel ASM/SSM.\n\n    Executes a kill -15 &lt;iPerf session pid&gt; on target device.\n    In case of IGMPv3, will send a block old sources membership report.\n\n    :param session: Session object created during the join\n    :type session: IPerfSession\n    :return: iPerf result\n    :rtype: IPerfResult\n    :raises UseCaseFailure: If the device fails to leave the multicast group.\n    \"\"\"\n    dev = session.device\n\n    if not _is_multicast_stream_active(dev, session.address, session.port):\n        # Something is wrong, there should be a process ID always.\n\n        err_msg = (\n            f\"iperf session with port {session.port} \"\n            f\"and {session.address} multicast group does \"\n            f\"not exist on {dev}\"\n        )\n\n        raise UseCaseFailure(err_msg)\n\n    # kill -15 iperf session\n    dev.console.execute_command(f\"kill -15 {session.pid}\")\n    out = dev.console.execute_command(f\"cat {session.output_file}\")\n\n    # remove the file after reading results\n    dev.console.execute_command(f\"rm {session.output_file}\")\n    if not out.strip():\n        return IPerfResult(None)\n\n    csv = pd.read_csv(StringIO(out.strip()))\n    cols = [\n        \"timestamp\",\n        \"source_address\",\n        \"source_port\",\n        \"destination_address\",\n        \"destination_port\",\n        \"id\",\n        \"interval\",\n        \"transferred_bytes\",\n        \"bandwidth\",\n        \"jitter\",\n        \"lost\",\n        \"total\",\n    ]\n\n    results = pd.DataFrame(csv.iloc[:, :-2].values, columns=cols)\n    return IPerfResult(results)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.leave_iperf_multicast_group(session)","title":"<code>session</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.parse_mcast_trace","title":"parse_mcast_trace","text":"<pre><code>parse_mcast_trace(\n    dev: IperfDevice,\n    fname: str,\n    expected_sequence: list[tuple[str, ...]],\n    ip_version: int = 4,\n) -&gt; list[tuple[str, ...]]\n</code></pre> <p>Compare captured PCAP file against an expected sequence of packets.</p> <p>This returns a matched subset of the whole packet trace. The sequence of the matched packets must align with expected sequence. The length of the matched sequence is equal to expected sequence.</p> <p>In case a packet is missing in captured sequence, an empty value is maintained in output at the same index as that of the expected sequence.</p> <p>IP packets in expected sequence must follow the following order:</p> <pre><code>- IP source\n- IP destination\n- MAC source\n- MAC destination\n- IP protocol number (1 - ICMP, 2 - IGMP, 6 - TCP, 17 - UDP)\n- IGMP version (v3 by default)\n- IGMP Record Type number (5 - Allow new sources, 6 - Block old sources)\n- IGMP Multicast Address (if provided in group records)\n- IGMP Source Address (if provided in group records)\n</code></pre> <p>IPv6 packets will be parsed and following values are returned in a list:</p> <pre><code>- IPv6 source\n- IPv6 destination\n- MAC source\n- MAC destination\n- IPv6 Next Header (0 - ICMPv6, 6 - TCP, 17 - UDP)\n- MLDv2 version (130 - MLDv2 Query, 143 - MLDv2 Report)\n- MLDv2 Record Type number (5 - Allow new sources, 6 - Block old sources)\n- MLDv2 Multicast Address (if provided in group records)\n- MLDv2 Source Address (if provided in group records)\n</code></pre> <p>You can use * to mark a field as Any</p> <p>.. hint:: This Use Case implements statements from the test suite such as:    test suite such as:</p> <pre><code>- Check IGMPv3 report to subscribe to (S,G) from LAN on eRouter\n  LAN interface\n- Check Multicast traffic from WAN multicast server is received\n  on eRouter WAN interface and forwarded to Ethernet LAN client\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>IperfDevice</code> <p>Descriptor of iPerf capable device with PCAP file</p> required <code>str</code> <p>name of the PCAP file</p> required <code>list[tuple[str, ...]]</code> <p>expected sequence to match against captured sequence</p> required <code>int</code> <p>IP version, defaults to 4</p> <code>4</code> <p>Returns:</p> Type Description <code>list[tuple[str, ...]]</code> <p>matched captured sequence against the expected sequence</p> Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>def parse_mcast_trace(\n    dev: IperfDevice,\n    fname: str,\n    expected_sequence: list[tuple[str, ...]],\n    ip_version: int = 4,\n) -&gt; list[tuple[str, ...]]:\n    \"\"\"Compare captured PCAP file against an expected sequence of packets.\n\n    This returns a matched subset of the whole packet trace.\n    The sequence of the matched packets must align with expected sequence.\n    The length of the matched sequence is equal to expected sequence.\n\n    In case a packet is missing in captured sequence, an empty value is\n    maintained in output at the same index as that of the expected sequence.\n\n    IP packets in expected sequence must follow the following order:\n\n        - IP source\n        - IP destination\n        - MAC source\n        - MAC destination\n        - IP protocol number (1 - ICMP, 2 - IGMP, 6 - TCP, 17 - UDP)\n        - IGMP version (v3 by default)\n        - IGMP Record Type number (5 - Allow new sources, 6 - Block old sources)\n        - IGMP Multicast Address (if provided in group records)\n        - IGMP Source Address (if provided in group records)\n\n    IPv6 packets will be parsed and following values are returned in a list:\n\n        - IPv6 source\n        - IPv6 destination\n        - MAC source\n        - MAC destination\n        - IPv6 Next Header (0 - ICMPv6, 6 - TCP, 17 - UDP)\n        - MLDv2 version (130 - MLDv2 Query, 143 - MLDv2 Report)\n        - MLDv2 Record Type number (5 - Allow new sources, 6 - Block old sources)\n        - MLDv2 Multicast Address (if provided in group records)\n        - MLDv2 Source Address (if provided in group records)\n\n    You can use * to mark a field as Any\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n       test suite such as:\n\n        - Check IGMPv3 report to subscribe to (S,G) from LAN on eRouter\n          LAN interface\n        - Check Multicast traffic from WAN multicast server is received\n          on eRouter WAN interface and forwarded to Ethernet LAN client\n\n    :param dev: Descriptor of iPerf capable device with PCAP file\n    :type dev: IperfDevice\n    :param fname: name of the PCAP file\n    :type fname: str\n    :param expected_sequence: expected sequence to match against captured sequence\n    :type expected_sequence: list[tuple[str, ...]]\n    :param ip_version: IP version, defaults to 4\n    :type ip_version: int\n    :return: matched captured sequence against the expected sequence\n    :rtype: list[tuple[str, ...]]\n    \"\"\"\n    return dev.multicast.parse_mcast_trace(fname, expected_sequence, ip_version)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.parse_mcast_trace(dev)","title":"<code>dev</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.parse_mcast_trace(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.parse_mcast_trace(expected_sequence)","title":"<code>expected_sequence</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.parse_mcast_trace(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.start_iperf_multicast_stream","title":"start_iperf_multicast_stream","text":"<pre><code>start_iperf_multicast_stream(\n    on_which_device: WAN,\n    multicast_group_addr: str,\n    port: int,\n    time: int,\n    bit_rate: float,\n) -&gt; IPerfStream\n</code></pre> <p>Start an iPerf client sending data on multicast address in background.</p> <p>Session will have the following parameters by default:     - TTL value set to 5</p> <p>.. hint:: This Use Case implements statements from the    test suite such as:</p> <pre><code>- Start multicast server on WAN network to provide\n  the multicast traffic in unreserved multicast group IP\n  range 232.0.0.0/8\n- Start multicast server on WAN network to provide\n  the multicast traffic in unreserved multicast group IP\n  range FF38::8000:0/96\n- Start multicast stream on a specific Group channel\n  by sending IGMPv3 report\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>WAN</code> <p>WAN object that runs the multicast stream.</p> required <code>str</code> <p>multicast stream's group IP address</p> required <code>int</code> <p>multicast stream's port number</p> required <code>int</code> <p>total time the session should run for</p> required <code>float</code> <p>bit_rate of data to be sent (in Mbps)</p> required <p>Returns:</p> Type Description <code>IPerfStream</code> <p>object holding data on the iPerf stream.</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>if there is a multicat stream.</p> Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>def start_iperf_multicast_stream(\n    on_which_device: WAN,\n    multicast_group_addr: str,\n    port: int,\n    time: int,\n    bit_rate: float,\n) -&gt; IPerfStream:\n    \"\"\"Start an iPerf client sending data on multicast address in background.\n\n    Session will have the following parameters by default:\n        - TTL value set to 5\n\n    .. hint:: This Use Case implements statements from the\n       test suite such as:\n\n        - Start multicast server on WAN network to provide\n          the multicast traffic in unreserved multicast group IP\n          range 232.0.0.0/8\n        - Start multicast server on WAN network to provide\n          the multicast traffic in unreserved multicast group IP\n          range FF38::8000:0/96\n        - Start multicast stream on a specific Group channel\n          by sending IGMPv3 report\n\n    :param on_which_device: WAN object that runs the multicast stream.\n    :type on_which_device: WAN\n    :param multicast_group_addr: multicast stream's group IP address\n    :type multicast_group_addr: str\n    :param port: multicast stream's port number\n    :type port: int\n    :param time: total time the session should run for\n    :type time: int\n    :param bit_rate: bit_rate of data to be sent (in Mbps)\n    :type bit_rate: float\n    :return: object holding data on the iPerf stream.\n    :rtype: IPerfStream\n    :raises UseCaseFailure: if there is a multicat stream.\n    \"\"\"\n    dev = on_which_device\n    ipv6_flag = \"\"\n\n    if isinstance(ip_address(multicast_group_addr), IPv6Address):\n        ipv6_flag = \"-V\"\n\n    # Ensure there is no exisiting stream with same IP and port.\n    if _is_multicast_stream_active(dev, multicast_group_addr, port):\n        msg = (\n            f\"{dev} already has an iperf session with \"\n            f\"port {port} and multicast address {multicast_group_addr}\"\n        )\n        raise UseCaseFailure(msg)\n    fname = f\"mserver_{port}.txt\"\n\n    dev.console.execute_command(\n        f\"iperf {ipv6_flag} -u -f m -c {multicast_group_addr} \"\n        f\"-p {port} --ttl 5 \"\n        f\"-t {time} -b {bit_rate}m &gt; {fname} &amp;\"\n    )\n\n    pid = dev.console.execute_command(\n        f\"pgrep iperf -a | grep {port} | awk '{{print$1}}'\"\n    )\n    return IPerfStream(on_which_device, pid, multicast_group_addr, port, fname, time)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.start_iperf_multicast_stream(on_which_device)","title":"<code>on_which_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.start_iperf_multicast_stream(multicast_group_addr)","title":"<code>multicast_group_addr</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.start_iperf_multicast_stream(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.start_iperf_multicast_stream(time)","title":"<code>time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.start_iperf_multicast_stream(bit_rate)","title":"<code>bit_rate</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.tcpdump","title":"tcpdump","text":"<pre><code>tcpdump(\n    dev: IperfDevice, fname: str, filters: str | None = \"ip multicast\"\n) -&gt; Generator[str]\n</code></pre> <p>Start packet capture using tcpdump and kill the process at the end.</p> <p>Applies specific filter for multicast traffic only.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Capturing packets sent from and to eRouter WAN and eRouter LAN interfaces\n- Make sure you can capture packets sent from and to eRouter WAN interface\n  and Ethernet LAN client\n</code></pre> <p>:yield: process ID</p> <p>Parameters:</p> Name Type Description Default <code>IperfDevice</code> <p>LAN, WAN or WLAN device instance</p> required <code>str</code> <p>name of the pcap file to which the capture will be stored</p> required <code>str | None</code> <p>additional filters for capture, defaults to \"ip multicast\"</p> <code>'ip multicast'</code> Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>@contextmanager\ndef tcpdump(\n    dev: IperfDevice,\n    fname: str,\n    filters: str | None = \"ip multicast\",\n) -&gt; Generator[str]:\n    \"\"\"Start packet capture using tcpdump and kill the process at the end.\n\n    Applies specific filter for multicast traffic only.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Capturing packets sent from and to eRouter WAN and eRouter LAN interfaces\n        - Make sure you can capture packets sent from and to eRouter WAN interface\n          and Ethernet LAN client\n\n    :param dev: LAN, WAN or WLAN device instance\n    :type dev: IperfDevice\n    :param fname: name of the pcap file to which the capture will be stored\n    :type fname: str\n    :param filters: additional filters for capture, defaults to \"ip multicast\"\n    :type filters: str | None\n    :yield: process ID\n    :rtype: Generator[str, None, None]\n    \"\"\"\n    with dev.tcpdump_capture(fname, dev.iface_dut, filters) as pid:\n        yield pid\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.tcpdump(dev)","title":"<code>dev</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.tcpdump(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.wait_for_multicast_stream_to_end","title":"wait_for_multicast_stream_to_end","text":"<pre><code>wait_for_multicast_stream_to_end(stream_list: list[IPerfStream]) -&gt; None\n</code></pre> <p>Wait for all multicast streams to end.</p> <p>The Use Case will wait for a time equal to the stream with the highest wait time.</p> <p>If a stream from the list does not exit within the max wait time, then throw an error.</p> <p>.. hint:: To be used along with the Use Case start_iperf_multicast_stream</p> <p>Parameters:</p> Name Type Description Default <code>list[IPerfStream]</code> <p>List of IPerfStreams</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if empty list is passed</p> <code>UseCaseFailure</code> <p>if a session fails to exit.</p> Source code in <code>boardfarm3/use_cases/multicast.py</code> <pre><code>def wait_for_multicast_stream_to_end(stream_list: list[IPerfStream]) -&gt; None:\n    \"\"\"Wait for all multicast streams to end.\n\n    The Use Case will wait for a time equal to the stream with\n    the highest wait time.\n\n    If a stream from the list does not exit within the\n    max wait time, then throw an error.\n\n    .. hint:: To be used along with the Use Case start_iperf_multicast_stream\n\n    :param stream_list: List of IPerfStreams\n    :type stream_list: list[IPerfStream]\n    :raises ValueError: if empty list is passed\n    :raises UseCaseFailure: if a session fails to exit.\n    \"\"\"\n    if not stream_list:\n        msg = \"Cannot pass an empty session list!\"\n        raise ValueError(msg)\n\n    max_time_to_wait = max(stream.time for stream in stream_list)\n\n    # Should expect all streams to be closed by now\n    # This is not asyncio, no high expectations\n    sleep(max_time_to_wait)\n\n    failed_sessions = []\n    for stream in stream_list:\n        # try twice before raising exception.\n        dev = stream.device\n        for _ in range(2):\n            if not dev.console.execute_command(\n                f\"pgrep iperf -a | grep {stream.port}| grep {stream.address}\"\n            ):\n                break\n            sleep(1)\n        else:\n            dev.console.execute_command(f\"kill -9 {stream.pid}\")\n            failed_sessions.append(\n                f\"{stream.address}:{stream.port} did not exit within {stream.time}s\"\n            )\n        dev.console.execute_command(f\"rm {stream.output_file}\")\n\n    if failed_sessions:\n        raise UseCaseFailure(\"Following sessions failed:\\n\".join(failed_sessions))\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.multicast.wait_for_multicast_stream_to_end(stream_list)","title":"<code>stream_list</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking","title":"networking","text":"<p>Common Networking use cases.</p> <p>Functions:</p> Name Description <code>connect_via_ssh</code> <p>SSH from a device to another.</p> <code>create_tcp_session</code> <p>Create a TCP session from source to destination device on a port.</p> <code>create_tcp_udp_session</code> <p>Create both TCP and UDP session from source to destination device on a port.</p> <code>create_udp_session</code> <p>Create a UDP session from source to destination device on a port.</p> <code>delete_arp_table_entry</code> <p>Delete arp table entry.</p> <code>disable_ipv6</code> <p>Disable ipv6 on the specified interface.</p> <code>dns_lookup</code> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <code>enable_ipv6</code> <p>Enable IPv6 on the specified interface.</p> <code>flush_arp_cache</code> <p>Flushes arp cache entries.</p> <code>get_arp_table_info</code> <p>Fetch arp entries.</p> <code>get_interface_mac_addr</code> <p>Get the MAC address of the provided interface.</p> <code>get_ip6tables_list</code> <p>Return ip6tables rules as dictionary.</p> <code>get_ip6tables_policy</code> <p>Get firewall's ip6tables policy.</p> <code>get_iptables_list</code> <p>Return iptables rules as dictionary.</p> <code>get_iptables_policy</code> <p>Return iptables policies as dictionary.</p> <code>get_nslookup_data</code> <p>Perform nslookup with given arguments and return the parsed results.</p> <code>hping_flood</code> <p>Validate SYN, UDP and ICMP flood operation.</p> <code>http_get</code> <p>Check if the given HTTP server is running.</p> <code>is_client_ip_in_pool</code> <p>Check for client IP in IP pool.</p> <code>is_icmp_packet_present</code> <p>Check whether the expected ICMP sequence matches with the captured sequence.</p> <code>is_ip6table_empty</code> <p>Return True if ip6tables is empty.</p> <code>is_iptable_empty</code> <p>Return True if iptables is empty.</p> <code>netcat</code> <p>Run netcat command to initiate brute force.</p> <code>netstat_all_tcp</code> <p>Get all TCP ports.</p> <code>netstat_all_udp</code> <p>Get all UDP ports.</p> <code>netstat_listening_ports</code> <p>Get all listening ports.</p> <code>nmap_scan</code> <p>Perform Complete scan on destination via nmap network utility on source device.</p> <code>nping</code> <p>Perform nping command and kill process once done.</p> <code>ping</code> <p>Ping remote host IP.</p> <code>start_http_server</code> <p>Start http server on given client.</p> <code>trigger_ip_flood</code> <p>Perform IP flooding via nmap network utility on source device.</p> <code>verify_tunnel_packets</code> <p>Verify the expected encapsulated info with the captured sequence.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.connect_via_ssh","title":"connect_via_ssh","text":"<pre><code>connect_via_ssh(\n    from_which_device: SSHDeviceType,\n    to_which_device: SSHDeviceType,\n    protocol: int = 4,\n    username: str = \"root\",\n    password: str = \"bigfoot1\",\n) -&gt; bool\n</code></pre> <p>SSH from a device to another.</p> <p>This use case validates if SSH is possible from a device to another.</p> <p>Parameters:</p> Name Type Description Default <code>SSHDeviceType</code> <p>Device initiating the SSH connection</p> required <code>SSHDeviceType</code> <p>Target SSH device</p> required <code>int</code> <p>IP address family, defaults to 4</p> <code>4</code> <code>str</code> <p>SSH username, defaults to root</p> <code>'root'</code> <code>str</code> <p>SSH password, defaults to bigfoot1</p> <code>'bigfoot1'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if SSH successful, else False</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If connectivity exists, but SSH not successful</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def connect_via_ssh(\n    from_which_device: SSHDeviceType,\n    to_which_device: SSHDeviceType,\n    protocol: int = 4,\n    username: str = \"root\",\n    password: str = \"bigfoot1\",  # noqa: S107\n) -&gt; bool:\n    \"\"\"SSH from a device to another.\n\n    This use case validates if SSH is possible from a device to another.\n\n    :param from_which_device: Device initiating the SSH connection\n    :type from_which_device: SSHDeviceType\n    :param to_which_device: Target SSH device\n    :type to_which_device: SSHDeviceType\n    :param protocol: IP address family, defaults to 4\n    :type protocol: int\n    :param username: SSH username, defaults to root\n    :type username: str\n    :param password: SSH password, defaults to bigfoot1\n    :type password: str\n    :raises ConnectionError: If connectivity exists, but SSH not successful\n    :return: True if SSH successful, else False\n    :rtype: bool\n    \"\"\"\n    def_protocol = 4\n    address = (\n        to_which_device.ipv4_addr\n        if protocol == def_protocol\n        else to_which_device.ipv6_addr\n    )\n    ssh_command = f\"ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \\\n        -o UserKnownHostsFile=/dev/null {username}@{address} exit\"\n    from_which_device.console.sendline(ssh_command)\n    index = from_which_device.console.expect(\n        [\"assword:\", DEFAULT_BASH_SHELL_PROMPT_PATTERN]\n    )\n    if index == 0:\n        from_which_device.console.sendline(f\"{password}\")\n        index = from_which_device.console.expect(\n            [\"assword:\", DEFAULT_BASH_SHELL_PROMPT_PATTERN]\n        )\n        if index == 0:\n            from_which_device.console.sendcontrol(\"c\")\n            from_which_device.console.expect(DEFAULT_BASH_SHELL_PROMPT_PATTERN)\n            return False\n        if from_which_device.console.execute_command(\"echo $?\") != \"0\":\n            msg = \"SSH not successful - needs troubleshooting.\"\n            raise ConnectionError(msg)\n        return True\n    return False\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.connect_via_ssh(from_which_device)","title":"<code>from_which_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.connect_via_ssh(to_which_device)","title":"<code>to_which_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.connect_via_ssh(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.connect_via_ssh(username)","title":"<code>username</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.connect_via_ssh(password)","title":"<code>password</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_session","title":"create_tcp_session","text":"<pre><code>create_tcp_session(\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    max_retries: int = 4,\n    timeout: int = 30,\n) -&gt; dict[str, str]\n</code></pre> <p>Create a TCP session from source to destination device on a port.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Create a TCP session from source to destination device on a port.\n</code></pre> <p>Runs nmap network utility on source device.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN | WAN</code> <p>Source device</p> required <code>LAN | WLAN | WAN | CPE</code> <p>destination device</p> required <code>str</code> <p>type of IP address: \"ipv4\", \"ipv6\"</p> required <code>str | int</code> <p>port or range of ports: \"666-999\"</p> required <code>int</code> <p>maximum number retries for nmap</p> <code>4</code> <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict[str,str]</code> <p>XML output of the nmap command in form of dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def create_tcp_session(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    max_retries: int = 4,\n    timeout: int = 30,\n) -&gt; dict[str, str]:\n    \"\"\"Create a TCP session from source to destination device on a port.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Create a TCP session from source to destination device on a port.\n\n    Runs nmap network utility on source device.\n\n    :param source_device: Source device\n    :type source_device: LAN | WLAN | WAN\n    :param destination_device: destination device\n    :type destination_device: LAN | WLAN | WAN | CPE\n    :param ip_type: type of IP address: \"ipv4\", \"ipv6\"\n    :type ip_type: str\n    :param port: port or range of ports: \"666-999\"\n    :type port: str | int\n    :param max_retries: maximum number retries for nmap\n    :type max_retries: int\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :return: XML output of the nmap command in form of dictionary\n    :rtype: dict[str,str]\n    \"\"\"\n    return nmap(\n        source_device,\n        destination_device,\n        ip_type,\n        port,\n        \"-sT\",\n        max_retries,\n        timeout=timeout,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_session(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_session(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_session(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_session(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_session(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_session(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_udp_session","title":"create_tcp_udp_session","text":"<pre><code>create_tcp_udp_session(\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    max_retries: int = 4,\n    timeout: int = 30,\n) -&gt; dict[str, str]\n</code></pre> <p>Create both TCP and UDP session from source to destination device on a port.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Run nmap from client to erouter WAN IP.\n</code></pre> <p>Runs nmap network utility on source device.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN | WAN</code> <p>source device</p> required <code>LAN | WLAN | WAN | CPE</code> <p>destination device</p> required <code>str</code> <p>type of IP address: \"ipv4\", \"ipv6\"</p> required <code>str | int</code> <p>port or range of ports: \"666-999\"</p> required <code>int</code> <p>maximum number retries for nmap</p> <code>4</code> <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict[str,str]</code> <p>XML output of the nmap command in form of dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def create_tcp_udp_session(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    max_retries: int = 4,\n    timeout: int = 30,\n) -&gt; dict[str, str]:\n    \"\"\"Create both TCP and UDP session from source to destination device on a port.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Run nmap from client to erouter WAN IP.\n\n    Runs nmap network utility on source device.\n\n    :param source_device: source device\n    :type source_device: LAN | WLAN | WA\n    :param destination_device: destination device\n    :type destination_device: LAN | WLAN | WAN | CPE\n    :param ip_type: type of IP address: \"ipv4\", \"ipv6\"\n    :type ip_type: str\n    :param port: port or range of ports: \"666-999\"\n    :type port: str | int\n    :param max_retries: maximum number retries for nmap\n    :type max_retries: int\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :return: XML output of the nmap command in form of dictionary\n    :rtype: dict[str,str]\n    \"\"\"\n    return nmap(\n        source_device,\n        destination_device,\n        ip_type,\n        port,\n        \"-sU -sT\",\n        max_retries,\n        timeout=timeout,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_udp_session(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_udp_session(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_udp_session(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_udp_session(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_udp_session(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_tcp_udp_session(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_udp_session","title":"create_udp_session","text":"<pre><code>create_udp_session(\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    max_retries: int,\n    timeout: int = 30,\n) -&gt; dict[str, str]\n</code></pre> <p>Create a UDP session from source to destination device on a port.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Create a UDP session from source to destination device on a port.\n</code></pre> <p>Runs nmap network utility on source device.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN | WAN</code> <p>Source device</p> required <code>LAN | WLAN | WAN | CPE</code> <p>Destination device</p> required <code>str</code> <p>type of ipaddress: \"ipv4\", \"ipv6\"</p> required <code>str | int</code> <p>port or range of ports: \"666-999\"</p> required <code>int</code> <p>maximum number retries for nmap</p> required <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict[str,str]</code> <p>XML output of the nmap command in form of dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def create_udp_session(  # pylint: disable=too-many-arguments  # noqa: PLR0913\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    max_retries: int,\n    timeout: int = 30,\n) -&gt; dict[str, str]:\n    \"\"\"Create a UDP session from source to destination device on a port.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Create a UDP session from source to destination device on a port.\n\n    Runs nmap network utility on source device.\n\n    :param source_device: Source device\n    :type source_device: LAN | WLAN | WAN\n    :param destination_device: Destination device\n    :type destination_device: LAN | WLAN | WAN | CPE\n    :param ip_type: type of ipaddress: \"ipv4\", \"ipv6\"\n    :type ip_type: str\n    :param port: port or range of ports: \"666-999\"\n    :type port: str | int\n    :param max_retries: maximum number retries for nmap\n    :type max_retries: int\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :return: XML output of the nmap command in form of dictionary\n    :rtype: dict[str,str]\n    \"\"\"\n    return nmap(\n        source_device,\n        destination_device,\n        ip_type,\n        port,\n        \"-sU\",\n        max_retries,\n        timeout=timeout,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_udp_session(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_udp_session(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_udp_session(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_udp_session(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_udp_session(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.create_udp_session(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.delete_arp_table_entry","title":"delete_arp_table_entry","text":"<pre><code>delete_arp_table_entry(device: LAN, ip: str, intf: str) -&gt; None\n</code></pre> <p>Delete arp table entry.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>Delete ARP table entry\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN</code> <p>device on which cache to be cleared</p> required <code>str</code> <p>ip of the host entry to be deleted</p> required <code>str</code> <p>interface on which the host needs to be deleted</p> required Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def delete_arp_table_entry(device: LAN, ip: str, intf: str) -&gt; None:\n    \"\"\"Delete arp table entry.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        Delete ARP table entry\n\n    :param device: device on which cache to be cleared\n    :type device: LAN\n    :param ip: ip of the host entry to be deleted\n    :type ip: str\n    :param intf: interface on which the host needs to be deleted\n    :type intf: str\n    \"\"\"\n    device.delete_arp_table_entry(ip, intf)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.delete_arp_table_entry(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.delete_arp_table_entry(ip)","title":"<code>ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.delete_arp_table_entry(intf)","title":"<code>intf</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.disable_ipv6","title":"disable_ipv6","text":"<pre><code>disable_ipv6(device: LAN | WLAN) -&gt; None\n</code></pre> <p>Disable ipv6 on the specified interface.</p> <p>The use case executes the following commands:     - sysctl net.ipv6.conf..disable_ipv6=1 <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Disable IPv6 on the specified interface.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN</code> <p>LAN or WLAN device object</p> required Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def disable_ipv6(device: LAN | WLAN) -&gt; None:\n    \"\"\"Disable ipv6 on the specified interface.\n\n    The use case executes the following commands:\n        - sysctl net.ipv6.conf.&lt;interface&gt;.disable_ipv6=1\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Disable IPv6 on the specified interface.\n\n    :param device: LAN or WLAN device object\n    :type device: LAN | WLAN\n    \"\"\"\n    device.disable_ipv6()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.disable_ipv6(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.dns_lookup","title":"dns_lookup","text":"<pre><code>dns_lookup(\n    host: LAN | WAN, domain_name: str, ipv6: bool = False, opts: str = \"\"\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Perform <code>dig</code> command in the devices to resolve DNS.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify that IPv4 domain name can be resolved to IP.\n- Verify the DNS IPv4 address assigned by the service provider\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>host where the dig command has to be run</p> required <code>str</code> <p>domain name which needs lookup</p> required <code>bool</code> <p>flag to perform IPv4 or IPv6 lookup, defaults to False</p> <code>False</code> <code>str</code> <p>options to be provided to dig command, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>returns dig output from jc parser</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>when domain_name cannot resolve</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def dns_lookup(\n    host: LAN | WAN, domain_name: str, ipv6: bool = False, opts: str = \"\"\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Perform ``dig`` command in the devices to resolve DNS.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify that IPv4 domain name can be resolved to IP.\n        - Verify the DNS IPv4 address assigned by the service provider\n\n    :param host: host where the dig command has to be run\n    :type host: LAN | WAN\n    :param domain_name: domain name which needs lookup\n    :type domain_name: str\n    :param ipv6: flag to perform IPv4 or IPv6 lookup, defaults to False\n    :type ipv6: bool\n    :param opts: options to be provided to dig command, defaults to \"\"\n    :type opts: str\n    :return: returns dig output from jc parser\n    :rtype: List[Dict[str, Any]]\n    :raises UseCaseFailure: when domain_name cannot resolve\n    \"\"\"\n    record_type = \"AAAA\" if ipv6 else \"A\"\n    result = host.dns_lookup(domain_name, record_type, opts)\n    if result:\n        return result\n    msg = f\"Failed to resolve {domain_name}\"\n    raise UseCaseFailure(msg)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.dns_lookup(host)","title":"<code>host</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.dns_lookup(domain_name)","title":"<code>domain_name</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.dns_lookup(ipv6)","title":"<code>ipv6</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.dns_lookup(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.enable_ipv6","title":"enable_ipv6","text":"<pre><code>enable_ipv6(device: LAN | WLAN) -&gt; None\n</code></pre> <p>Enable IPv6 on the specified interface.</p> <p>The Use Case executes the following commands:     - sysctl net.ipv6.conf..disable_ipv6=0     - sysctl net.ipv6.conf..accept_ra=2 <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Enable IPv6 on the specified interface.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN</code> <p>LAN or WLAN device object</p> required Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def enable_ipv6(device: LAN | WLAN) -&gt; None:\n    \"\"\"Enable IPv6 on the specified interface.\n\n    The Use Case executes the following commands:\n        - sysctl net.ipv6.conf.&lt;interface&gt;.disable_ipv6=0\n        - sysctl net.ipv6.conf.&lt;interface&gt;.accept_ra=2\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Enable IPv6 on the specified interface.\n\n    :param device: LAN or WLAN device object\n    :type device: LAN | WLAN\n    \"\"\"\n    device.enable_ipv6()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.enable_ipv6(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.flush_arp_cache","title":"flush_arp_cache","text":"<pre><code>flush_arp_cache(device: LAN) -&gt; None\n</code></pre> <p>Flushes arp cache entries.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>Generate ARP Request for...\n</code></pre> <ul> <li>ping can be used post clearing cache and ARP pakcets can be ovserved in     pkt capture</li> </ul> <p>Parameters:</p> Name Type Description Default <code>LAN</code> <p>device on which cache to be cleared</p> required Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def flush_arp_cache(device: LAN) -&gt; None:\n    \"\"\"Flushes arp cache entries.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        Generate ARP Request for...\n\n    - ping can be used post clearing cache and ARP pakcets can be ovserved in\n        pkt capture\n\n    :param device: device on which cache to be cleared\n    :type device: LAN\n    \"\"\"\n    device.flush_arp_cache()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.flush_arp_cache(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_arp_table_info","title":"get_arp_table_info","text":"<pre><code>get_arp_table_info(device: LAN) -&gt; list[dict[str, str]]\n</code></pre> <p>Fetch arp entries.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>Show ARP table / Get ARP entries\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN</code> <p>device on which cache to be cleared</p> required <p>Returns:</p> Type Description <code>list[dict[str, str]]</code> <p>list of parsed ARP table entries</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def get_arp_table_info(device: LAN) -&gt; list[dict[str, str]]:\n    \"\"\"Fetch arp entries.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        Show ARP table / Get ARP entries\n\n    :param device: device on which cache to be cleared\n    :type device: LAN\n    :return: list of parsed ARP table entries\n    :rtype: list[dict[str, str]]\n    \"\"\"\n    arp_table: list[dict[str, str]] = []\n    out = device.get_arp_table()\n    arp_regex = re.compile(\n        r\"(?P&lt;address&gt;\\d+.\\d+.\\d+.\\d+)\\s+(?P&lt;hw_type&gt;\\S+)\\s+\"\n        r\"(?P&lt;hw_address&gt;\\S+)\\s+(?P&lt;flags_mask&gt;\\S+)\\s+(?P&lt;iface&gt;\\S+)\"\n    )\n    for entry in out.splitlines()[1:]:\n        arp_entry = re.search(arp_regex, entry)\n        if arp_entry:\n            arp_table.append(arp_entry.groupdict())\n    return arp_table\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_arp_table_info(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_interface_mac_addr","title":"get_interface_mac_addr","text":"<pre><code>get_interface_mac_addr(device: LAN | WLAN | WAN | CPE, interface: str) -&gt; str\n</code></pre> <p>Get the MAC address of the provided interface.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Get the mac address of the provided interface.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN | WAN | CPE</code> <p>device having the interface</p> required <code>str</code> <p>interface name</p> required <p>Returns:</p> Type Description <code>str</code> <p>MAC address of the provided interface</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def get_interface_mac_addr(device: LAN | WLAN | WAN | CPE, interface: str) -&gt; str:\n    \"\"\"Get the MAC address of the provided interface.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Get the mac address of the provided interface.\n\n    :param device: device having the interface\n    :type device: LAN | WLAN | WAN | CPE\n    :param interface: interface name\n    :type interface: str\n    :return: MAC address of the provided interface\n    :rtype: str\n    \"\"\"\n    return (\n        device.sw.get_interface_mac_addr(interface)\n        if isinstance(device, CPE)\n        else device.get_interface_macaddr(interface)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_interface_mac_addr(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_interface_mac_addr(interface)","title":"<code>interface</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_list","title":"get_ip6tables_list","text":"<pre><code>get_ip6tables_list(\n    device: DeviceWithFwType, opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; dict[str, list[dict]]\n</code></pre> <p>Return ip6tables rules as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>DeviceWithFwType</code> <p>type of the device</p> required <code>str</code> <p>_command line arguments for ip6tables command, defaults to \"\"</p> <code>''</code> <code>str</code> <p>extra command line arguments for ip6tables command, defaults to -nvL --line-number</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>dict[str, list[dict]]</code> <p>ip6tables rules dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def get_ip6tables_list(\n    device: DeviceWithFwType,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; dict[str, list[dict]]:\n    \"\"\"Return ip6tables rules as dictionary.\n\n    :param device: type of the device\n    :type device: DeviceWithFwType\n    :param opts: _command line arguments for ip6tables command, defaults to \"\"\n    :type opts: str\n    :param extra_opts: extra command line arguments for ip6tables command,\n        defaults to -nvL --line-number\n    :type extra_opts: str\n    :return: ip6tables rules dictionary\n    :rtype: dict[str, list[dict]]\n    \"\"\"\n    return (\n        device.firewall.get_ip6tables_list(opts, extra_opts)\n        if not isinstance(device, CPE)\n        else device.sw.firewall.get_ip6tables_list(opts, extra_opts)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_list(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_list(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_list(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_policy","title":"get_ip6tables_policy","text":"<pre><code>get_ip6tables_policy(\n    device: DeviceWithFwType, opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; dict[str, str]\n</code></pre> <p>Get firewall's ip6tables policy.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Get the Firewall's ip6tables policy\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>DeviceWithFwType</code> <p>device instance</p> required <code>str</code> <p>options for ip6tables command, defaults to \"\"</p> <code>''</code> <code>str</code> <p>options for ip6tables command, defaults to \"-nvL --line-number\"</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict of ip6tables policy</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def get_ip6tables_policy(\n    device: DeviceWithFwType,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; dict[str, str]:\n    \"\"\"Get firewall's ip6tables policy.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Get the Firewall's ip6tables policy\n\n    :param device: device instance\n    :type device: DeviceWithFwType\n    :param opts: options for ip6tables command, defaults to \"\"\n    :type opts: str\n    :param extra_opts: options for ip6tables command, defaults to \"-nvL --line-number\"\n    :type extra_opts: str\n    :return: dict of ip6tables policy\n    :rtype: dict[str, str]\n    \"\"\"\n    return (\n        device.firewall.get_ip6tables_policy(opts, extra_opts)\n        if not isinstance(device, CPE)\n        else device.sw.firewall.get_ip6tables_policy(opts, extra_opts)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_policy(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_policy(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_ip6tables_policy(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_list","title":"get_iptables_list","text":"<pre><code>get_iptables_list(\n    device: DeviceWithFwType, opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; dict[str, list[dict]]\n</code></pre> <p>Return iptables rules as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>DeviceWithFwType</code> <p>type of the device</p> required <code>str</code> <p>_command line arguments for iptables command, defaults to \"\"</p> <code>''</code> <code>str</code> <p>extra command line arguments for iptables command, defaults to -nvL --line-number</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>dict[str, list[dict]]</code> <p>iptables rules dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def get_iptables_list(\n    device: DeviceWithFwType,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; dict[str, list[dict]]:\n    \"\"\"Return iptables rules as dictionary.\n\n    :param device: type of the device\n    :type device: DeviceWithFwType\n    :param opts: _command line arguments for iptables command, defaults to \"\"\n    :type opts: str\n    :param extra_opts: extra command line arguments for iptables command,\n        defaults to -nvL --line-number\n    :type extra_opts: str\n    :return: iptables rules dictionary\n    :rtype: dict[str, list[dict]]\n    \"\"\"\n    return (\n        device.firewall.get_iptables_list(opts, extra_opts)\n        if not isinstance(device, CPE)\n        else device.sw.firewall.get_iptables_list(opts, extra_opts)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_list(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_list(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_list(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_policy","title":"get_iptables_policy","text":"<pre><code>get_iptables_policy(\n    device: DeviceWithFwType, opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; dict[str, str]\n</code></pre> <p>Return iptables policies as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>DeviceWithFwType</code> <p>type of the device</p> required <code>str</code> <p>command line arguments for iptables command, defaults to \"\"</p> <code>''</code> <code>str</code> <p>extra command line arguments for iptables command, defaults to \"-nvL --line-number\"</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>iptables policies dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def get_iptables_policy(\n    device: DeviceWithFwType,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; dict[str, str]:\n    \"\"\"Return iptables policies as dictionary.\n\n    :param device: type of the device\n    :type device: DeviceWithFwType\n    :param opts: command line arguments for iptables command, defaults to \"\"\n    :type opts: str\n    :param extra_opts: extra command line arguments for iptables command,\n        defaults to \"-nvL --line-number\"\n    :type extra_opts: str\n    :return: iptables policies dictionary\n    :rtype: dict[str, str]\n    \"\"\"\n    return (\n        device.firewall.get_iptables_policy(opts, extra_opts)\n        if not isinstance(device, CPE)\n        else device.sw.firewall.get_iptables_policy(opts, extra_opts)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_policy(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_policy(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_iptables_policy(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_nslookup_data","title":"get_nslookup_data","text":"<pre><code>get_nslookup_data(\n    device: LAN | WAN, domain_name: str, opts: str = \"\", extra_opts: str = \"\"\n) -&gt; dict[str, Any]\n</code></pre> <p>Perform nslookup with given arguments and return the parsed results.</p> <p>to get A records, pass -q=A in opts</p> <p>to get AAAA records, pass -q=AAAA in opts</p> <p>to just get the DNS records, opts and extra opts are not needed</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>type of the device</p> required <code>str</code> <p>domain name to perform nslookup on</p> required <code>str</code> <p>nslookup command line options, defaults to \"\"</p> <code>''</code> <code>str</code> <p>nslookup additional command line options, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>parsed nslookup results as dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def get_nslookup_data(\n    device: LAN | WAN,\n    domain_name: str,\n    opts: str = \"\",\n    extra_opts: str = \"\",\n) -&gt; dict[str, Any]:\n    \"\"\"Perform nslookup with given arguments and return the parsed results.\n\n    to get A records, pass -q=A in opts\n\n    to get AAAA records, pass -q=AAAA in opts\n\n    to just get the DNS records, opts and extra opts are not needed\n\n    :param device: type of the device\n    :type device: Union[LAN, WAN]\n    :param domain_name: domain name to perform nslookup on\n    :type domain_name: str\n    :param opts: nslookup command line options, defaults to \"\"\n    :type opts: str\n    :param extra_opts: nslookup additional command line options, defaults to \"\"\n    :type extra_opts: str\n    :return: parsed nslookup results as dictionary\n    :rtype: dict[str, Any]\n    \"\"\"\n    return device.nslookup.nslookup(domain_name, opts, extra_opts)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_nslookup_data(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_nslookup_data(domain_name)","title":"<code>domain_name</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_nslookup_data(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.get_nslookup_data(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.hping_flood","title":"hping_flood","text":"<pre><code>hping_flood(\n    device: LAN | WAN,\n    protocol: str,\n    target: str,\n    packet_count: str,\n    extra_args: str | None = None,\n    pkt_interval: str = \"\",\n) -&gt; str\n</code></pre> <p>Validate SYN, UDP and ICMP flood operation.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- To validate SYN flood, ICMP flood (from WAN &amp; LAN) and UDP flood (from WAN)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>object of the device class where tcpdump is captured</p> required <code>str</code> <p>mode, for ex 'S': syn-flood '1': ping-flood (icmp) '2': udp</p> required <code>str</code> <p>target IP addr</p> required <code>str</code> <p>number of packets to be transmitted.</p> required <code>str | None</code> <p>extra arguments to be passed, defaults to None</p> <code>None</code> <code>str</code> <p>wait for X microseconds before sending next packet uX, defaults to \"\", uX for X microseconds, for example -i u1000</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>command output</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def hping_flood(  # noqa: PLR0913\n    device: LAN | WAN,\n    protocol: str,\n    target: str,\n    packet_count: str,\n    extra_args: str | None = None,\n    pkt_interval: str = \"\",\n) -&gt; str:\n    \"\"\"Validate SYN, UDP and ICMP flood operation.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - To validate SYN flood, ICMP flood (from WAN &amp; LAN) and UDP flood (from WAN)\n\n    :param device: object of the device class where tcpdump is captured\n    :type device: LAN | WAN\n    :param protocol: mode, for ex 'S': syn-flood '1': ping-flood (icmp) '2': udp\n    :type protocol: str\n    :param target: target IP addr\n    :type target: str\n    :param packet_count: number of packets to be transmitted.\n    :type packet_count: str\n    :param extra_args: extra arguments to be passed, defaults to None\n    :type extra_args: str\n    :param pkt_interval: wait for X microseconds before sending next packet uX,\n        defaults to \"\", uX for X microseconds, for example -i u1000\n    :type pkt_interval: str\n    :return: command output\n    :rtype: str\n    \"\"\"\n    return device.hping_flood(\n        protocol=protocol,\n        target=target,\n        packet_count=packet_count,\n        extra_args=extra_args,\n        pkt_interval=pkt_interval,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.hping_flood(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.hping_flood(protocol)","title":"<code>protocol</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.hping_flood(target)","title":"<code>target</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.hping_flood(packet_count)","title":"<code>packet_count</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.hping_flood(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.hping_flood(pkt_interval)","title":"<code>pkt_interval</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.http_get","title":"http_get","text":"<pre><code>http_get(\n    device: LAN | WAN,\n    url: str,\n    timeout: int = 20,\n    no_proxy: bool = False,\n    is_insecure: bool = False,\n    follow_redirects: bool = False,\n) -&gt; HTTPResult\n</code></pre> <p>Check if the given HTTP server is running.</p> <p>This Use Case executes a curl command with a given timeout from the given client. The destination is specified by the URL parameter</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify HTTP server is accessible from [] via eRouter IP\n- Verify that the HTTP server running on the client is accessible\n- Try to connect to the HTTP server from [] client\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>the device from where HTTP response to get</p> required <code>str</code> <p>URL to get the response</p> required <code>int</code> <p>connection timeout for the curl command in seconds, default 20</p> <code>20</code> <code>bool</code> <p>no_proxy option for curl command, defaults to False</p> <code>False</code> <code>bool</code> <p>is_insecure option for curl command, defaults to False</p> <code>False</code> <code>bool</code> <p>follow_redirects option for curl command, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>HTTPResult</code> <p>parsed HTTP Get response</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def http_get(  # noqa: PLR0913\n    device: LAN | WAN,\n    url: str,\n    timeout: int = 20,\n    no_proxy: bool = False,\n    is_insecure: bool = False,\n    follow_redirects: bool = False,\n) -&gt; HTTPResult:\n    \"\"\"Check if the given HTTP server is running.\n\n    This Use Case executes a curl command with a given timeout from the given\n    client. The destination is specified by the URL parameter\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify HTTP server is accessible from [] via eRouter IP\n        - Verify that the HTTP server running on the client is accessible\n        - Try to connect to the HTTP server from [] client\n\n    :param device: the device from where HTTP response to get\n    :type device: LAN | WAN\n    :param url: URL to get the response\n    :type url: str\n    :param timeout: connection timeout for the curl command in seconds, default 20\n    :type timeout: int\n    :param no_proxy: no_proxy option for curl command, defaults to False\n    :type no_proxy: bool\n    :param is_insecure: is_insecure option for curl command, defaults to False\n    :type is_insecure: bool\n    :param follow_redirects: follow_redirects option for curl command, defaults to False\n    :type follow_redirects: bool\n    :return: parsed HTTP Get response\n    :rtype: HTTPResult\n    \"\"\"\n    options = \"\"\n    if no_proxy:\n        options += \"--noproxy '*' \"\n    if is_insecure:\n        options += \"-k \"\n    if follow_redirects:\n        options += \"-L \"\n    return device.http_get(url, timeout, options)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.http_get(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.http_get(url)","title":"<code>url</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.http_get(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.http_get(no_proxy)","title":"<code>no_proxy</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.http_get(is_insecure)","title":"<code>is_insecure</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.http_get(follow_redirects)","title":"<code>follow_redirects</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_client_ip_in_pool","title":"is_client_ip_in_pool","text":"<pre><code>is_client_ip_in_pool(\n    pool_bounds: tuple[IPv4Address, IPv4Address], client: LAN | WAN\n) -&gt; bool\n</code></pre> <p>Check for client IP in IP pool.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Configure the LAN client with Static IP from the higher range of the subnet\n  defined in the config file and Default gateway is set to the lowest IP\n  (eRouter LAN interface) address of subnet\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tuple[IPv4Address, IPv4Address]</code> <p>lowest and highest IP from DHCP pool</p> required <code>LAN | WAN</code> <p>client to be checked</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if LAN/WIFILAN IP is lowest in pool range</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def is_client_ip_in_pool(\n    pool_bounds: tuple[ipaddress.IPv4Address, ipaddress.IPv4Address],\n    client: LAN | WAN,\n) -&gt; bool:\n    \"\"\"Check for client IP in IP pool.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Configure the LAN client with Static IP from the higher range of the subnet\n          defined in the config file and Default gateway is set to the lowest IP\n          (eRouter LAN interface) address of subnet\n\n    :param pool_bounds: lowest and highest IP from DHCP pool\n    :type pool_bounds: tuple[ipaddress.IPv4Address, ipaddress.IPv4Address]\n    :param client: client to be checked\n    :type client: LAN | WAN\n    :return: True if LAN/WIFILAN IP is lowest in pool range\n    :rtype: bool\n    \"\"\"\n    lan_ip_address = ipaddress.IPv4Address(\n        client.get_interface_ipv4addr(client.iface_dut),\n    )\n    ip_range = ip_pool_to_list(*pool_bounds)\n    return lan_ip_address in ip_range\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_client_ip_in_pool(pool_bounds)","title":"<code>pool_bounds</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_client_ip_in_pool(client)","title":"<code>client</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_icmp_packet_present","title":"is_icmp_packet_present","text":"<pre><code>is_icmp_packet_present(\n    captured_sequence: list[ICMPPacketData], expected_sequence: list[ICMPPacketData]\n) -&gt; bool\n</code></pre> <p>Check whether the expected ICMP sequence matches with the captured sequence.</p> <p>Parameters:</p> Name Type Description Default <code>list[ICMPPacketData]</code> <p>Sequence of ICMP packets filtered from captured pcap file</p> required <code>list[ICMPPacketData]</code> <p>Example for IPv4 source and destination and <code>query_code</code> as 8 (Echo Request)  .. code-block:: python  [ ICMPPacketData( IPAddresses(IPv4Address(\"172.25.1.109\"), None, None), IPAddresses(IPv4Address(\"192.168.178.22\"), None, None), 8, ), ]  .. hint:: This Use Case implements statements from the test suite such as:  - Check whether the expected ICMP sequence matches with the captured sequence.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if ICMP expected sequences matches with the captured sequence</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def is_icmp_packet_present(\n    captured_sequence: list[ICMPPacketData],\n    expected_sequence: list[ICMPPacketData],\n) -&gt; bool:\n    \"\"\"Check whether the expected ICMP sequence matches with the captured sequence.\n\n    :param captured_sequence: Sequence of ICMP packets filtered from captured pcap file\n    :type captured_sequence: List[ICMPPacketData]\n    :param expected_sequence: Example for IPv4 source and destination and ``query_code``\n        as 8 (Echo Request)\n\n            .. code-block:: python\n\n                [\n                    ICMPPacketData(\n                        IPAddresses(IPv4Address(\"172.25.1.109\"), None, None),\n                        IPAddresses(IPv4Address(\"192.168.178.22\"), None, None),\n                        8,\n                    ),\n                ]\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Check whether the expected ICMP sequence matches with the captured sequence.\n\n    :type expected_sequence: List[ICMPPacketData]\n    :return: True if ICMP expected sequences matches with the captured sequence\n    :rtype: bool\n    \"\"\"\n    last_check = 0\n    final_result = []\n    for icmp_packet_expected in expected_sequence:\n        for i in range(last_check, len(captured_sequence)):\n            if captured_sequence[i] == icmp_packet_expected:\n                last_check = i\n                _LOGGER.info(\n                    colored(\n                        f\"Verified ICMP packet:\\t{icmp_packet_expected.source}\\t\"\n                        f\"--&gt;&gt;\\t{icmp_packet_expected.destination}\\tType:\"\n                        f\" {icmp_packet_expected.query_code}\",\n                        color=\"green\",\n                    ),\n                )\n                final_result.append(True)\n                break\n        else:\n            _LOGGER.info(\n                colored(\n                    \"Couldn't verify ICMP packet:\\t\"\n                    f\"{icmp_packet_expected.source}\\t--&gt;&gt;\\t\"\n                    f\"{icmp_packet_expected.destination}\\tType:\"\n                    f\" {icmp_packet_expected.query_code}\",\n                    color=\"red\",\n                ),\n            )\n            final_result.append(False)\n    return all(final_result)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_icmp_packet_present(captured_sequence)","title":"<code>captured_sequence</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_icmp_packet_present(expected_sequence)","title":"<code>expected_sequence</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_ip6table_empty","title":"is_ip6table_empty","text":"<pre><code>is_ip6table_empty(\n    device: DeviceWithFwType, opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; bool\n</code></pre> <p>Return True if ip6tables is empty.</p> <p>Parameters:</p> Name Type Description Default <code>DeviceWithFwType</code> <p>type of the device</p> required <code>str</code> <p>command line arguments for ip6tables command, defaults to \"\"</p> <code>''</code> <code>str</code> <p>extra command line arguments for ip6tables command, defaults to \"\"</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if ip6tables is empty, False otherwise</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def is_ip6table_empty(\n    device: DeviceWithFwType,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; bool:\n    \"\"\"Return True if ip6tables is empty.\n\n    :param device: type of the device\n    :type device: DeviceWithFwType\n    :param opts: command line arguments for ip6tables command, defaults to \"\"\n    :type opts: str\n    :param extra_opts: extra command line arguments for ip6tables command,\n        defaults to \"\"\n    :type extra_opts: str\n    :return: True if ip6tables is empty, False otherwise\n    :rtype: bool\n    \"\"\"\n    return (\n        device.firewall.is_ip6table_empty(opts, extra_opts)\n        if not isinstance(device, CPE)\n        else device.sw.firewall.is_ip6table_empty(opts, extra_opts)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_ip6table_empty(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_ip6table_empty(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_ip6table_empty(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_iptable_empty","title":"is_iptable_empty","text":"<pre><code>is_iptable_empty(\n    device: DeviceWithFwType, opts: str = \"\", extra_opts: str = \"-nvL --line-number\"\n) -&gt; bool\n</code></pre> <p>Return True if iptables is empty.</p> <p>Parameters:</p> Name Type Description Default <code>DeviceWithFwType</code> <p>type of the device</p> required <code>str</code> <p>command line arguments for iptables command, defaults to \"\"</p> <code>''</code> <code>str</code> <p>extra command line arguments for iptables command, defaults to \"\"</p> <code>'-nvL --line-number'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if iptables is empty, False otherwise</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def is_iptable_empty(\n    device: DeviceWithFwType,\n    opts: str = \"\",\n    extra_opts: str = \"-nvL --line-number\",\n) -&gt; bool:\n    \"\"\"Return True if iptables is empty.\n\n    :param device: type of the device\n    :type device: DeviceWithFwType\n    :param opts: command line arguments for iptables command, defaults to \"\"\n    :type opts: str\n    :param extra_opts: extra command line arguments for iptables command, defaults to \"\"\n    :type extra_opts: str\n    :return: True if iptables is empty, False otherwise\n    :rtype: bool\n    \"\"\"\n    return (\n        device.firewall.is_iptable_empty(opts, extra_opts)\n        if not isinstance(device, CPE)\n        else device.sw.firewall.is_iptable_empty(opts, extra_opts)\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_iptable_empty(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_iptable_empty(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.is_iptable_empty(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netcat","title":"netcat","text":"<pre><code>netcat(device: LAN, host_ip: str, port: str, additional_args: str) -&gt; None\n</code></pre> <p>Run netcat command to initiate brute force.</p> <p>Parameters:</p> Name Type Description Default <code>LAN</code> <p>lan device</p> required <code>str</code> <p>host ip address</p> required <code>str</code> <p>port number of the host</p> required <code>str</code> <p>additional args to be provided in netcat command</p> required Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def netcat(device: LAN, host_ip: str, port: str, additional_args: str) -&gt; None:\n    \"\"\"Run netcat command to initiate brute force.\n\n    :param device: lan device\n    :type device: LAN\n    :param host_ip: host ip address\n    :type host_ip: str\n    :param port: port number of the host\n    :type port: str\n    :param additional_args: additional args to be provided in netcat command\n    :type additional_args: str\n    \"\"\"\n    device.netcat(host_ip, port, additional_args)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netcat(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netcat(host_ip)","title":"<code>host_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netcat(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netcat(additional_args)","title":"<code>additional_args</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_tcp","title":"netstat_all_tcp","text":"<pre><code>netstat_all_tcp(\n    device: CPE | LAN | WAN, opts: str = \"-at\", extra_opts: str = \"\"\n) -&gt; DataFrame\n</code></pre> <p>Get all TCP ports.</p> <p>Parameters:</p> Name Type Description Default <code>CPE | LAN | WAN</code> <p>type of the device</p> required <code>str</code> <p>command line options</p> <code>'-at'</code> <code>str</code> <p>extra command line options</p> <code>''</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>parsed netstat output</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def netstat_all_tcp(\n    device: CPE | LAN | WAN,\n    opts: str = \"-at\",\n    extra_opts: str = \"\",\n) -&gt; DataFrame:\n    \"\"\"Get all TCP ports.\n\n    :param device: type of the device\n    :type device: CPE | LAN | WAN\n    :param opts: command line options\n    :type opts: str\n    :param extra_opts: extra command line options\n    :type extra_opts: str\n    :return: parsed netstat output\n    :rtype: DataFrame\n    \"\"\"\n    device_nw = __get_dev_s_network_utility(device)\n    return device_nw.netstat(opts, extra_opts)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_tcp(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_tcp(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_tcp(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_udp","title":"netstat_all_udp","text":"<pre><code>netstat_all_udp(\n    device: CPE | LAN | WAN, opts: str = \"-au\", extra_opts: str = \"\"\n) -&gt; DataFrame\n</code></pre> <p>Get all UDP ports.</p> <p>Parameters:</p> Name Type Description Default <code>CPE | LAN | WAN</code> <p>type of the device</p> required <code>str</code> <p>command line options</p> <code>'-au'</code> <code>str</code> <p>extra command line options</p> <code>''</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>parsed netstat output</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def netstat_all_udp(\n    device: CPE | LAN | WAN,\n    opts: str = \"-au\",\n    extra_opts: str = \"\",\n) -&gt; DataFrame:\n    \"\"\"Get all UDP ports.\n\n    :param device: type of the device\n    :type device: CPE | LAN | WAN\n    :param opts: command line options\n    :type opts: str\n    :param extra_opts: extra command line options\n    :type extra_opts: str\n    :return: parsed netstat output\n    :rtype: DataFrame\n    \"\"\"\n    device_nw = __get_dev_s_network_utility(device)\n    return device_nw.netstat(opts, extra_opts)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_udp(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_udp(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_all_udp(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_listening_ports","title":"netstat_listening_ports","text":"<pre><code>netstat_listening_ports(\n    device: CPE | LAN | WAN, opts: str = \"-nlp\", extra_opts: str = \"\"\n) -&gt; DataFrame\n</code></pre> <p>Get all listening ports.</p> <p>Parameters:</p> Name Type Description Default <code>CPE | LAN | WAN</code> <p>type of the device</p> required <code>str</code> <p>command line options</p> <code>'-nlp'</code> <code>str</code> <p>extra command line options</p> <code>''</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>parsed netstat output</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def netstat_listening_ports(\n    device: CPE | LAN | WAN,\n    opts: str = \"-nlp\",\n    extra_opts: str = \"\",\n) -&gt; DataFrame:\n    \"\"\"Get all listening ports.\n\n    :param device: type of the device\n    :type device: CPE | LAN | WAN\n    :param opts: command line options\n    :type opts: str\n    :param extra_opts: extra command line options\n    :type extra_opts: str\n    :return: parsed netstat output\n    :rtype: DataFrame\n    \"\"\"\n    device_nw = __get_dev_s_network_utility(device)\n    return device_nw.netstat(opts, extra_opts)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_listening_ports(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_listening_ports(opts)","title":"<code>opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.netstat_listening_ports(extra_opts)","title":"<code>extra_opts</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nmap_scan","title":"nmap_scan","text":"<pre><code>nmap_scan(\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    timeout: int = 30,\n) -&gt; dict[str, str]\n</code></pre> <p>Perform Complete scan on destination via nmap network utility on source device.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Perform Complete scan on destination via nmap network utility on source device\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN | WAN</code> <p>source device</p> required <code>LAN | WLAN | WAN | CPE</code> <p>destination device</p> required <code>str</code> <p>type of IP address: \"ipv4\", \"ipv6\"</p> required <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict[str,str]</code> <p>XML output of the nmap command in form of dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def nmap_scan(\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    timeout: int = 30,\n) -&gt; dict[str, str]:\n    \"\"\"Perform Complete scan on destination via nmap network utility on source device.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Perform Complete scan on destination via nmap network utility on source device\n\n    :param source_device: source device\n    :type source_device: LAN | WLAN | WAN\n    :param destination_device: destination device\n    :type destination_device: LAN | WLAN | WAN | CPE\n    :param ip_type: type of IP address: \"ipv4\", \"ipv6\"\n    :type ip_type: str\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :return: XML output of the nmap command in form of dictionary\n    :rtype: dict[str,str]\n    \"\"\"\n    return nmap(source_device, destination_device, ip_type, opts=\"-F\", timeout=timeout)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nmap_scan(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nmap_scan(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nmap_scan(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nmap_scan(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping","title":"nping","text":"<pre><code>nping(\n    device: LAN,\n    interface_ip: str,\n    ipv6: bool = False,\n    extra_args: str = \"\",\n    port_range: str = \"0-65535\",\n    hit_count: str = \"2\",\n    rate: str = \"200\",\n    mode: str = \"udp\",\n) -&gt; Generator[str]\n</code></pre> <p>Perform nping command and kill process once done.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Execute the command from the connected LAN Client to do nping\n  on [] side network\n</code></pre> <p>:yield: process id</p> <p>Parameters:</p> Name Type Description Default <code>LAN</code> <p>connected client to perform nping command from.</p> required <code>str</code> <p>interface ip addr</p> required <code>bool</code> <p>if ipv6 addr to be used, defaults to False</p> <code>False</code> <code>str</code> <p>any extra arguments</p> <code>''</code> <code>str</code> <p>target port range, defaults to all ports</p> <code>'0-65535'</code> <code>str</code> <p>the number of times to target each host, defaults to 2</p> <code>'2'</code> <code>str</code> <p>num of packets per second to send, defaults to 200</p> <code>'200'</code> <code>str</code> <p>probe mode. tcp/udp/icmp etc protocol, defaults to udp</p> <code>'udp'</code> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>@contextmanager\ndef nping(  # pylint: disable=too-many-arguments # noqa: PLR0913\n    device: LAN,\n    interface_ip: str,\n    ipv6: bool = False,\n    extra_args: str = \"\",\n    port_range: str = \"0-65535\",\n    hit_count: str = \"2\",\n    rate: str = \"200\",\n    mode: str = \"udp\",\n) -&gt; Generator[str]:\n    \"\"\"Perform nping command and kill process once done.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Execute the command from the connected LAN Client to do nping\n          on [] side network\n\n    :param device: connected client to perform nping command from.\n    :type device: LAN\n    :param interface_ip: interface ip addr\n    :type interface_ip: str\n    :param ipv6: if ipv6 addr to be used, defaults to False\n    :type ipv6: bool\n    :param extra_args: any extra arguments\n    :type extra_args: str\n    :param port_range: target port range, defaults to all ports\n    :type port_range: str\n    :param hit_count: the number of times to target each host,\n        defaults to 2\n    :type hit_count: str\n    :param rate: num of packets per second to send, defaults to 200\n    :type rate: str\n    :param mode: probe mode. tcp/udp/icmp etc protocol, defaults to udp\n    :type mode: str\n    :yield: process id\n    :rtype: Generator[str, None, None]\n    \"\"\"\n    pid: str = \"\"\n    try:\n        pid = device.start_nping(\n            interface_ip, ipv6, extra_args, port_range, hit_count, rate, mode\n        )\n        yield pid\n    finally:\n        device.stop_nping(process_id=pid)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(interface_ip)","title":"<code>interface_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(ipv6)","title":"<code>ipv6</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(extra_args)","title":"<code>extra_args</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(port_range)","title":"<code>port_range</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(hit_count)","title":"<code>hit_count</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(rate)","title":"<code>rate</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.nping(mode)","title":"<code>mode</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping","title":"ping","text":"<pre><code>ping(\n    device: LAN | WAN | WLAN,\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    timeout: int = 50,\n    json_output: bool = False,\n    options: str = \"\",\n) -&gt; bool | dict[str, Any]\n</code></pre> <p>Ping remote host IP.</p> <p>Return True if ping has 0% loss or parsed output in JSON if json_output=True flag is provided.</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN | WLAN</code> <p>device on which ping is performed</p> required <code>str</code> <p>IP to ping</p> required <code>int</code> <p>number of concurrent pings, defaults to 4</p> <code>4</code> <code>str | None</code> <p>ping via interface, defaults to None</p> <code>None</code> <code>int</code> <p>timeout, defaults to 50</p> <code>50</code> <code>bool</code> <p>True if ping output in dictionary format else False, defaults to False</p> <code>False</code> <code>str</code> <p>extra ping options, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>bool | dict[str, Any]</code> <p>bool or dict of ping output</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def ping(  # noqa: PLR0913\n    device: LAN | WAN | WLAN,\n    ping_ip: str,\n    ping_count: int = 4,\n    ping_interface: str | None = None,\n    timeout: int = 50,\n    json_output: bool = False,\n    options: str = \"\",\n) -&gt; bool | dict[str, Any]:\n    \"\"\"Ping remote host IP.\n\n    Return True if ping has 0% loss or parsed output in JSON if\n    json_output=True flag is provided.\n\n    :param device: device on which ping is performed\n    :type device: LAN | WAN\n    :param ping_ip: IP to ping\n    :type ping_ip: str\n    :param ping_count: number of concurrent pings, defaults to 4\n    :type ping_count: int\n    :param ping_interface: ping via interface, defaults to None\n    :type ping_interface: str | None\n    :param timeout: timeout, defaults to 50\n    :type timeout: int\n    :param json_output: True if ping output in dictionary format else False,\n        defaults to False\n    :type json_output: bool\n    :param options: extra ping options, defaults to \"\"\n    :type options: str\n    :return: bool or dict of ping output\n    :rtype: bool | dict[str, Any]\n    \"\"\"\n    return device.ping(\n        ping_ip,\n        ping_count,\n        ping_interface,\n        timeout=timeout,\n        json_output=json_output,\n        options=options,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping(ping_ip)","title":"<code>ping_ip</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping(ping_count)","title":"<code>ping_count</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping(ping_interface)","title":"<code>ping_interface</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping(json_output)","title":"<code>json_output</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.ping(options)","title":"<code>options</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.start_http_server","title":"start_http_server","text":"<pre><code>start_http_server(\n    device: LAN | WAN, port: int | str, ip_version: str | int\n) -&gt; Generator\n</code></pre> <p>Start http server on given client.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start the HTTP server on the [] client\n</code></pre> <p>:yield: PID of the http server process</p> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>device on which server will start</p> required <code>int | str</code> <p>port on which the server listen for incomming connections</p> required <code>str | int</code> <p>ip version of server values can strictly be 4 or 6</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>wrong ip_version value is given in api call</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>@contextmanager\ndef start_http_server(\n    device: LAN | WAN,\n    port: int | str,\n    ip_version: str | int,\n) -&gt; Generator:\n    \"\"\"Start http server on given client.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start the HTTP server on the [] client\n\n    :param device: device on which server will start\n    :type device: LAN | WAN\n    :param port: port on which the server listen for incomming connections\n    :type port: int | str\n    :param ip_version: ip version of server values can strictly be 4 or 6\n    :type ip_version: str | int\n    :raises ValueError: wrong ip_version value is given in api call\n    :yield: PID of the http server process\n    \"\"\"\n    port = str(port)\n    ip_version = str(ip_version)\n    if ip_version not in [\"4\", \"6\"]:\n        reason = f\"Invalid ip_version argument {ip_version}.\"\n        raise ValueError(reason)\n    # stop http service if running\n    device.stop_http_service(port)\n    try:\n        yield device.start_http_service(port, ip_version)\n    finally:\n        device.stop_http_service(port)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.start_http_server(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.start_http_server(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.start_http_server(ip_version)","title":"<code>ip_version</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood","title":"trigger_ip_flood","text":"<pre><code>trigger_ip_flood(\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    min_rate: int,\n    max_retries: int = 4,\n    timeout: int = 30,\n) -&gt; dict[str, str]\n</code></pre> <p>Perform IP flooding via nmap network utility on source device.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Perform IP flooding via nmap network utility on source device.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WLAN | WAN</code> <p>source device</p> required <code>LAN | WLAN | WAN | CPE</code> <p>destination device</p> required <code>str</code> <p>type of IP address: \"ipv4\", \"ipv6\"</p> required <code>str | int</code> <p>port or range of ports: \"666-999\"</p> required <code>int</code> <p>send packets no slower than min_rate per second</p> required <code>int</code> <p>maximum number retries for nmap</p> <code>4</code> <code>int</code> <p>pexpect timeout for the command in seconds, defaults to 30</p> <code>30</code> <p>Returns:</p> Type Description <code>dict[str,str]</code> <p>XML output of the nmap command in form of dictionary</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def trigger_ip_flood(  # noqa: PLR0913\n    source_device: LAN | WLAN | WAN,\n    destination_device: LAN | WLAN | WAN | CPE,\n    ip_type: str,\n    port: str | int,\n    min_rate: int,\n    max_retries: int = 4,\n    timeout: int = 30,\n) -&gt; dict[str, str]:\n    \"\"\"Perform IP flooding via nmap network utility on source device.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Perform IP flooding via nmap network utility on source device.\n\n    :param source_device: source device\n    :type source_device: LAN | WLAN | WAN\n    :param destination_device: destination device\n    :type destination_device: LAN | WLAN | WAN | CPE\n    :param ip_type: type of IP address: \"ipv4\", \"ipv6\"\n    :type ip_type: str\n    :param port: port or range of ports: \"666-999\"\n    :type port: str | int\n    :param min_rate: send packets no slower than min_rate per second\n    :type min_rate: int\n    :param max_retries: maximum number retries for nmap\n    :type max_retries: int\n    :param timeout: pexpect timeout for the command in seconds, defaults to 30\n    :type timeout: int\n    :return: XML output of the nmap command in form of dictionary\n    :rtype: dict[str,str]\n    \"\"\"\n    return nmap(\n        source_device,\n        destination_device,\n        ip_type,\n        port,\n        \"-sS\",\n        max_retries,\n        min_rate,\n        timeout=timeout,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood(source_device)","title":"<code>source_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood(destination_device)","title":"<code>destination_device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood(ip_type)","title":"<code>ip_type</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood(port)","title":"<code>port</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood(min_rate)","title":"<code>min_rate</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood(max_retries)","title":"<code>max_retries</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.trigger_ip_flood(timeout)","title":"<code>timeout</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.verify_tunnel_packets","title":"verify_tunnel_packets","text":"<pre><code>verify_tunnel_packets(\n    captured_sequence: list[tuple[str, ...]], expected_sequence: list[tuple[str, ...]]\n) -&gt; bool\n</code></pre> <p>Verify the expected encapsulated info with the captured sequence.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Traffic from Ethernet LAN client to Internet, must be encapsulated like below\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>list[tuple[str, ...]]</code> <p>Sequence of packets filtered from captured pcap file</p> required <code>list[tuple[str, ...]]</code> <p>Example for encapsulated traffic  .. code-block:: python  [ ( \"10.1.2.105,10.15.137.242\", \"44:d4:54:e1:9e:57,44:d4:54:e1:9e:57\", \"172.30.113.175,8.8.8.8\", \"52:54:00:67:85:42,52:54:00:67:85:42\", ) ]</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if ICMP expected sequences matches with the captured sequence and encapsulated as expected sequence with outer and inner layer</p> Source code in <code>boardfarm3/use_cases/networking.py</code> <pre><code>def verify_tunnel_packets(\n    captured_sequence: list[tuple[str, ...]],\n    expected_sequence: list[tuple[str, ...]],\n) -&gt; bool:\n    \"\"\"Verify the expected encapsulated info with the captured sequence.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Traffic from Ethernet LAN client to Internet, must be encapsulated like below\n\n    :param captured_sequence: Sequence of packets filtered from captured pcap file\n    :type captured_sequence: list[tuple[str, ...]]\n    :param expected_sequence: Example for encapsulated traffic\n\n            .. code-block:: python\n\n                [\n                    (\n                        \"10.1.2.105,10.15.137.242\",\n                        \"44:d4:54:e1:9e:57,44:d4:54:e1:9e:57\",\n                        \"172.30.113.175,8.8.8.8\",\n                        \"52:54:00:67:85:42,52:54:00:67:85:42\",\n                    )\n                ]\n\n    :type expected_sequence: list[tuple[str, ...]]\n    :return: True if ICMP expected sequences matches with the captured sequence\n        and encapsulated as expected sequence with outer and inner layer\n    :rtype: bool\n    \"\"\"\n    final_result = []\n    last_check = 0\n    for packet in expected_sequence:\n        for i in range(last_check, len(captured_sequence)):\n            if all(\n                expected == actual\n                for expected, actual in zip(packet, captured_sequence[i])\n                if expected != \"*\"\n            ):\n                last_check = i\n                _LOGGER.debug(\n                    \"Verified encapsulated packets: %s,%s,%s,%s\",\n                    packet[0],\n                    packet[1],\n                    packet[2],\n                    packet[3],\n                )\n                final_result.append(captured_sequence[i])\n                break\n        else:\n            _LOGGER.debug(\n                \"Failed verification: %s,%s,%s,%s\",\n                packet[0],\n                packet[1],\n                packet[2],\n                packet[3],\n            )\n            final_result.append(())\n    return all(final_result)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.verify_tunnel_packets(captured_sequence)","title":"<code>captured_sequence</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.networking.verify_tunnel_packets(expected_sequence)","title":"<code>expected_sequence</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.ripv2","title":"ripv2","text":"<p>RIPv2 Use Cases library.</p> <p>All Use Cases are independent of the device.</p> <p>Functions:</p> Name Description <code>parse_rip_trace</code> <p>Read and filter RIP packets from the captured file.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.ripv2.parse_rip_trace","title":"parse_rip_trace","text":"<pre><code>parse_rip_trace(\n    dev: LAN | WAN, fname: str, frame_time: bool, rm_pcap: bool\n) -&gt; list[RIPv2PacketData]\n</code></pre> <p>Read and filter RIP packets from the captured file.</p> <p>The Routing Information Protocol is one of a family of IP Routing protocols. RIP is a simple vector routing protocol. This usecase parses RIP protocol packets.</p> <p>.. code-block:: python</p> <pre><code># example usage\ncmts_packet_cap = read_rip_trace(\n    device=LanClient, fname=\"some_capture.pcap\", frame_time=False, rm_pcap=False\n)\n</code></pre> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Check that CPE is sending and receiving RIPv2 route advertisements to the CMTS\n- Verify that CPE is sending RIPv2 route advertisements every 30 seconds.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>LAN | WAN</code> <p>device where captures were taken, LAN, WAN</p> required <code>str</code> <p>PCAP file to be read</p> required <code>bool</code> <p>If True stores timestap value in RIPv2PacketData else stores None</p> required <code>bool</code> <p>if True remove the PCAP file after reading else keeps the file</p> required <p>Returns:</p> Type Description <code>List[RIPv2PacketData]</code> <p>list of RIP packets as  .. code-block:: python  [ ( frame, src ip, dst ip, rip contact, rip msg:media_attribute:connection:info, time ) ]</p> <p>Raises:</p> Type Description <code>UseCaseFailure</code> <p>when no RIPv2 trace is found in PCAP file</p> Source code in <code>boardfarm3/use_cases/ripv2.py</code> <pre><code>def parse_rip_trace(  # pylint: disable=too-many-locals\n    dev: LAN | WAN,\n    fname: str,\n    frame_time: bool,\n    rm_pcap: bool,\n) -&gt; list[RIPv2PacketData]:\n    \"\"\"Read and filter RIP packets from the captured file.\n\n    The Routing Information Protocol is one of a family of IP Routing\n    protocols. RIP is a simple vector routing protocol.\n    This usecase parses RIP protocol packets.\n\n    .. code-block:: python\n\n        # example usage\n        cmts_packet_cap = read_rip_trace(\n            device=LanClient, fname=\"some_capture.pcap\", frame_time=False, rm_pcap=False\n        )\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Check that CPE is sending and receiving RIPv2 route advertisements to the CMTS\n        - Verify that CPE is sending RIPv2 route advertisements every 30 seconds.\n\n    :param dev: device where captures were taken, LAN, WAN\n    :type dev: LAN | WAN\n    :param fname: PCAP file to be read\n    :type fname: str\n    :param frame_time: If True stores timestap value in RIPv2PacketData else stores None\n    :type frame_time: bool\n    :param rm_pcap: if True remove the PCAP file after reading else keeps the file\n    :type rm_pcap: bool\n    :raises UseCaseFailure: when no RIPv2 trace is found in PCAP file\n    :return: list of RIP packets as\n\n        .. code-block:: python\n\n            [\n                (\n                    frame,\n                    src ip,\n                    dst ip,\n                    rip contact,\n                    rip msg:media_attribute:connection:info,\n                    time\n                )\n            ]\n\n    :rtype: List[RIPv2PacketData]\n    \"\"\"\n    output = []\n    time_field = \"-e frame.time_epoch\" if frame_time else \"\"\n    fields = (\n        f\" -Y rip -T fields -e ip.src -e ip.dst -e rip.ip -e rip.netmask {time_field}\"\n    )\n    filter_str = fields\n    raw_rip_packets = dev.tshark_read_pcap(\n        fname=fname,\n        additional_args=filter_str,\n        rm_pcap=rm_pcap,\n    )\n    rip_packets = raw_rip_packets.split(\"This could be dangerous.\\r\\n\")[-1]\n    if not rip_packets:\n        msg = f\"No trace found in PCAP file {fname} with filters: {filter_str}\"\n        raise UseCaseFailure(msg)\n\n    ftime = None\n    for packet in rip_packets.splitlines():\n        packet_fields = packet.split(\"\\t\")\n        try:\n            (\n                src,\n                dst,\n                advertised_ips,\n                netmask,\n            ) = packet_fields[:4]\n\n            if frame_time:\n                ftime = datetime.fromtimestamp(\n                    float(packet_fields[-1]),\n                    tz=tz.tzlocal(),\n                )\n\n        except (IndexError, ValueError) as exception:\n            msg = f\"No RIPv2 trace found in PCAP file {fname}\"\n            raise UseCaseFailure(msg) from exception\n\n        if advertised_ips:\n            output.append(\n                RIPv2PacketData(\n                    source=IPv4Address(src),\n                    destination=IPv4Address(dst),\n                    ip_address=[IPv4Address(ip) for ip in advertised_ips.split(\",\")],\n                    subnet=[ip_interface(mask) for mask in netmask.split(\",\")],\n                    frame_time=ftime,\n                ),\n            )\n    return output\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.ripv2.parse_rip_trace(dev)","title":"<code>dev</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.ripv2.parse_rip_trace(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.ripv2.parse_rip_trace(frame_time)","title":"<code>frame_time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.ripv2.parse_rip_trace(rm_pcap)","title":"<code>rm_pcap</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice","title":"voice","text":"<p>Voice use cases library.</p> <p>This module deals with only SIP end points. All APIs are independent of board under test.</p> <p>Functions:</p> Name Description <code>add_user_profile</code> <p>Register user profile on the SIP Server.</p> <code>answer_a_call</code> <p>Answer a ringing call by target SIP agent.</p> <code>answer_waiting_call</code> <p>Answer the waiting call and hang up on the current call.</p> <code>call_a_number</code> <p>Have the Caller dial the given phone number.</p> <code>call_a_phone</code> <p>Call the Callee by the Caller.</p> <code>disable_call_forwarding_busy</code> <p>Disable call forwarding on a phone when busy.</p> <code>disable_call_forwarding_no_answer</code> <p>Disable call forwarding on a phone when not answered.</p> <code>disable_unconditional_call_forwarding</code> <p>Disable unconditional call forwarding on a phone.</p> <code>disconnect_the_call</code> <p>Disconnecting a call on a SIP agent.</p> <code>enable_call_forwarding_busy</code> <p>Enable call forwarding on a phone when busy.</p> <code>enable_call_forwarding_no_answer</code> <p>Enable call forwarding on a phone when there's no answer.</p> <code>enable_unconditional_call_forwarding</code> <p>Enable unconditional call forwarding on a phone.</p> <code>get_sip_expiry_time</code> <p>Get the call expiry timer from the config file.</p> <code>initialize_phone</code> <p>Configure the phone, and start the application.</p> <code>is_call_connected</code> <p>Verify if a call is connected.</p> <code>is_call_dialing</code> <p>Verify if a phone is dialing and a call in progress.</p> <code>is_call_ended</code> <p>Verify if the call has been disconnected and ended.</p> <code>is_call_idle</code> <p>Verify if a phone is in idle state.</p> <code>is_call_in_conference</code> <p>Verify if a call is in conference.</p> <code>is_call_not_answered</code> <p>Verify if callee did not pick up the call.</p> <code>is_call_on_hold</code> <p>Verify if a call is on hold.</p> <code>is_call_ringing</code> <p>Verify if a ringtone is detected on a phone device.</p> <code>is_call_waiting</code> <p>Verify if the phone notifies for the call on other line to be waiting.</p> <code>is_code_ended</code> <p>Verify if the dialed code or number has expired.</p> <code>is_dialtone_detected</code> <p>Verify if a dialtone is detected off_hook.</p> <code>is_incall_connected</code> <p>Verify if a call is incall connected.</p> <code>is_incall_dialing</code> <p>Verify if a phone is incall and call is dialing/in progress.</p> <code>is_incall_playing_dialtone</code> <p>Verify phone is connected on one line and playing dialtone on another line.</p> <code>is_line_busy</code> <p>To verify if the caller was notified that the callee is BUSY.</p> <code>is_off_hook_warning</code> <p>Verify phone has been left off-hook without use for an extended period.</p> <code>is_playing_dialtone</code> <p>Verify if the phone is playing a dialtone.</p> <code>is_user_profile_present</code> <p>Check whether the user profile is registered on the SIP Server or not.</p> <code>merge_two_calls</code> <p>Merge the two calls for conference calling.</p> <code>place_call_offhold</code> <p>Place an ongoing call on hold to off-hold.</p> <code>place_call_onhold</code> <p>Place an ongoing call on-hold.</p> <code>press_R_button</code> <p>Press the R button.</p> <code>put_phone_offhook</code> <p>Put the phone off hook.</p> <code>remove_user_profile</code> <p>Deregister user profile from the SIP Server.</p> <code>set_sip_expiry_time</code> <p>Modify the call expires timer in the config file of the sip_proxy.</p> <code>shutdown_phone</code> <p>Go on_hook and stop the phone application.</p> <code>stop_and_start_sip_server</code> <p>Stop and start the SIP server.</p> <code>tcpdump</code> <p>Start packet capture using tcpdump and kills the process at the end.</p> <code>toggle_call</code> <p>Toggle between the calls.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.add_user_profile","title":"add_user_profile","text":"<pre><code>add_user_profile(where_to_add: VoiceServer, whom_to_add: VoiceClient) -&gt; None\n</code></pre> <p>Register user profile on the SIP Server.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Add user profile of (User) to the SIP Server.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceServer</code> <p>SIP Server</p> required <code>VoiceClient</code> <p>Phone device to be registered</p> required <p>Raises:</p> Type Description <code>VoiceError</code> <p>if the device already exist on the SIP Server</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def add_user_profile(where_to_add: VoiceServer, whom_to_add: VoiceClient) -&gt; None:\n    \"\"\"Register user profile on the SIP Server.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Add user profile of (User) to the SIP Server.\n\n    :param where_to_add: SIP Server\n    :type where_to_add: VoiceServer\n    :param whom_to_add: Phone device to be registered\n    :type whom_to_add: VoiceClient\n    :raises VoiceError: if the device already exist on the SIP Server\n    \"\"\"\n    if whom_to_add.number in where_to_add.sipserver_get_online_users():\n        msg = f\"User {whom_to_add.name} is already registered\"\n        raise VoiceError(msg)\n    where_to_add.sipserver_user_add(whom_to_add.number)\n    # TODO: the need for restart should be specific to the SIP server device class\n    where_to_add.sipserver_restart()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.add_user_profile(where_to_add)","title":"<code>where_to_add</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.add_user_profile(whom_to_add)","title":"<code>whom_to_add</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.answer_a_call","title":"answer_a_call","text":"<pre><code>answer_a_call(who_answers: VoiceClient) -&gt; bool\n</code></pre> <p>Answer a ringing call by target SIP agent.</p> <p>Execution order: - Ensure there is a ring on the target agent. - Pick up the call - Ensure the line is connected</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) answers to (User)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent who is suppose to answer the call.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is connected, else False</p> <p>Raises:</p> Type Description <code>VoiceError</code> <p>In case answering the call fails.</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def answer_a_call(who_answers: VoiceClient) -&gt; bool:\n    \"\"\"Answer a ringing call by target SIP agent.\n\n    Execution order:\n    - Ensure there is a ring on the target agent.\n    - Pick up the call\n    - Ensure the line is connected\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) answers to (User)\n\n    :param who_answers: SIP agent who is suppose to answer the call.\n    :type who_answers: VoiceClient\n    :raises VoiceError: In case answering the call fails.\n    :return: True if call is connected, else False\n    :rtype: bool\n    \"\"\"\n    if not who_answers.is_ringing():\n        msg = f\"{who_answers.name} is not ringing!!\"\n        raise VoiceError(msg)\n    who_answers.answer()\n\n    return who_answers.is_connected()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.answer_a_call(who_answers)","title":"<code>who_answers</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.answer_waiting_call","title":"answer_waiting_call","text":"<pre><code>answer_waiting_call(who_answers: VoiceClient) -&gt; None\n</code></pre> <p>Answer the waiting call and hang up on the current call.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) presses R1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent who is suppose to answer the call.</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def answer_waiting_call(who_answers: VoiceClient) -&gt; None:\n    \"\"\"Answer the waiting call and hang up on the current call.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) presses R1\n\n    :param who_answers: SIP agent who is suppose to answer the call.\n    :type who_answers: VoiceClient\n    \"\"\"\n    who_answers.answer_waiting_call()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.answer_waiting_call(who_answers)","title":"<code>who_answers</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.call_a_number","title":"call_a_number","text":"<pre><code>call_a_number(caller: VoiceClient, phone_nr: str) -&gt; None\n</code></pre> <p>Have the Caller dial the given phone number.</p> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent that initiates the call</p> required <code>str</code> <p>Phone number to be dialled</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def call_a_number(caller: VoiceClient, phone_nr: str) -&gt; None:\n    \"\"\"Have the Caller dial the given phone number.\n\n    :param caller: SIP agent that initiates the call\n    :type caller: VoiceClient\n    :param phone_nr: Phone number to be dialled\n    :type phone_nr: str\n    \"\"\"\n    caller.dial(phone_nr)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.call_a_number(caller)","title":"<code>caller</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.call_a_number(phone_nr)","title":"<code>phone_nr</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.call_a_phone","title":"call_a_phone","text":"<pre><code>call_a_phone(caller: VoiceClient, callee: VoiceClient) -&gt; None\n</code></pre> <p>Call the Callee by the Caller.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) calls (User)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent who intiates the call</p> required <code>VoiceClient</code> <p>SIP agent who receives the call</p> required <p>Raises:</p> Type Description <code>VoiceError</code> <p>In case the call fails.</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def call_a_phone(caller: VoiceClient, callee: VoiceClient) -&gt; None:\n    \"\"\"Call the Callee by the Caller.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) calls (User)\n\n    :param caller: SIP agent who intiates the call\n    :type caller: VoiceClient\n    :param callee: SIP agent who receives the call\n    :type callee: VoiceClient\n    :raises VoiceError: In case the call fails.\n    \"\"\"\n    try:\n        assert caller is not callee, \"Caller and Callee cannot be same!\"  # noqa: S101\n        caller.dial(callee.number)\n    except Exception as exc:  # pylint: disable=broad-except  # BOARDFARM-4980\n        msg = f\"Failed to initiate a call between: {caller.name} --&gt; {callee.name}\"\n        raise VoiceError(msg) from exc\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.call_a_phone(caller)","title":"<code>caller</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.call_a_phone(callee)","title":"<code>callee</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_call_forwarding_busy","title":"disable_call_forwarding_busy","text":"<pre><code>disable_call_forwarding_busy(who_disables: VoiceClient, sip_srv: SIPServer) -&gt; None\n</code></pre> <p>Disable call forwarding on a phone when busy.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Disable call forwarding on (User)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Agent that disables call forwarding busy</p> required <code>SIPServer</code> <p>SIP server to retrieve the Vertical Service Code from</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def disable_call_forwarding_busy(\n    who_disables: VoiceClient,\n    sip_srv: SIPServer,\n) -&gt; None:\n    \"\"\"Disable call forwarding on a phone when busy.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Disable call forwarding on (User)\n\n    :param who_disables: Agent that disables call forwarding busy\n    :type who_disables: VoiceClient\n    :param sip_srv: SIP server to retrieve the Vertical Service Code from\n    :type sip_srv: SIPServer\n    \"\"\"\n    vsc = sip_srv.get_vsc_prefix(\"unset_cf_busy\")\n    who_disables.dial_feature_code(vsc)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_call_forwarding_busy(who_disables)","title":"<code>who_disables</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_call_forwarding_busy(sip_srv)","title":"<code>sip_srv</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_call_forwarding_no_answer","title":"disable_call_forwarding_no_answer","text":"<pre><code>disable_call_forwarding_no_answer(\n    who_disables: VoiceClient, sip_srv: SIPServer\n) -&gt; None\n</code></pre> <p>Disable call forwarding on a phone when not answered.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Disable call forwarding no answer on (User)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Agent that disables call forwarding no answer</p> required <code>SIPServer</code> <p>SIP server to retrieve the Vertical Service Code from</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def disable_call_forwarding_no_answer(\n    who_disables: VoiceClient,\n    sip_srv: SIPServer,\n) -&gt; None:\n    \"\"\"Disable call forwarding on a phone when not answered.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Disable call forwarding no answer on (User)\n\n    :param who_disables: Agent that disables call forwarding no answer\n    :type who_disables: VoiceClient\n    :param sip_srv: SIP server to retrieve the Vertical Service Code from\n    :type sip_srv: SIPServer\n    \"\"\"\n    vsc = sip_srv.get_vsc_prefix(\"unset_cf_no_answer\")\n    who_disables.dial_feature_code(vsc)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_call_forwarding_no_answer(who_disables)","title":"<code>who_disables</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_call_forwarding_no_answer(sip_srv)","title":"<code>sip_srv</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_unconditional_call_forwarding","title":"disable_unconditional_call_forwarding","text":"<pre><code>disable_unconditional_call_forwarding(\n    who_disables: VoiceClient, sip_srv: SIPServer\n) -&gt; None\n</code></pre> <p>Disable unconditional call forwarding on a phone.</p> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Agent that disables call forwarding busy</p> required <code>SIPServer</code> <p>SIP server to retrieve the Vertical Service Code from</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def disable_unconditional_call_forwarding(\n    who_disables: VoiceClient,\n    sip_srv: SIPServer,\n) -&gt; None:\n    \"\"\"Disable unconditional call forwarding on a phone.\n\n    :param who_disables: Agent that disables call forwarding busy\n    :type who_disables: VoiceClient\n    :param sip_srv: SIP server to retrieve the Vertical Service Code from\n    :type sip_srv: SIPServer\n    \"\"\"\n    vsc = sip_srv.get_vsc_prefix(\"unset_cf_unconditional\")\n    who_disables.dial_feature_code(vsc)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_unconditional_call_forwarding(who_disables)","title":"<code>who_disables</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disable_unconditional_call_forwarding(sip_srv)","title":"<code>sip_srv</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disconnect_the_call","title":"disconnect_the_call","text":"<pre><code>disconnect_the_call(who_disconnects: VoiceClient) -&gt; bool\n</code></pre> <p>Disconnecting a call on a SIP agent.</p> <p>The user will not verify if the call is ongoing. It will simply call the on_hook implementation.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) goes on hook.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent who is suppose to disconnect the call.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is disconnected</p> <p>Raises:</p> Type Description <code>VoiceError</code> <p>In case disconnecting the call fails.</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def disconnect_the_call(who_disconnects: VoiceClient) -&gt; bool:\n    \"\"\"Disconnecting a call on a SIP agent.\n\n    The user will not verify if the call is ongoing.\n    It will simply call the on_hook implementation.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) goes on hook.\n\n    :param who_disconnects: SIP agent who is suppose to disconnect the call.\n    :type who_disconnects: VoiceClient\n    :raises VoiceError: In case disconnecting the call fails.\n    :return: True if call is disconnected\n    :rtype: bool\n    \"\"\"\n    try:\n        who_disconnects.on_hook()\n    except Exception as exc:  # pylint: disable=broad-except  # BOARDFARM-4981\n        msg = f\"Failed to disconnect the call: {who_disconnects.name}\"\n        raise VoiceError(msg) from exc\n    return True\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.disconnect_the_call(who_disconnects)","title":"<code>who_disconnects</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_busy","title":"enable_call_forwarding_busy","text":"<pre><code>enable_call_forwarding_busy(\n    who_forwards: VoiceClient, forward_to: VoiceClient, sip_srv: SIPServer\n) -&gt; None\n</code></pre> <p>Enable call forwarding on a phone when busy.</p> <p>This thus forwards a call to another user</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Enable Call Forwarding Busy on (User) to (User)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Agent that enables call forwarding busy</p> required <code>VoiceClient</code> <p>SIP Client to which agent forwards the call to</p> required <code>SIPServer</code> <p>sip server</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def enable_call_forwarding_busy(\n    who_forwards: VoiceClient,\n    forward_to: VoiceClient,\n    sip_srv: SIPServer,\n) -&gt; None:\n    \"\"\"Enable call forwarding on a phone when busy.\n\n    This thus forwards a call to another user\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Enable Call Forwarding Busy on (User) to (User)\n\n    :param who_forwards: Agent that enables call forwarding busy\n    :type who_forwards: VoiceClient\n    :param forward_to: SIP Client to which agent forwards the call to\n    :type forward_to: VoiceClient\n    :param sip_srv: sip server\n    :type sip_srv: SIPServer\n    \"\"\"\n    vsc = sip_srv.get_vsc_prefix(\"set_cf_busy\")\n    if vsc.endswith(\"#\"):\n        who_forwards.dial_feature_code(f\"{vsc[:-1]}{forward_to.number}#\")\n    else:\n        who_forwards.dial_feature_code(f\"{vsc}{forward_to.number}\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_busy(who_forwards)","title":"<code>who_forwards</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_busy(forward_to)","title":"<code>forward_to</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_busy(sip_srv)","title":"<code>sip_srv</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_no_answer","title":"enable_call_forwarding_no_answer","text":"<pre><code>enable_call_forwarding_no_answer(\n    who_forwards: VoiceClient, forward_to: VoiceClient, sip_srv: SIPServer\n) -&gt; None\n</code></pre> <p>Enable call forwarding on a phone when there's no answer.</p> <p>This thus forwards a call to another user</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Enable Call Forwarding No Answer on (User) to (User)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Agent that enables call forwarding no answer</p> required <code>VoiceClient</code> <p>SIP Client to which agent forwards the call to</p> required <code>SIPServer</code> <p>SIP server to retrieve the Vertical Service Code from</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def enable_call_forwarding_no_answer(\n    who_forwards: VoiceClient,\n    forward_to: VoiceClient,\n    sip_srv: SIPServer,\n) -&gt; None:\n    \"\"\"Enable call forwarding on a phone when there's no answer.\n\n    This thus forwards a call to another user\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Enable Call Forwarding No Answer on (User) to (User)\n\n    :param who_forwards: Agent that enables call forwarding no answer\n    :type who_forwards: VoiceClient\n    :param forward_to: SIP Client to which agent forwards the call to\n    :type forward_to: VoiceClient\n    :param sip_srv: SIP server to retrieve the Vertical Service Code from\n    :type sip_srv: SIPServer\n    \"\"\"\n    vsc = sip_srv.get_vsc_prefix(\"set_cf_no_answer\")\n    if vsc.endswith(\"#\"):\n        who_forwards.dial_feature_code(f\"{vsc[:-1]}{forward_to.number}#\")\n    else:\n        who_forwards.dial_feature_code(f\"{vsc}{forward_to.number}\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_no_answer(who_forwards)","title":"<code>who_forwards</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_no_answer(forward_to)","title":"<code>forward_to</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_call_forwarding_no_answer(sip_srv)","title":"<code>sip_srv</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_unconditional_call_forwarding","title":"enable_unconditional_call_forwarding","text":"<pre><code>enable_unconditional_call_forwarding(\n    who_forwards: VoiceClient, forward_to: VoiceClient, sip_srv: SIPServer\n) -&gt; None\n</code></pre> <p>Enable unconditional call forwarding on a phone.</p> <p>This thus forwards a call to another user</p> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Agent that enables call forwarding busy</p> required <code>VoiceClient</code> <p>SIP Client to which agent forwards the call to</p> required <code>SIPServer</code> <p>SIP server</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def enable_unconditional_call_forwarding(\n    who_forwards: VoiceClient,\n    forward_to: VoiceClient,\n    sip_srv: SIPServer,\n) -&gt; None:\n    \"\"\"Enable unconditional call forwarding on a phone.\n\n    This thus forwards a call to another user\n\n    :param who_forwards: Agent that enables call forwarding busy\n    :type who_forwards: VoiceClient\n    :param forward_to: SIP Client to which agent forwards the call to\n    :type forward_to: VoiceClient\n    :param sip_srv: SIP server\n    :type sip_srv: SIPServer\n    \"\"\"\n    vsc = sip_srv.get_vsc_prefix(\"set_cf_unconditional\")\n    if vsc.endswith(\"#\"):\n        who_forwards.dial_feature_code(f\"{vsc[:-1]}{forward_to.number}#\")\n    else:\n        who_forwards.dial_feature_code(f\"{vsc}{forward_to.number}\")\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_unconditional_call_forwarding(who_forwards)","title":"<code>who_forwards</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_unconditional_call_forwarding(forward_to)","title":"<code>forward_to</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.enable_unconditional_call_forwarding(sip_srv)","title":"<code>sip_srv</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.get_sip_expiry_time","title":"get_sip_expiry_time","text":"<pre><code>get_sip_expiry_time(sip_proxy: VoiceServer) -&gt; int\n</code></pre> <p>Get the call expiry timer from the config file.</p> <p>Parameters:</p> Name Type Description Default <code>VoiceServer</code> <p>SIP server</p> required <p>Returns:</p> Type Description <code>int</code> <p>expiry timer saved in the config</p> <p>Raises:</p> Type Description <code>VoiceError</code> <p>if the SIP Server is not installed</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def get_sip_expiry_time(sip_proxy: VoiceServer) -&gt; int:\n    \"\"\"Get the call expiry timer from the config file.\n\n    :param sip_proxy: SIP server\n    :type sip_proxy: VoiceServer\n    :return: expiry timer saved in the config\n    :rtype: int\n    :raises VoiceError: if the SIP Server is not installed\n    \"\"\"\n    if sip_proxy.sipserver_status() in [\"Not installed\", \"Not Running\"]:\n        err_msg = \"Install the sipserver first\"\n        raise VoiceError(err_msg)\n    return sip_proxy.sipserver_get_expire_timer()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.get_sip_expiry_time(sip_proxy)","title":"<code>sip_proxy</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.initialize_phone","title":"initialize_phone","text":"<pre><code>initialize_phone(target_phone: VoiceClient) -&gt; None\n</code></pre> <p>Configure the phone, and start the application.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Configure the phone, and start the application.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Target phone to be initialized</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def initialize_phone(target_phone: VoiceClient) -&gt; None:\n    \"\"\"Configure the phone, and start the application.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Configure the phone, and start the application.\n\n    :param target_phone: Target phone to be initialized\n    :type target_phone: VoiceClient\n    \"\"\"\n    target_phone.phone_start()\n    target_phone.on_hook()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.initialize_phone(target_phone)","title":"<code>target_phone</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_connected","title":"is_call_connected","text":"<pre><code>is_call_connected(who_is_connected: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a call is connected.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if a call is connected.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP client on which connection needs to be checked</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is connected.</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_connected(who_is_connected: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a call is connected.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if a call is connected.\n\n    :param who_is_connected: SIP client on which connection needs to be checked\n    :type who_is_connected: VoiceClient\n    :return: True if call is connected.\n    :rtype: bool\n    \"\"\"\n    return who_is_connected.is_connected()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_connected(who_is_connected)","title":"<code>who_is_connected</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_dialing","title":"is_call_dialing","text":"<pre><code>is_call_dialing(who_is_dialing: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a phone is dialing and a call in progress.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if a phone is dialing and a call in progress.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent used to verify dialing</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if in progress dialing is detected</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_dialing(who_is_dialing: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a phone is dialing and a call in progress.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if a phone is dialing and a call in progress.\n\n    :param who_is_dialing: SIP agent used to verify dialing\n    :type who_is_dialing: VoiceClient\n    :return: True if in progress dialing is detected\n    :rtype: bool\n    \"\"\"\n    return who_is_dialing.is_dialing()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_dialing(who_is_dialing)","title":"<code>who_is_dialing</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_ended","title":"is_call_ended","text":"<pre><code>is_call_ended(whose_call_ended: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if the call has been disconnected and ended.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if the call has been disconnected and ended.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP Client</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is disconnected</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_ended(whose_call_ended: VoiceClient) -&gt; bool:\n    \"\"\"Verify if the call has been disconnected and ended.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if the call has been disconnected and ended.\n\n    :param whose_call_ended: SIP Client\n    :type whose_call_ended: VoiceClient\n    :return: True if call is disconnected\n    :rtype: bool\n    \"\"\"\n    return whose_call_ended.is_call_ended()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_ended(whose_call_ended)","title":"<code>whose_call_ended</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_idle","title":"is_call_idle","text":"<pre><code>is_call_idle(who_is_idle: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a phone is in idle state.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) goes on Hook\n- Verify if a phone is in idle state.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent used to verify idle</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if idle is detected</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_idle(who_is_idle: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a phone is in idle state.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) goes on Hook\n        - Verify if a phone is in idle state.\n\n    :param who_is_idle: SIP agent used to verify idle\n    :type who_is_idle: VoiceClient\n    :return: True if idle is detected\n    :rtype: bool\n    \"\"\"\n    return who_is_idle.is_idle()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_idle(who_is_idle)","title":"<code>who_is_idle</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_in_conference","title":"is_call_in_conference","text":"<pre><code>is_call_in_conference(who_in_conference: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a call is in conference.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if a call is in conference.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP client on which conference state needs to be checked</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is in conference state</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_in_conference(who_in_conference: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a call is in conference.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if a call is in conference.\n\n    :param who_in_conference: SIP client on which conference state needs to be checked\n    :type who_in_conference: VoiceClient\n    :return: True if call is in conference state\n    :rtype: bool\n    \"\"\"\n    return who_in_conference.is_in_conference()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_in_conference(who_in_conference)","title":"<code>who_in_conference</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_not_answered","title":"is_call_not_answered","text":"<pre><code>is_call_not_answered(whose_call: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if callee did not pick up the call.</p> <p>The Caller will receive a NO CARRIER or TIMEOUT reply.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if callee did not pick up the call.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Callee</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True is not answered, else False</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_not_answered(whose_call: VoiceClient) -&gt; bool:\n    \"\"\"Verify if callee did not pick up the call.\n\n    The Caller will receive a NO CARRIER or TIMEOUT reply.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if callee did not pick up the call.\n\n    :param whose_call: Callee\n    :type whose_call: VoiceClient\n    :return: True is not answered, else False\n    :rtype: bool\n    \"\"\"\n    return whose_call.is_call_not_answered()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_not_answered(whose_call)","title":"<code>whose_call</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_on_hold","title":"is_call_on_hold","text":"<pre><code>is_call_on_hold(who_is_onhold: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a call is on hold.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if a call is on hold.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP client on which hold state needs to be checked</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is on hold.</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_on_hold(who_is_onhold: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a call is on hold.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if a call is on hold.\n\n    :param who_is_onhold: SIP client on which hold state needs to be checked\n    :type who_is_onhold: VoiceClient\n    :return: True if call is on hold.\n    :rtype: bool\n    \"\"\"\n    return who_is_onhold.is_onhold()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_on_hold(who_is_onhold)","title":"<code>who_is_onhold</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_ringing","title":"is_call_ringing","text":"<pre><code>is_call_ringing(who_is_ringing: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a ringtone is detected on a phone device.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if a ringtone is detected on a phone device.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent used to verify ringtone</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if ringtone is detected</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_ringing(who_is_ringing: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a ringtone is detected on a phone device.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if a ringtone is detected on a phone device.\n\n    :param who_is_ringing: SIP agent used to verify ringtone\n    :type who_is_ringing: VoiceClient\n    :return: True if ringtone is detected\n    :rtype: bool\n    \"\"\"\n    return who_is_ringing.is_ringing()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_ringing(who_is_ringing)","title":"<code>who_is_ringing</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_waiting","title":"is_call_waiting","text":"<pre><code>is_call_waiting(who_is_waiting: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if the phone notifies for the call on other line to be waiting.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if the phone notifies for the call on other line to be waiting.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP Client</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is in waiting</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_call_waiting(who_is_waiting: VoiceClient) -&gt; bool:\n    \"\"\"Verify if the phone notifies for the call on other line to be waiting.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if the phone notifies for the call on other line to be waiting.\n\n    :param who_is_waiting: SIP Client\n    :type who_is_waiting: VoiceClient\n    :return: True if call is in waiting\n    :rtype: bool\n    \"\"\"\n    return who_is_waiting.is_call_waiting()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_call_waiting(who_is_waiting)","title":"<code>who_is_waiting</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_code_ended","title":"is_code_ended","text":"<pre><code>is_code_ended(whose_code_ended: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if the dialed code or number has expired.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if the dialed code or number has expired.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP Client</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if code ended</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_code_ended(whose_code_ended: VoiceClient) -&gt; bool:\n    \"\"\"Verify if the dialed code or number has expired.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if the dialed code or number has expired.\n\n    :param whose_code_ended: SIP Client\n    :type whose_code_ended: VoiceClient\n    :return: True if code ended\n    :rtype: bool\n    \"\"\"\n    return whose_code_ended.is_code_ended()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_code_ended(whose_code_ended)","title":"<code>whose_code_ended</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_dialtone_detected","title":"is_dialtone_detected","text":"<pre><code>is_dialtone_detected(agent: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a dialtone is detected off_hook.</p> <p>Device will be first placed on_hook. This is done to ensure disconnecting any previous sessions.</p> <p>After verifying dial tone device will again go back to on_hook state.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) goes off hook\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent used to verify dialtone.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if dialtone is detected.</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_dialtone_detected(agent: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a dialtone is detected off_hook.\n\n    Device will be first placed on_hook.\n    This is done to ensure disconnecting any previous sessions.\n\n    After verifying dial tone device will again go back to on_hook state.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) goes off hook\n\n    :param agent: SIP agent used to verify dialtone.\n    :type agent: VoiceClient\n    :return: True if dialtone is detected.\n    :rtype: bool\n    \"\"\"\n    agent.on_hook()\n    return agent.detect_dialtone()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_dialtone_detected(agent)","title":"<code>agent</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_incall_connected","title":"is_incall_connected","text":"<pre><code>is_incall_connected(who_is_incall_connected: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a call is incall connected.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) answers to (User)\n- Verify if a call is incall connected.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP client on which connection needs to be checked</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if phone is incall connected.</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_incall_connected(who_is_incall_connected: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a call is incall connected.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) answers to (User)\n        - Verify if a call is incall connected.\n\n    :param who_is_incall_connected: SIP client on which connection needs to be checked\n    :type who_is_incall_connected: VoiceClient\n    :return: True if phone is incall connected.\n    :rtype: bool\n    \"\"\"\n    return who_is_incall_connected.is_incall_connected()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_incall_connected(who_is_incall_connected)","title":"<code>who_is_incall_connected</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_incall_dialing","title":"is_incall_dialing","text":"<pre><code>is_incall_dialing(who_is_incall_dialing: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if a phone is incall and call is dialing/in progress.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if a phone is incall and call is dialing/in progress.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent used to verify incall dialing</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if in progress dialing is detected</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_incall_dialing(who_is_incall_dialing: VoiceClient) -&gt; bool:\n    \"\"\"Verify if a phone is incall and call is dialing/in progress.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if a phone is incall and call is dialing/in progress.\n\n    :param who_is_incall_dialing: SIP agent used to verify incall dialing\n    :type who_is_incall_dialing: VoiceClient\n    :return: True if in progress dialing is detected\n    :rtype: bool\n    \"\"\"\n    return who_is_incall_dialing.is_incall_dialing()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_incall_dialing(who_is_incall_dialing)","title":"<code>who_is_incall_dialing</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_incall_playing_dialtone","title":"is_incall_playing_dialtone","text":"<pre><code>is_incall_playing_dialtone(who_is_playing_incall_dialtone: VoiceClient) -&gt; bool\n</code></pre> <p>Verify phone is connected on one line and playing dialtone on another line.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify phone is connected on one line and playing dialtone on another line.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP Client</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if call is incall playing dialtone state</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_incall_playing_dialtone(who_is_playing_incall_dialtone: VoiceClient) -&gt; bool:\n    \"\"\"Verify phone is connected on one line and playing dialtone on another line.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify phone is connected on one line and playing dialtone on another line.\n\n    :param who_is_playing_incall_dialtone: SIP Client\n    :type who_is_playing_incall_dialtone: VoiceClient\n    :return: True if call is incall playing dialtone state\n    :rtype: bool\n    \"\"\"\n    return who_is_playing_incall_dialtone.is_incall_playing_dialtone()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_incall_playing_dialtone(who_is_playing_incall_dialtone)","title":"<code>who_is_playing_incall_dialtone</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_line_busy","title":"is_line_busy","text":"<pre><code>is_line_busy(on_which_agent: VoiceClient, who_is_busy: VoiceClient) -&gt; bool\n</code></pre> <p>To verify if the caller was notified that the callee is BUSY.</p> <p>Some phone will send this explicitly and will have RINGING 180 as well inside their trace.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- To verify if the caller was notified that the callee is BUSY.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Caller who will receive BUSY</p> required <code>VoiceClient</code> <p>Callee who replies BUSY</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if caller received BUSY, else False</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_line_busy(on_which_agent: VoiceClient, who_is_busy: VoiceClient) -&gt; bool:\n    \"\"\"To verify if the caller was notified that the callee is BUSY.\n\n    Some phone will send this explicitly and will have RINGING 180\n    as well inside their trace.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - To verify if the caller was notified that the callee is BUSY.\n\n    :param on_which_agent: Caller who will receive BUSY\n    :type on_which_agent: VoiceClient\n    :param who_is_busy: Callee who replies BUSY\n    :type who_is_busy: VoiceClient\n    :return: True if caller received BUSY, else False\n    :rtype: bool\n    \"\"\"\n    assert on_which_agent is not who_is_busy, \"Both args cannot be same\"  # noqa: S101\n\n    return on_which_agent.is_line_busy()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_line_busy(on_which_agent)","title":"<code>on_which_agent</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_line_busy(who_is_busy)","title":"<code>who_is_busy</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_off_hook_warning","title":"is_off_hook_warning","text":"<pre><code>is_off_hook_warning(who_has_offhook_warning: VoiceClient) -&gt; bool\n</code></pre> <p>Verify phone has been left off-hook without use for an extended period.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify phone has been left off-hook without use for an extended period.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP Client</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if phone generates off hook warning state</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_off_hook_warning(who_has_offhook_warning: VoiceClient) -&gt; bool:\n    \"\"\"Verify phone has been left off-hook without use for an extended period.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify phone has been left off-hook without use for an extended period.\n\n    :param who_has_offhook_warning: SIP Client\n    :type who_has_offhook_warning: VoiceClient\n    :return: True if phone generates off hook warning state\n    :rtype: bool\n    \"\"\"\n    return who_has_offhook_warning.has_off_hook_warning()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_off_hook_warning(who_has_offhook_warning)","title":"<code>who_has_offhook_warning</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_playing_dialtone","title":"is_playing_dialtone","text":"<pre><code>is_playing_dialtone(who_is_playing_dialtone: VoiceClient) -&gt; bool\n</code></pre> <p>Verify if the phone is playing a dialtone.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify if the phone is playing a dialtone.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP Client</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if dialtone is playing else False</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_playing_dialtone(who_is_playing_dialtone: VoiceClient) -&gt; bool:\n    \"\"\"Verify if the phone is playing a dialtone.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify if the phone is playing a dialtone.\n\n    :param who_is_playing_dialtone: SIP Client\n    :type who_is_playing_dialtone: VoiceClient\n    :return: True if dialtone is playing else False\n    :rtype: bool\n    \"\"\"\n    return who_is_playing_dialtone.is_playing_dialtone()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_playing_dialtone(who_is_playing_dialtone)","title":"<code>who_is_playing_dialtone</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_user_profile_present","title":"is_user_profile_present","text":"<pre><code>is_user_profile_present(sip_proxy: VoiceServer, whose_profile: VoiceClient) -&gt; bool\n</code></pre> <p>Check whether the user profile is registered on the SIP Server or not.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Make sure that (User) is successfully registered.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceServer</code> <p>SIP Server</p> required <code>VoiceClient</code> <p>Phone device to be checked</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if phone device is registered on the SIP Server</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def is_user_profile_present(sip_proxy: VoiceServer, whose_profile: VoiceClient) -&gt; bool:\n    \"\"\"Check whether the user profile is registered on the SIP Server or not.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Make sure that (User) is successfully registered.\n\n    :param sip_proxy: SIP Server\n    :type sip_proxy: VoiceServer\n    :param whose_profile: Phone device to be checked\n    :type whose_profile: VoiceClient\n    :return: True if phone device is registered on the SIP Server\n    :rtype: bool\n    \"\"\"\n    return whose_profile.number in sip_proxy.sipserver_get_online_users()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_user_profile_present(sip_proxy)","title":"<code>sip_proxy</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.is_user_profile_present(whose_profile)","title":"<code>whose_profile</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.merge_two_calls","title":"merge_two_calls","text":"<pre><code>merge_two_calls(who_is_conferencing: VoiceClient) -&gt; None\n</code></pre> <p>Merge the two calls for conference calling.</p> <p>Ensure call waiting must be enabled. There must be a call on other line to add to conference.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) presses R3 and initiates 3-Way Conference\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent that adds all calls in a conference.</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def merge_two_calls(who_is_conferencing: VoiceClient) -&gt; None:\n    \"\"\"Merge the two calls for conference calling.\n\n    Ensure call waiting must be enabled.\n    There must be a call on other line to add to conference.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) presses R3 and initiates 3-Way Conference\n\n    :param who_is_conferencing: SIP agent that adds all calls in a conference.\n    :type who_is_conferencing: VoiceClient\n    \"\"\"\n    client: SIPPhone = who_is_conferencing\n    client.merge_two_calls()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.merge_two_calls(who_is_conferencing)","title":"<code>who_is_conferencing</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.place_call_offhold","title":"place_call_offhold","text":"<pre><code>place_call_offhold(who_places: VoiceClient) -&gt; None\n</code></pre> <p>Place an ongoing call on hold to off-hold.</p> <p>There must be an active call to be placed off hold.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) presses flash hook\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent that is suppose to place the call off-hold.</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def place_call_offhold(who_places: VoiceClient) -&gt; None:\n    \"\"\"Place an ongoing call on hold to off-hold.\n\n    There must be an active call to be placed off hold.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) presses flash hook\n\n    :param who_places: SIP agent that is suppose to place the call off-hold.\n    :type who_places: VoiceClient\n    \"\"\"\n    client: SIPPhone = who_places\n    client.place_call_offhold()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.place_call_offhold(who_places)","title":"<code>who_places</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.place_call_onhold","title":"place_call_onhold","text":"<pre><code>place_call_onhold(who_places: VoiceClient) -&gt; None\n</code></pre> <p>Place an ongoing call on-hold.</p> <p>There must be an active call to be placed on hold.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) presses flash hook\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent that is suppose to place the call on-hold.</p> required <p>Raises:</p> Type Description <code>VoiceError</code> <p>If there is no on-going call</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def place_call_onhold(who_places: VoiceClient) -&gt; None:\n    \"\"\"Place an ongoing call on-hold.\n\n    There must be an active call to be placed on hold.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) presses flash hook\n\n    :param who_places: SIP agent that is suppose to place the call on-hold.\n    :type who_places: VoiceClient\n    :raises VoiceError: If there is no on-going call\n    \"\"\"\n    client: SIPPhone = who_places\n    if not client.is_connected() and not client.is_incall_connected():\n        msg = \"No active call in place!!\"\n        raise VoiceError(msg)\n    client.place_call_onhold()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.place_call_onhold(who_places)","title":"<code>who_places</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.press_R_button","title":"press_R_button","text":"<pre><code>press_R_button(who_presses: VoiceClient) -&gt; None\n</code></pre> <p>Press the R button.</p> <p>Used when we put a call on hold, or during dialing.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) presses R button\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Agent that presses the R button.</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def press_R_button(who_presses: VoiceClient) -&gt; None:  # pylint: disable=invalid-name\n    \"\"\"Press the R button.\n\n    Used when we put a call on hold, or during dialing.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) presses R button\n\n    :param who_presses: Agent that presses the R button.\n    :type who_presses: VoiceClient\n    \"\"\"\n    client: SIPPhone = who_presses\n    client.press_R_button()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.press_R_button(who_presses)","title":"<code>who_presses</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.put_phone_offhook","title":"put_phone_offhook","text":"<pre><code>put_phone_offhook(who_puts_offhook: VoiceClient) -&gt; None\n</code></pre> <p>Put the phone off hook.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) goes off Hook.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent who puts phone off hook</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def put_phone_offhook(who_puts_offhook: VoiceClient) -&gt; None:\n    \"\"\"Put the phone off hook.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) goes off Hook.\n\n    :param who_puts_offhook: SIP agent who puts phone off hook\n    :type who_puts_offhook: VoiceClient\n    \"\"\"\n    who_puts_offhook.off_hook()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.put_phone_offhook(who_puts_offhook)","title":"<code>who_puts_offhook</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.remove_user_profile","title":"remove_user_profile","text":"<pre><code>remove_user_profile(where_to_remove: VoiceServer, whom_to_remove: VoiceClient) -&gt; None\n</code></pre> <p>Deregister user profile from the SIP Server.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Remove the user profile of (User A) from SIP Server.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceServer</code> <p>SIP Server</p> required <code>VoiceClient</code> <p>Phone device to be removed</p> required <p>Raises:</p> Type Description <code>VoiceError</code> <p>if the device does not already exist on the SIP Server</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def remove_user_profile(\n    where_to_remove: VoiceServer,\n    whom_to_remove: VoiceClient,\n) -&gt; None:\n    \"\"\"Deregister user profile from the SIP Server.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Remove the user profile of (User A) from SIP Server.\n\n    :param where_to_remove: SIP Server\n    :type where_to_remove: VoiceServer\n    :param whom_to_remove: Phone device to be removed\n    :type whom_to_remove: VoiceClient\n    :raises VoiceError: if the device does not already exist on the SIP Server\n    \"\"\"\n    if whom_to_remove.number not in where_to_remove.sipserver_get_online_users():\n        msg = f\"User {whom_to_remove.name} is not registered\"\n        raise VoiceError(msg)\n    where_to_remove.remove_endpoint_from_sipserver(whom_to_remove.number)\n    # TODO: the restart, as it might not be needed for some Voice servers, should be\n    # part of the remove_enpoint_...() method\n    where_to_remove.sipserver_restart()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.remove_user_profile(where_to_remove)","title":"<code>where_to_remove</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.remove_user_profile(whom_to_remove)","title":"<code>whom_to_remove</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.set_sip_expiry_time","title":"set_sip_expiry_time","text":"<pre><code>set_sip_expiry_time(sip_proxy: VoiceServer, to_what_time: int = 60) -&gt; None\n</code></pre> <p>Modify the call expires timer in the config file of the sip_proxy.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Modify the call expires timer in the config file of the sip_proxy.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceServer</code> <p>SIP Server</p> required <code>int</code> <p>New expiry time to be set, defaults to 60</p> <code>60</code> <p>Raises:</p> Type Description <code>VoiceError</code> <p>if the sipserver is not installed</p> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def set_sip_expiry_time(sip_proxy: VoiceServer, to_what_time: int = 60) -&gt; None:\n    \"\"\"Modify the call expires timer in the config file of the sip_proxy.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Modify the call expires timer in the config file of the sip_proxy.\n\n    :param sip_proxy: SIP Server\n    :type sip_proxy: VoiceServer\n    :param to_what_time: New expiry time to be set, defaults to 60\n    :type to_what_time: int\n    :raises VoiceError: if the sipserver is not installed\n    \"\"\"\n    if sip_proxy.sipserver_status() in [\"Not installed\", \"Not Running\"]:\n        msg = \"Install the sipserver first\"\n        raise VoiceError(msg)\n    sip_proxy.sipserver_set_expire_timer(\n        to_timer=to_what_time,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.set_sip_expiry_time(sip_proxy)","title":"<code>sip_proxy</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.set_sip_expiry_time(to_what_time)","title":"<code>to_what_time</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.shutdown_phone","title":"shutdown_phone","text":"<pre><code>shutdown_phone(target_phone: VoiceClient) -&gt; None\n</code></pre> <p>Go on_hook and stop the phone application.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Go on_hook and stop the phone application.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>Target phone to be initialized.</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def shutdown_phone(target_phone: VoiceClient) -&gt; None:\n    \"\"\"Go on_hook and stop the phone application.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Go on_hook and stop the phone application.\n\n    :param target_phone: Target phone to be initialized.\n    :type target_phone: VoiceClient\n    \"\"\"\n    dev = target_phone\n    try:\n        dev.on_hook()\n    except Exception:  # pylint: disable=broad-except  # noqa: BLE001  # BOARDFARM-4982\n        _LOGGER.warning(colored(\"Cannot put phone onhook\", color=\"yellow\"))\n    dev.phone_kill()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.shutdown_phone(target_phone)","title":"<code>target_phone</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.stop_and_start_sip_server","title":"stop_and_start_sip_server","text":"<pre><code>stop_and_start_sip_server(sip_proxy: VoiceServer) -&gt; Generator[None, Any, None]\n</code></pre> <p>Stop and start the SIP server.</p> <p>:yield: in between stopping and starting the SIP server</p> <p>Parameters:</p> Name Type Description Default <code>VoiceServer</code> <p>The SIP server to be restarted</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>@contextmanager\ndef stop_and_start_sip_server(sip_proxy: VoiceServer) -&gt; Generator[None, Any, None]:\n    \"\"\"Stop and start the SIP server.\n\n    :param sip_proxy: The SIP server to be restarted\n    :type sip_proxy: VoiceServer\n    :yield: in between stopping and starting the SIP server\n    :rtype: Generator[None, Any, None]\n    \"\"\"\n    try:\n        sip_proxy.stop()\n        yield\n    finally:\n        sip_proxy.start()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.stop_and_start_sip_server(sip_proxy)","title":"<code>sip_proxy</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.tcpdump","title":"tcpdump","text":"<pre><code>tcpdump(dev: VoiceServer, fname: str, filters: str = '') -&gt; Generator[str]\n</code></pre> <p>Start packet capture using tcpdump and kills the process at the end.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Start the packets capture to be able to analyze SIP/RTP/RTCP protocol\n</code></pre> <p>:yield: process id</p> <p>Parameters:</p> Name Type Description Default <code>VoiceServer</code> <p>device object for a VoiceServer</p> required <code>str</code> <p>name of the pcap file to which the capture will be stored</p> required <code>str</code> <p>additional filters for capture, defaults to \"\"</p> <code>''</code> Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>@contextmanager\ndef tcpdump(\n    dev: VoiceServer,\n    fname: str,\n    filters: str = \"\",\n) -&gt; Generator[str]:\n    \"\"\"Start packet capture using tcpdump and kills the process at the end.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Start the packets capture to be able to analyze SIP/RTP/RTCP protocol\n\n    :param dev: device object for a VoiceServer\n    :type dev: VoiceServer\n    :param fname: name of the pcap file to which the capture will be stored\n    :type fname: str\n    :param filters: additional filters for capture, defaults to \"\"\n    :type filters: str\n    :yield: process id\n    :rtype: Generator[str, None, None]\n    \"\"\"\n    with dev.tcpdump_capture(\n        fname=fname,\n        interface=dev.iface_dut,\n        additional_args=f\"-s0 {filters}\",\n    ) as pid:\n        yield pid\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.tcpdump(dev)","title":"<code>dev</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.tcpdump(fname)","title":"<code>fname</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.tcpdump(filters)","title":"<code>filters</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.toggle_call","title":"toggle_call","text":"<pre><code>toggle_call(who_toggles: VoiceClient) -&gt; None\n</code></pre> <p>Toggle between the calls.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- (User) presses R2 button\n</code></pre> <p>Need to first validate, there is an incoming call on other line. If not throw an exception.</p> <p>Parameters:</p> Name Type Description Default <code>VoiceClient</code> <p>SIP agent who is suppose to toggle the call</p> required Source code in <code>boardfarm3/use_cases/voice.py</code> <pre><code>def toggle_call(who_toggles: VoiceClient) -&gt; None:\n    \"\"\"Toggle between the calls.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - (User) presses R2 button\n\n    Need to first validate, there is an incoming call on other line.\n    If not throw an exception.\n\n    :param who_toggles: SIP agent who is suppose to toggle the call\n    :type who_toggles: VoiceClient\n    \"\"\"\n    who_toggles.toggle_call()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.voice.toggle_call(who_toggles)","title":"<code>who_toggles</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi","title":"wifi","text":"<p>Wi-Fi Use Cases library.</p> <p>All APIs are independent of board under test.</p> <p>Functions:</p> Name Description <code>check_and_connect_to_wifi</code> <p>Check if specific Wi-Fi is enabled and try to connect appropriate client.</p> <code>connect_wifi_client</code> <p>Connect client to Wi-Fi.</p> <code>disconnect_wifi_client</code> <p>Disconnect client from Wi-Fi.</p> <code>enable_and_disable_monitor_mode</code> <p>Enable and disbale monitor mode.</p> <code>get_bssid</code> <p>Get the Wi-Fi Basic Service Set Identifier.</p> <code>get_passphrase</code> <p>Get the Wi-Fi passphrase.</p> <code>get_ssid</code> <p>Get the Wi-Fi SSID.</p> <code>get_wifi_clients</code> <p>Return list of wlan_devices based on filters network and band type.</p> <code>is_wifi_connected</code> <p>Get the state of the interface.</p> <code>list_wifi_ssid</code> <p>Return the list of Wi-Fi SSIDs.</p> <code>scan_ssid_name</code> <p>Scan for the particular SSID based on the network type and band.</p> <code>wifi_check_ssid</code> <p>Check the SSID provided is present in the scan list.</p>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.check_and_connect_to_wifi","title":"check_and_connect_to_wifi","text":"<pre><code>check_and_connect_to_wifi(who_to_connect: WLAN, cpe: CPE) -&gt; None\n</code></pre> <p>Check if specific Wi-Fi is enabled and try to connect appropriate client.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Check if specific Wi-Fi is enabled and try to connect appropriate client.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>Wi-Fi client device</p> required <code>CPE</code> <p>the CPE to connect to</p> required Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def check_and_connect_to_wifi(who_to_connect: WLAN, cpe: CPE) -&gt; None:\n    \"\"\"Check if specific Wi-Fi is enabled and try to connect appropriate client.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Check if specific Wi-Fi is enabled and try to connect appropriate client.\n\n    :param who_to_connect: Wi-Fi client device\n    :type who_to_connect: WLAN\n    :param cpe: the CPE to connect to\n    :type cpe: CPE\n    \"\"\"\n    wifi = cpe.sw.wifi\n    ssid, bssid, passphrase = wifi.enable_wifi(\n        who_to_connect.network,\n        who_to_connect.band,\n    )\n    # Connect appropriate client to the network\n    who_to_connect.wifi_client_connect(\n        ssid_name=ssid,\n        password=passphrase,\n        bssid=bssid,\n        security_mode=who_to_connect.authentication,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.check_and_connect_to_wifi(who_to_connect)","title":"<code>who_to_connect</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.check_and_connect_to_wifi(cpe)","title":"<code>cpe</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.connect_wifi_client","title":"connect_wifi_client","text":"<pre><code>connect_wifi_client(\n    who_to_connect: WLAN,\n    cpe: CPE,\n    ssid: str | None = None,\n    password: str | None = None,\n    bssid: str | None = None,\n) -&gt; None\n</code></pre> <p>Connect client to Wi-Fi.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Verify that the connection to 2.4GHz private Wi-Fi SSID is successful.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>client to connect</p> required <code>CPE</code> <p>the CPE to connect to</p> required <code>str | None</code> <p>SSID of the network to connect</p> <code>None</code> <code>str | None</code> <p>password of the network to connect</p> <code>None</code> <code>str | None</code> <p>BSSID of the network to connect</p> <code>None</code> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def connect_wifi_client(\n    who_to_connect: WLAN,\n    cpe: CPE,\n    ssid: str | None = None,\n    password: str | None = None,\n    bssid: str | None = None,\n) -&gt; None:\n    \"\"\"Connect client to Wi-Fi.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Verify that the connection to 2.4GHz private Wi-Fi SSID is successful.\n\n    :param who_to_connect: client to connect\n    :type who_to_connect: WLAN\n    :param cpe: the CPE to connect to\n    :type cpe: CPE\n    :param ssid: SSID of the network to connect\n    :type ssid: str | None\n    :param password: password of the network to connect\n    :type password: str | None\n    :param bssid: BSSID of the network to connect\n    :type bssid: str | None\n    \"\"\"\n    ssid = (\n        ssid if ssid else get_ssid(who_to_connect.network, who_to_connect.band, cpe=cpe)\n    )\n    bssid = (\n        bssid\n        if bssid\n        else get_bssid(who_to_connect.network, who_to_connect.band, cpe=cpe)\n    )\n    password = password if password else get_passphrase(who_to_connect.network, cpe=cpe)\n    who_to_connect.wifi_client_connect(\n        ssid_name=ssid,\n        password=password,\n        security_mode=who_to_connect.authentication,\n        bssid=bssid,\n    )\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.connect_wifi_client(who_to_connect)","title":"<code>who_to_connect</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.connect_wifi_client(cpe)","title":"<code>cpe</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.connect_wifi_client(ssid)","title":"<code>ssid</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.connect_wifi_client(password)","title":"<code>password</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.connect_wifi_client(bssid)","title":"<code>bssid</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.disconnect_wifi_client","title":"disconnect_wifi_client","text":"<pre><code>disconnect_wifi_client(who_to_disconnect: WLAN) -&gt; None\n</code></pre> <p>Disconnect client from Wi-Fi.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Disconnect the client from 5GHz Wi-Fi network\n- Disconnect the client from 2.4GHz Wi-Fi network\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>client to disconnect</p> required Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def disconnect_wifi_client(who_to_disconnect: WLAN) -&gt; None:\n    \"\"\"Disconnect client from Wi-Fi.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Disconnect the client from 5GHz Wi-Fi network\n        - Disconnect the client from 2.4GHz Wi-Fi network\n\n    :param who_to_disconnect: client to disconnect\n    :type who_to_disconnect: WLAN\n    \"\"\"\n    who_to_disconnect.wifi_disconnect()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.disconnect_wifi_client(who_to_disconnect)","title":"<code>who_to_disconnect</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.enable_and_disable_monitor_mode","title":"enable_and_disable_monitor_mode","text":"<pre><code>enable_and_disable_monitor_mode(device: WLAN) -&gt; Generator[None, Any, None]\n</code></pre> <p>Enable and disbale monitor mode.</p> <p>:yield: in between enabling and disabling monitor mode</p> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>device instance</p> required Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>@contextmanager\ndef enable_and_disable_monitor_mode(device: WLAN) -&gt; Generator[None, Any, None]:\n    \"\"\"Enable and disbale monitor mode.\n\n    :param device: device instance\n    :type device: WLAN\n    :yield: in between enabling and disabling monitor mode\n    :rtype: Generator[None, Any, None]\n    \"\"\"\n    try:\n        device.enable_monitor_mode()\n        yield\n    finally:\n        device.disable_monitor_mode()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.enable_and_disable_monitor_mode(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_bssid","title":"get_bssid","text":"<pre><code>get_bssid(network: str, band: str, cpe: CPE, mode: str = 'console') -&gt; str | None\n</code></pre> <p>Get the Wi-Fi Basic Service Set Identifier.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Get the Wi-Fi Basic Service Set Identifier.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type of the client E.g: private, guest, community</p> required <code>str</code> <p>band of the client</p> required <code>CPE</code> <p>the CPE that is beaming the SSID</p> required <code>str</code> <p>mode to get the BSSID. E.g. console (default), snmp, acs, dmcli</p> <code>'console'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>MAC physical address of the access point</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>not implemented for modes other than console</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def get_bssid(network: str, band: str, cpe: CPE, mode: str = \"console\") -&gt; str | None:\n    \"\"\"Get the Wi-Fi Basic Service Set Identifier.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Get the Wi-Fi Basic Service Set Identifier.\n\n    :param network: network type of the client E.g: private, guest, community\n    :type network: str\n    :param band: band of the client\n    :type band: str\n    :param cpe: the CPE that is beaming the SSID\n    :type cpe: CPE\n    :param mode: mode to get the BSSID. E.g. console (default), snmp, acs, dmcli\n    :type mode: str\n    :return: MAC physical address of the access point\n    :rtype: str | None\n    :raises NotImplementedError: not implemented for modes other than console\n    \"\"\"\n    if mode == \"console\":\n        return cpe.sw.wifi.get_bssid(network, band)\n    msg = \"Not implemented for modes other than console\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_bssid(network)","title":"<code>network</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_bssid(band)","title":"<code>band</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_bssid(cpe)","title":"<code>cpe</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_bssid(mode)","title":"<code>mode</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_passphrase","title":"get_passphrase","text":"<pre><code>get_passphrase(network: str, cpe: CPE) -&gt; str\n</code></pre> <p>Get the Wi-Fi passphrase.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Get the Wi-Fi passphrase.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type of the client E.g: private, guest, community</p> required <code>CPE</code> <p>the CPE that is beaming the SSID</p> required <p>Returns:</p> Type Description <code>str</code> <p>encrypted password for a network</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def get_passphrase(network: str, cpe: CPE) -&gt; str:\n    \"\"\"Get the Wi-Fi passphrase.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Get the Wi-Fi passphrase.\n\n    :param network: network type of the client E.g: private, guest, community\n    :type network: str\n    :param cpe: the CPE that is beaming the SSID\n    :type cpe: CPE\n    :return: encrypted password for a network\n    :rtype: str\n    \"\"\"\n    iface = cpe.sw.wifi.wlan_ifaces[network][\"5\"]\n    return cpe.sw.wifi.get_passphrase(iface=iface)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_passphrase(network)","title":"<code>network</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_passphrase(cpe)","title":"<code>cpe</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_ssid","title":"get_ssid","text":"<pre><code>get_ssid(network: str, band: str, cpe: CPE, mode: str = 'console') -&gt; str | None\n</code></pre> <p>Get the Wi-Fi SSID.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Get the Wi-Fi SSID.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type of the client E.g: private, guest, community</p> required <code>str</code> <p>Wi-Fi band of the client</p> required <code>CPE</code> <p>the CPE that is beaming the SSID</p> required <code>str</code> <p>way to retrieve the information, defaults to \"console\"</p> <code>'console'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>SSID of the Wi-Fi for a given network type and band</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>not implemented for modes other than console</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def get_ssid(\n    network: str,\n    band: str,\n    cpe: CPE,\n    mode: str = \"console\",\n) -&gt; str | None:\n    \"\"\"Get the Wi-Fi SSID.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Get the Wi-Fi SSID.\n\n    :param network: network type of the client E.g: private, guest, community\n    :type network: str\n    :param band: Wi-Fi band of the client\n    :type band: str\n    :param cpe: the CPE that is beaming the SSID\n    :type cpe: CPE\n    :param mode: way to retrieve the information, defaults to \"console\"\n    :param mode: mode to get the SSID E.g. snmp, acs, dmcli, console (default)\n    :type mode: str\n    :raises NotImplementedError: not implemented for modes other than console\n    :return: SSID of the Wi-Fi for a given network type and band\n    :rtype: str | None\n    \"\"\"\n    if mode == \"console\":\n        return cpe.sw.wifi.get_ssid(network, band)\n    msg = \"Not implemented for modes other than console\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_ssid(network)","title":"<code>network</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_ssid(band)","title":"<code>band</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_ssid(cpe)","title":"<code>cpe</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_ssid(mode)","title":"<code>mode</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_wifi_clients","title":"get_wifi_clients","text":"<pre><code>get_wifi_clients(network: str, band: str) -&gt; list[WLAN]\n</code></pre> <p>Return list of wlan_devices based on filters network and band type.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Return list of wlan_devices based on filters network and band type.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>network type of the client Eg: private, guest, community</p> required <code>str</code> <p>band of the client in GHz</p> required <p>Returns:</p> Type Description <code>list[WLAN]</code> <p>list of WLAN devices</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def get_wifi_clients(network: str, band: str) -&gt; list[WLAN]:\n    \"\"\"Return list of wlan_devices based on filters network and band type.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Return list of wlan_devices based on filters network and band type.\n\n    :param network: network type of the client Eg: private, guest, community\n    :type network: str\n    :param band: band of the client in GHz\n    :type band: str\n    :return: list of WLAN devices\n    :rtype: list[WLAN]\n    \"\"\"\n    wifi_devices = get_device_manager().get_devices_by_type(\n        WLAN,  # type: ignore[type-abstract]\n    )\n    return [\n        device\n        for device in wifi_devices.values()\n        if device.network == network and device.band == band\n    ]\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_wifi_clients(network)","title":"<code>network</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.get_wifi_clients(band)","title":"<code>band</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.is_wifi_connected","title":"is_wifi_connected","text":"<pre><code>is_wifi_connected(device: WLAN) -&gt; bool\n</code></pre> <p>Get the state of the interface.</p> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>device instance</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if connected</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def is_wifi_connected(device: WLAN) -&gt; bool:\n    \"\"\"Get the state of the interface.\n\n    :param device: device instance\n    :type device: WLAN\n    :return: True if connected\n    :rtype: bool\n    \"\"\"\n    return device.is_wlan_connected()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.is_wifi_connected(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.list_wifi_ssid","title":"list_wifi_ssid","text":"<pre><code>list_wifi_ssid(device: WLAN) -&gt; list[str]\n</code></pre> <p>Return the list of Wi-Fi SSIDs.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Return the list of Wi-Fi SSIDs.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>WLAN device instance</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list of Wi-Fi SSIDs</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def list_wifi_ssid(device: WLAN) -&gt; list[str]:\n    \"\"\"Return the list of Wi-Fi SSIDs.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Return the list of Wi-Fi SSIDs.\n\n    :param device: WLAN device instance\n    :type device: WLAN\n    :return: list of Wi-Fi SSIDs\n    :rtype: list[str]\n    \"\"\"\n    return device.list_wifi_ssids()\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.list_wifi_ssid(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.scan_ssid_name","title":"scan_ssid_name","text":"<pre><code>scan_ssid_name(device: WLAN, cpe: CPE) -&gt; bool\n</code></pre> <p>Scan for the particular SSID based on the network type and band.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Scan for the particular SSID based on the network type and band.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>WLAN device instance</p> required <code>CPE</code> <p>the CPE to connect to</p> required <p>Returns:</p> Type Description <code>bool</code> <p>true if the SSID is available, false otherwise</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def scan_ssid_name(device: WLAN, cpe: CPE) -&gt; bool:\n    \"\"\"Scan for the particular SSID based on the network type and band.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Scan for the particular SSID based on the network type and band.\n\n    :param device: WLAN device instance\n    :type device: WLAN\n    :param cpe: the CPE to connect to\n    :type cpe: CPE\n    :return: true if the SSID is available, false otherwise\n    :rtype: bool\n    \"\"\"\n    ssid_name = get_ssid(device.network, device.band, cpe=cpe)\n    return wifi_check_ssid(device, ssid_name)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.scan_ssid_name(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.scan_ssid_name(cpe)","title":"<code>cpe</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.wifi_check_ssid","title":"wifi_check_ssid","text":"<pre><code>wifi_check_ssid(device: WLAN, ssid_name: str) -&gt; bool\n</code></pre> <p>Check the SSID provided is present in the scan list.</p> <p>.. hint:: This Use Case implements statements from the test suite such as:</p> <pre><code>- Check the SSID provided is present in the scan list.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>WLAN</code> <p>WLAN device instance</p> required <code>str</code> <p>SSID name to be verified</p> required <p>Returns:</p> Type Description <code>bool</code> <p>true if the ssid_name is available, false otherwise</p> Source code in <code>boardfarm3/use_cases/wifi.py</code> <pre><code>def wifi_check_ssid(device: WLAN, ssid_name: str) -&gt; bool:\n    \"\"\"Check the SSID provided is present in the scan list.\n\n    .. hint:: This Use Case implements statements from the test suite such as:\n\n        - Check the SSID provided is present in the scan list.\n\n    :param device: WLAN device instance\n    :type device: WLAN\n    :param ssid_name: SSID name to be verified\n    :type ssid_name: str\n    :return: true if the ssid_name is available, false otherwise\n    :rtype: bool\n    \"\"\"\n    return ssid_name in list_wifi_ssid(device)\n</code></pre>"},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.wifi_check_ssid(device)","title":"<code>device</code>","text":""},{"location":"reference/use_cases/#boardfarm3.use_cases.wifi.wifi_check_ssid(ssid_name)","title":"<code>ssid_name</code>","text":""}]}